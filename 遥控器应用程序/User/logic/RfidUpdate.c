/********************************************************************************* 文件名称：RfidUpdate.c* 作    者：马如意   * 版    本：V1.0* 日    期：2017.06.21* 功能描述: 实现RFID的协议层处理。* 修改说明：   **       >>>>  在工程中的位置  <<<<*             3-应用层*          √ 2-协议层*             1-硬件驱动层********************************************************************************** @copy* <h2><center>&copy; COPYRIGHT 天津华宁电子有限公司 研发中心 软件部</center></h2>*********************************************************************************//********************************************************************************* .h头文件*********************************************************************************/#include	"includes.h"#if (ONLINE_UPDATE_SELF_PRG_PT_FLAG	!= DISABLED)/********************************************************************************* #define宏定义*********************************************************************************/__packed typedef struct{	u8 u8DestDevID;	RFID_UPDATE_FRAME_TYPE stFrame;		u32 u32SendTimes;		u32 u32SendInterval;		}RFIDUPDATE_MNG_DATA_TYPE;/********************************************************************************* 常量定义*********************************************************************************/#define	RFIDUPDATE_SEND_BUF_SIZE			0x02#define	RFIDUPDATE_RECV_BUF_SIZE			256#define	RFIDMNG_UPDATE_TASK_TIME_SET		10#define	RSSI_OFFSET_VALUE					74#define	RFID_SEND_INTERVAL_CLOSED			0xFFFFFFFF//等待时间无效(关闭)#define	RFID_SEND_TIMES_LIMITLESS			0xFFFF//无限次发送#define	RFID_PRG_SEND_TIMES					0x03#define	RFID_PRG_SEND_INTERVAL				70#define ACTION_INFO_HEAD_SIZE				32				//配置文件头部长度/********************************************************************************* 变量定义*********************************************************************************/static RFIDUPDATE_MNG_DATA_TYPE	s_stRfidSendBuf[RFIDUPDATE_SEND_BUF_SIZE];static u32 s_u32RfidSendBufWrite;static u32 s_u32RfidSendBufRead;static u32 s_u32SendTimer = 0x00;	static u8 s_u8RfidRecvBuf[RFIDUPDATE_RECV_BUF_SIZE];static u32 s_u32RfidRecvBufWrite;static u32 s_u32DownloaderId;static u32 s_u32RecvPacketBackup;static u32 s_u32RecvPacketTimes;   //jhystatic u32 s_u32WriteAddr;extern OS_STK  RfidMng_task_stk[RFIDMNG_TASK_STK_SIZE];			//开辟任务堆栈extern OS_EVENT *s_stRfidRecvd ;static u8 u8tmp_Update[64];extern u32 YKQUpdateStatus;extern ACTION_INFO ActionInformation;u8 cachuFlag = 0;u8 RebootSet = 0;static u8 RecvActionInfoFlag = 0;static u32 writeaddr = 0;/********************************************************************************* 函数声明*********************************************************************************/static u32 RfidUpdateVersionDwlProc(RFID_UPDATE_FRAME_TYPE *frame);static u32 RfidUpdateVersionWriteProc(RFID_UPDATE_FRAME_TYPE *frame);static u32 RfidUpdateCodeDwlProc(RFID_UPDATE_FRAME_TYPE *frame);static u32 RfidUpdateCodeWriteProc(RFID_UPDATE_FRAME_TYPE *frame);static u32 RfidUpdateTransEndProc(RFID_UPDATE_FRAME_TYPE *frame);/****LOGIC 状态函数指针数组****/u32 (*RfidUpdateProcFuncs[])(RFID_UPDATE_FRAME_TYPE *frame) ={	RfidUpdateTransEndProc,	RfidUpdateCodeWriteProc,	RfidUpdateCodeDwlProc,	RfidUpdateVersionWriteProc,	RfidUpdateVersionDwlProc,		NULL};static u32 WL_RfidUpdateVersionDwlProc(RFID_UPDATE_FRAME_TYPE *frame);static u32 WL_RfidUpdateVersionWriteProc(RFID_UPDATE_FRAME_TYPE *frame);static u32 WL_RfidUpdateCodeDwlProc(RFID_UPDATE_FRAME_TYPE *frame);static u32 WL_RfidUpdateCodeWriteProc(RFID_UPDATE_FRAME_TYPE *frame);static u32 WL_RfidUpdateTransEndProc(RFID_UPDATE_FRAME_TYPE *frame);/****LOGIC 状态函数指针数组****/u32 (*WL_RfidUpdateProcFuncs[])(RFID_UPDATE_FRAME_TYPE *frame) ={	WL_RfidUpdateTransEndProc,	WL_RfidUpdateCodeWriteProc,	WL_RfidUpdateCodeDwlProc,	WL_RfidUpdateVersionWriteProc,	WL_RfidUpdateVersionDwlProc,		NULL};static u32 ActionInfoSynchroVersionDwlProc(RFID_UPDATE_FRAME_TYPE *frame);static u32 ActionInfoSynchroVersionWriteProc(RFID_UPDATE_FRAME_TYPE *frame);static u32 ActionInfoSynchroCodeDwlProc(RFID_UPDATE_FRAME_TYPE *frame);static u32 ActionInfoSynchroCodeWriteProc(RFID_UPDATE_FRAME_TYPE *frame);static u32 ActionInfoSynchroTransEndProc(RFID_UPDATE_FRAME_TYPE *frame);u32 (*ActionInfoSynchroProcFuncs[])(RFID_UPDATE_FRAME_TYPE *frame) ={	ActionInfoSynchroTransEndProc,	ActionInfoSynchroCodeWriteProc,	ActionInfoSynchroCodeDwlProc,	ActionInfoSynchroVersionWriteProc,	ActionInfoSynchroVersionDwlProc,		NULL};/********************************************************************************* 函数定义*********************************************************************************//*********************************************************************************** 函数名称: RfidUpdateMngInint** 功能描述：RFID管理任务初始化** 函数输入：无** 函数输出：None** 注意事项：**********************************************************************************/void RfidUpdateMngInint(void){	u8 u8I = 0x00;		s_u32RfidSendBufWrite = 0x00;	s_u32RfidSendBufRead = 0x00;	s_u32SendTimer = 0x00;	u32 u32Y = 0;	memset(s_stRfidSendBuf,0x00,sizeof(s_stRfidSendBuf)*RFIDUPDATE_SEND_BUF_SIZE);	s_u32RfidRecvBufWrite = 0x00;	s_u32DownloaderId = 0x00;	s_u32RecvPacketBackup = 0x00;	s_u32WriteAddr = 0x00;	s_stRfidRecvd->OSEventCnt = 0x00;		memset(s_u8RfidRecvBuf,0x00,sizeof(s_u8RfidRecvBuf));	if(g_u32ID == B_type)	{		u8I = GetRfidCurStatus();//获取芯片状态		if(u8I == CC1101_STATE_RX_OVERFLOW)			RfidStrobe(CC1101_SFRX);    //冲洗 RX FIFO buffer.		else if(u8I == CC1101_STATE_TX_UNDERFLOW)			RfidStrobe(CC1101_SFTX);    //冲洗 TX FIFO buffer.		else if(u8I == CC1101_STATE_IDLE)			SetRfidSRX();		else			SetRfidSRX();	}	else	{		LogicRunInfApi(LOGIC_GET_RUN_STATUS,&u32Y);			if(u32Y != LOGIC_STATUS_ACTION_MESS_REQ)		{			OSTimeDly(5);			SendSetupToWl(RFID_PRG_ININT_SYNC1);			OSTimeDly(5);		}	}}/*********************************************************************************** 函数名称: RfidUpdateSendPrgData** 功能描述：RFID无线发送程序信息** 函数输入：无** 函数输出：None** 注意事项：**********************************************************************************/u32 RfidUpdateSendPrgData(u8 u8DevID,u32 u32FrameType,u32 u32PacketNumb,u8 *data,u32 u32DataLength){	#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */		OS_CPU_SR  cpu_sr = 0;	#endif	u8 u8Temp = 0x00;	u32 u32ReturnFlag = 0x01;	u16 u16TxBufWriteBackup = 0x00;		/**防止队列满的情况出现**/	u16TxBufWriteBackup = s_u32RfidSendBufWrite;	u16TxBufWriteBackup++;	u16TxBufWriteBackup %= RFIDUPDATE_SEND_BUF_SIZE;			if((u16TxBufWriteBackup != s_u32RfidSendBufRead))	{				OS_ENTER_CRITICAL(); 					s_stRfidSendBuf[s_u32RfidSendBufWrite].u8DestDevID = u8DevID;				s_stRfidSendBuf[s_u32RfidSendBufWrite].u32SendTimes = RFID_PRG_SEND_TIMES;		s_stRfidSendBuf[s_u32RfidSendBufWrite].u32SendInterval = RFID_PRG_SEND_INTERVAL;		s_stRfidSendBuf[s_u32RfidSendBufWrite].stFrame.u32ID.ID.FrameType = u32FrameType;		s_stRfidSendBuf[s_u32RfidSendBufWrite].stFrame.u32ID.ID.SDL = (THE_DEV_TYPE&0xFF);		s_stRfidSendBuf[s_u32RfidSendBufWrite].stFrame.u32ID.ID.Reservd = 0x00;					LogicParamApi(LOGIC_GET_YKQ_NUMBER,&u8Temp); 		s_stRfidSendBuf[s_u32RfidSendBufWrite].stFrame.u8DT[0x00] = u8Temp;		s_stRfidSendBuf[s_u32RfidSendBufWrite].stFrame.u8DT[0x01] =  u32PacketNumb&0x00FF ;		s_stRfidSendBuf[s_u32RfidSendBufWrite].stFrame.u8DT[0x02] =  (u32PacketNumb&0xFF00)>>8;		if(u32DataLength > (sizeof(s_stRfidSendBuf[s_u32RfidSendBufWrite].stFrame.u8DT)-0x03))			u32DataLength = (sizeof(s_stRfidSendBuf[s_u32RfidSendBufWrite].stFrame.u8DT)-0x03);		memmove(&(s_stRfidSendBuf[s_u32RfidSendBufWrite].stFrame.u8DT[0x03]),data,u32DataLength);			s_stRfidSendBuf[s_u32RfidSendBufWrite].stFrame.u8DLC = u32DataLength+0x03;		s_u32RfidSendBufWrite++;		s_u32RfidSendBufWrite %= RFIDUPDATE_SEND_BUF_SIZE;				OS_EXIT_CRITICAL();		}	else	{		u32ReturnFlag =  0x00;//缓冲区已满，不能再加入队列中	}	return u32ReturnFlag;		}/*********************************************************************************************函数名称：RfidUpdateSendFrame**函数作用：发送数据处理**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/u8 RfidUpdateSendFrame(RFIDUPDATE_MNG_DATA_TYPE *pData){		#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */		OS_CPU_SR  cpu_sr = 0;	#endif	u32 u32SendLength = 0x00;	u32SendLength = pData->stFrame.u8DLC+0x04+0x01;		if(g_u32ID != B_type)	{			OS_ENTER_CRITICAL();		memset(u8tmp_Update,0x00,u32SendLength+1);		u8tmp_Update[0] = pData->u8DestDevID;		memcpy(&u8tmp_Update[1],(u8 *)&(pData->stFrame.u32ID),u32SendLength);		OS_EXIT_CRITICAL();				InsUsartTrsQueue(u8tmp_Update,u32SendLength+1,WIRELESSDATA,NOACK,1);	}	else		RFID_SendData(pData->u8DestDevID,(u8 *)&(pData->stFrame.u32ID),&u32SendLength);		return 0x01;}/*********************************************************************************** 函数名称: RfidUpdateVersionDwlProc** 功能描述：RFID接收数据处理** 函数输入：无** 函数输出：None** 注意事项：**********************************************************************************/static u32 RfidUpdateVersionDwlProc(RFID_UPDATE_FRAME_TYPE *frame){	u32 u32Addr = 0x00;	u32 u32Length = 0x00;	u32 u32ReturnValue = 0x01;	u16 u16i,u16j;	#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */		OS_CPU_SR  cpu_sr = 0;	#endif		if(frame->u32ID.ID.FrameType != RFID_FT_UPDATE_DWL_VERSION)		u32ReturnValue = 0x00;		if(frame->u32ID.ID.SDL != (THE_DEV_TYPE&0xFF))		u32ReturnValue = 0x00;		if(frame->u8DT[0x1] == 0x01)		s_u32DownloaderId = frame->u8DT[0x00] ;	if(frame->u8DT[0x00] !=  s_u32DownloaderId)		u32ReturnValue = 0x00;	s_u32RecvPacketBackup = frame->u8DT[0x01];	s_u32RecvPacketBackup |= (frame->u8DT[0x02]<<8) ;				switch (s_u32RecvPacketBackup - s_u32RecvPacketTimes)	{		case 0:               //重复的帧 两遍			s_u32RecvPacketTimes++;			cachuFlag = 0;		break;		case 1:              //相差一帧 为正常顺序帧			s_u32RecvPacketTimes = 1;			s_u32RecvPacketTimes = s_u32RecvPacketBackup;			cachuFlag = 1;			break;		default:   //错误帧序列				//return;		break;	}		#ifdef GENERAL_APP//	if(g_u32ID != B_type)//	{	//		if(frame->u8DT[0x0f]==0 &&(frame->u8DT[0x3] != 0x08))//		{//			OS_ENTER_CRITICAL();//			LcdClear();		//			ShowStr(0, "版本更新错误", 2,12); 		//			for(u16i = 0;u16i<10000;u16i++)//			for(u16j = 0;u16j<300;u16j++);//			OS_EXIT_CRITICAL();//		//			u16i = LOGIC_STATUS_IDLE;//			LogicRunInfApi(LOGIC_SET_RUN_STATUS,&u16i);//			//			//			u16i = RFID_SIGNAL_TOO_SMALL;//			LogicRunInfApi(LOGIC_SET_RFID_SIGNAL_STATUS, &u16i);//			InterfaceInsertNote(INTERFACE_NOTE_SYSTEM_IDLE);	//			InterfaceSetCtrlMode(INTERFACE_MODE_IDLE);//			InterfaceSetUpdateMainMethod(INTERFACE_SHOW_MAIN_ALL|INTERFACE_SHOW_MAIN_RFIDSIGNAL);//			OSSemPost(g_stSemInterface);//			//			StateLed(0x00,ADJUST_CODE_ING_LED);//				//			SendSetupToWl(RFID_ININT_SYNC1);//			//			OSTaskResume(IRMNG_TASK_PRIO);//			OSTaskCreate(RfidMng_Task, (void *)0, &RfidMng_task_stk[RFIDMNG_TASK_STK_SIZE - 1], RFIDMNG_TASK_PRIO); 	//			OSTaskDel(RFIDMNG_UPDATE_TASK_PRIO);//			//		return 0x00;		//		}	//	}	#endif		if(s_u32RecvPacketBackup%0x05)	{		u32Addr = s_u32RecvPacketBackup%0x05;		u32Addr--;	}	else	{		u32Addr = 0x04;	}	u32Addr *=  (sizeof(RFID_UPDATE_FRAME_TYPE)-sizeof(u8)-sizeof(u32)-0x03);		memmove(s_u8RfidRecvBuf+u32Addr,&(frame->u8DT[0x03]) ,(frame->u8DLC)-0x03);	s_u32RfidRecvBufWrite	+=  frame->u8DLC-0x03;	if(cachuFlag == 1&& (frame->u8DT[0x1] == 0x01)		&&((InterfaceGetCtrlMode() == INTERFACE_MODE_RECV_PRG_START)	||(InterfaceGetCtrlMode() == INTERFACE_MODE_RECV_PRG_ING)))//第一帧的第一次进行擦除	{		InterfaceSetCtrlMode(INTERFACE_MODE_RECV_PRG_ING);		/**计算需要接收的时间***/				memmove(&u32Length,frame->u8DT+0x03+PROG_LENGTH_OFFSET_ADDRESS,0x04);		InterfaceSetDownloadRemainTimer(((u32Length/100) * TRANS_RECV_PRG_HUNDRED_BYTES_TIME*TRANS_PROG_TIMES));				u32ReturnValue = 0x00;		IapReadBuf((u8 *)&u32ReturnValue,YKQ_DEV_PROGRAM_BASE_ADDRESS,0x04);		if(u32ReturnValue != 0x00)//未擦除时		{			IapGetPrgStorageAddr(THE_DEV_TYPE, &u32Addr);			IapGetPrgSize(THE_DEV_TYPE, &u32Length);						#if (BSP_PRG_STORAGE_FLASH_FLAG	==	BSP_PRG_STORAGE_INFLASH_USE)				__disable_fault_irq();				FLASH_SetLatency(THE_DEV_FLASH_Latency);//120 MHz< HCLK <= 168 MHz				FLASH_Unlock();						#endif							IapEraserSector(MY_DEV_TYPE_ADDRESS);			for(u32Addr = YKQ_DEV_PROGRAM_BASE_ADDRESS; (u32Addr < (u32Length+YKQ_DEV_PROGRAM_BASE_ADDRESS+DEV_PROGRAM_VERSION_SIZE));)			{				if((u32Length+YKQ_DEV_PROGRAM_BASE_ADDRESS+DEV_PROGRAM_VERSION_SIZE) - u32Addr>= THE_DEV_PRG_BULK_SIZE)				{					IapEraserBulk(u32Addr);					u32Addr += THE_DEV_PRG_BULK_SIZE;				}							else if((u32Length+YKQ_DEV_PROGRAM_BASE_ADDRESS+DEV_PROGRAM_VERSION_SIZE) - u32Addr>= THE_DEV_PRG_SECTOR_SIZE)				{					IapEraserSector(u32Addr);					u32Addr += THE_DEV_PRG_SECTOR_SIZE;				}				else				{					#if (BSP_PRG_STORAGE_FLASH_FLAG	==	BSP_PRG_STORAGE_INFLASH_USE)						InFlashErasePage(u32Addr,u32Length+YKQ_DEV_PROGRAM_BASE_ADDRESS+DEV_PROGRAM_VERSION_SIZE-0x01);					#endif					u32Addr += u32Length+YKQ_DEV_PROGRAM_BASE_ADDRESS+DEV_PROGRAM_VERSION_SIZE-u32Addr;								}				#ifdef IWDG_ENABLED					IWDG_Feed();				//喂狗				#endif			}		}		else		{									#if (BSP_PRG_STORAGE_FLASH_FLAG	==	BSP_PRG_STORAGE_INFLASH_USE)				__disable_fault_irq();				FLASH_SetLatency(THE_DEV_FLASH_Latency);//120 MHz< HCLK <= 168 MHz				FLASH_Unlock();						#endif						}				if(s_u32RecvPacketBackup%0x05)		{			u32Addr = s_u32RecvPacketBackup%0x05;			u32Addr--;		}		else		{			u32Addr = 0x04;		}		u32Addr *=  (sizeof(RFID_UPDATE_FRAME_TYPE)-sizeof(u8)-sizeof(u32)-0x03);			IapWriteBuf(&(frame->u8DT[0x03]),THE_DEV_PRG_STORAGE_BASEADDR+u32Addr,(frame->u8DLC)-0x03);				#if (BSP_PRG_STORAGE_FLASH_FLAG	==	BSP_PRG_STORAGE_INFLASH_USE)			__enable_fault_irq();					#endif					InterfaceSetUpdateMainMethod(INTERFACE_SHOW_SELF_RECV_PRG);//显示主屏所有信息		OSSemPost(g_stSemInterface);	}	else	{		if(InterfaceGetCtrlMode() != INTERFACE_MODE_RECV_PRG_ING)			return 0x00;				LedToggle(ADJUST_CODE_ING_LED);					#if (BSP_PRG_STORAGE_FLASH_FLAG	==	BSP_PRG_STORAGE_INFLASH_USE)			__disable_fault_irq();			FLASH_SetLatency(THE_DEV_FLASH_Latency);//120 MHz< HCLK <= 168 MHz			FLASH_Unlock();					#endif					IapWriteBuf(&(frame->u8DT[0x03]),THE_DEV_PRG_STORAGE_BASEADDR+u32Addr,(frame->u8DLC)-0x03);				#if (BSP_PRG_STORAGE_FLASH_FLAG	==	BSP_PRG_STORAGE_INFLASH_USE)			__enable_fault_irq();					#endif		}		InterfaceDecDownloadRemainTimer(TRANS_RECV_PRG_WRITE_TIME);	InterfaceSetCtrlMode(INTERFACE_MODE_RECV_PRG_ING);	return u32ReturnValue;}/*********************************************************************************** 函数名称: RfidUpdateVersionWriteProc** 功能描述：RFID接收数据处理** 函数输入：无** 函数输出：None** 注意事项：**********************************************************************************/static u32 s_u32RecvPacketBackupLast = 0;static u32 RfidUpdateVersionWriteProc(RFID_UPDATE_FRAME_TYPE *frame){	u32 u32I = 0x00;	u32 u32Crc = 0x00;	u32 u32ReturnValue = 0x01;	if(InterfaceGetCtrlMode() != INTERFACE_MODE_RECV_PRG_ING)			return 0x00;				if(frame->u32ID.ID.FrameType != RFID_FT_UPDATE_WRITE_VERSION)		u32ReturnValue =  0x00;	if(frame->u8DT[0x00] !=  s_u32DownloaderId)		u32ReturnValue =  0x00;	if(s_u32RfidRecvBufWrite != RFIDUPDATE_RECV_BUF_SIZE)	{		u32ReturnValue = 0x00;		}		memmove(&u32I,s_u8RfidRecvBuf+PROG_DEVTYPE_OFFSET_ADDRESS,0x04); 	if(u32I!= THE_DEV_TYPE)		u32ReturnValue = 0x00;			memmove(&u32I,s_u8RfidRecvBuf+PROG_TARGETYPE_OFFSET_ADDRESS,0x04); 	if(u32I!= THE_TARGET_TYPE)		u32ReturnValue = 0x00;		/**计算校验***/	memmove(&u32I,s_u8RfidRecvBuf+PROG_VER_CRCL_OFFSET_ADDRESS,0x04);	u32Crc = 0x00;	Crc16Ccitt(s_u8RfidRecvBuf,PROG_VER_CRCL_OFFSET_ADDRESS,(u16 *)&u32Crc);	if(u32Crc != u32I)	 	u32ReturnValue = 0x00;		/**写入FLASH***/	#if 0		if(u32ReturnValue == 0x01)		{			#if (BSP_PRG_STORAGE_FLASH_FLAG	==	BSP_PRG_STORAGE_INFLASH_USE)				__disable_fault_irq();				FLASH_SetLatency(THE_DEV_FLASH_Latency);//120 MHz< HCLK <= 168 MHz				FLASH_Unlock();						#endif				IapWriteBuf(s_u8RfidRecvBuf,THE_DEV_PRG_STORAGE_BASEADDR,s_u32RfidRecvBufWrite);						#if (BSP_PRG_STORAGE_FLASH_FLAG	==	BSP_PRG_STORAGE_INFLASH_USE)				__enable_fault_irq();						#endif			}	#endif		s_u32RecvPacketBackup = 0x00;	s_u32RecvPacketBackupLast = 0x00;	s_u32RfidRecvBufWrite = 0x00;	s_u32WriteAddr = THE_DEV_PRG_STORAGE_BASEADDR+DEV_PROGRAM_VERSION_SIZE;		InterfaceDecDownloadRemainTimer(TRANS_RECV_PRG_WRITE_TIME);		InterfaceSetCtrlMode(INTERFACE_MODE_RECV_PRG_ING);	LedToggle(ADJUST_CODE_ING_LED);			return u32ReturnValue;}/*********************************************************************************** 函数名称: RfidUpdateCodeDwlProc** 功能描述：RFID接收数据处理** 函数输入：无** 函数输出：None** 注意事项：**********************************************************************************/static u32 RfidUpdateCodeDwlProc(RFID_UPDATE_FRAME_TYPE *frame){	u32 u32Temp;	u32 u32ReturnValue = 0x01;	u32 u32Addr = 0x00;		#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */		 OS_CPU_SR  cpu_sr = 0;	#endif	if(InterfaceGetCtrlMode() != INTERFACE_MODE_RECV_PRG_ING)		return 0x00;			if(frame->u32ID.ID.FrameType != RFID_FT_UPDATE_DWL_CODE)		u32ReturnValue =  0x00;		if(frame->u32ID.ID.SDL != (THE_DEV_TYPE&0xFF))		u32ReturnValue =  0x00;		if(frame->u8DT[0x00] !=  s_u32DownloaderId)		u32ReturnValue = 0x00;	s_u32RecvPacketBackup = frame->u8DT[0x01] ;	s_u32RecvPacketBackup |= (frame->u8DT[0x02]<<8) ;		if(s_u32RecvPacketBackup-s_u32RecvPacketBackupLast>1)	{		#if (BSP_PRG_STORAGE_FLASH_FLAG	==	BSP_PRG_STORAGE_INFLASH_USE)			__disable_fault_irq();			FLASH_SetLatency(THE_DEV_FLASH_Latency);//120 MHz< HCLK <= 168 MHz			FLASH_Unlock();					#endif					IapEraserSector(MY_DEV_TYPE_ADDRESS);		#if (BSP_PRG_STORAGE_FLASH_FLAG	==	BSP_PRG_STORAGE_INFLASH_USE)			FLASH_Lock();			__enable_fault_irq();					#endif					u32ReturnValue = LOGIC_STATUS_IDLE;		LogicRunInfApi(LOGIC_SET_RUN_STATUS,&u32ReturnValue);		InterfaceInsertNote(INTERFACE_NOTE_RECV_ERR);			InterfaceSetCtrlMode(INTERFACE_MODE_IDLE);		InterfaceSetUpdateMainMethod(INTERFACE_SHOW_MAIN_ALL);		OSSemPost(g_stSemInterface);				StateLed(0x00,ADJUST_CODE_ING_LED);							if(g_u32ID == B_type)		{			OS_ENTER_CRITICAL();			RFID_Init(RFID_ININT_SYNC0,RFID_ININT_SYNC1);			RfidMngSetRecvCallBack();			OS_EXIT_CRITICAL();		}		else		{			OSTaskResume(USART_TASK_PRIO);			SendSetupToWl(RFID_ININT_SYNC1);		}		OSTaskResume(IRMNG_TASK_PRIO);		OSTaskCreate(RfidMng_Task, (void *)0, &RfidMng_task_stk[RFIDMNG_TASK_STK_SIZE - 1], RFIDMNG_TASK_PRIO); 			OSTaskDel(RFIDMNG_UPDATE_TASK_PRIO);						if(g_u32ID != B_type)		{			SendSetupToWl(RFID_ININT_SYNC1);		}				u32Temp = (Version[8]-0x30)|(((Version[6]-0x30)+(Version[5]-0x30)*10)<<8)|((Version[3]-0x30)<<16)|((Version[1]-0x30)<<24);			IapWriteBuf((u8 *)&u32Temp, APP_VERSION_ADDRESS, 0x04);			IapWriteBuf((u8 *)&u32Temp, APP_VERSION_ADDRESS, 0x04);			}		s_u32RecvPacketBackupLast = s_u32RecvPacketBackup;	if(s_u32RecvPacketBackup%0x05)	{		u32Addr = s_u32RecvPacketBackup%0x05;		u32Addr--;	}	else	{		u32Addr = 0x04;	}	u32Addr *=  (sizeof(RFID_UPDATE_FRAME_TYPE)-sizeof(u8)-sizeof(u32)-0x03);		memmove(s_u8RfidRecvBuf+u32Addr,&(frame->u8DT[0x03]), (frame->u8DLC)-0x03);	s_u32RfidRecvBufWrite	+=  (frame->u8DLC)-0x03;		#if (BSP_PRG_STORAGE_FLASH_FLAG	==	BSP_PRG_STORAGE_INFLASH_USE)		__disable_fault_irq();		FLASH_SetLatency(THE_DEV_FLASH_Latency);//120 MHz< HCLK <= 168 MHz		FLASH_Unlock();				#endif			u32Addr += (s_u32RecvPacketBackup-0x01)/0x05*DEV_PROGRAM_VERSION_SIZE;		IapWriteBuf(&(frame->u8DT[0x03]),THE_DEV_PRG_STORAGE_BASEADDR+DEV_PROGRAM_VERSION_SIZE+u32Addr,(frame->u8DLC)-0x03);		#if (BSP_PRG_STORAGE_FLASH_FLAG	==	BSP_PRG_STORAGE_INFLASH_USE)		FLASH_Lock();		__enable_fault_irq();				#endif		s_u32WriteAddr = THE_DEV_PRG_STORAGE_BASEADDR+DEV_PROGRAM_VERSION_SIZE+u32Addr+(frame->u8DLC)-0x03;			InterfaceDecDownloadRemainTimer(TRANS_RECV_PRG_WRITE_TIME);	InterfaceSetCtrlMode(INTERFACE_MODE_RECV_PRG_ING);	LedToggle(ADJUST_CODE_ING_LED);			return	u32ReturnValue;}/*********************************************************************************** 函数名称: RfidUpdateCodeWriteProc** 功能描述：RFID接收数据处理** 函数输入：无** 函数输出：None** 注意事项：**********************************************************************************/static u32 RfidUpdateCodeWriteProc(RFID_UPDATE_FRAME_TYPE *frame){	u32 u32ReturnValue = 0x01;	u32 u32I = 0x00;	if(InterfaceGetCtrlMode() != INTERFACE_MODE_RECV_PRG_ING)		return 0x00;			if(frame->u32ID.ID.FrameType != RFID_FT_UPDATE_WRITE_CODE)		u32ReturnValue =  0x00;	if(frame->u8DT[0x00] !=  s_u32DownloaderId)		u32ReturnValue= 0x00;	u32I = (frame->u8DT[0x01] |(frame->u8DT[0x02]<<8));	if((u32I%0x05) == 0x00)	{			u32I/=0x05;		u32I--;		u32I = THE_DEV_PRG_STORAGE_BASEADDR+DEV_PROGRAM_VERSION_SIZE+u32I*DEV_PROGRAM_VERSION_SIZE;	}	else	{		u32I/=0x05;		u32I = THE_DEV_PRG_STORAGE_BASEADDR+DEV_PROGRAM_VERSION_SIZE+u32I*DEV_PROGRAM_VERSION_SIZE;			}		/**写入FLASH***/	#if 0		if(u32ReturnValue == 0x01)		{			#if (BSP_PRG_STORAGE_FLASH_FLAG	==	BSP_PRG_STORAGE_INFLASH_USE)				__disable_fault_irq();				FLASH_SetLatency(THE_DEV_FLASH_Latency);//120 MHz< HCLK <= 168 MHz				FLASH_Unlock();						#endif				IapWriteBuf(s_u8RfidRecvBuf, u32I, s_u32RfidRecvBufWrite);						#if (BSP_PRG_STORAGE_FLASH_FLAG	==	BSP_PRG_STORAGE_INFLASH_USE)				FLASH_Lock();				__enable_fault_irq();						#endif			}	#endif		s_u32RfidRecvBufWrite = 0x00;		InterfaceDecDownloadRemainTimer(TRANS_RECV_PRG_WRITE_TIME);		InterfaceSetCtrlMode(INTERFACE_MODE_RECV_PRG_ING);	LedToggle(ADJUST_CODE_ING_LED);			return u32ReturnValue;}/*********************************************************************************** 函数名称: RfidUpdateTransEndProc** 功能描述：RFID接收数据处理** 函数输入：无** 函数输出：None** 注意事项：**********************************************************************************/static u32 RfidUpdateTransEndProc(RFID_UPDATE_FRAME_TYPE *frame){	u32 u32ReturnValue = 0x01;	u32 u32I = 0x00;	u32 u32Temp = 0x00;	#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */		 OS_CPU_SR  cpu_sr = 0;	#endif	if(InterfaceGetCtrlMode() != INTERFACE_MODE_RECV_PRG_ING)		return 0x00;			LedToggle(ADJUST_CODE_ING_LED);		if(frame->u32ID.ID.FrameType != RFID_FT_UPDATE_END)		u32ReturnValue =  0x00;	if(frame->u8DT[0x00] !=  s_u32DownloaderId)		u32ReturnValue= 0x00;	u32I =0x00;	u32I = IapReadCodeLen(THE_DEV_PRG_STORAGE_BASEADDR+PROG_LENGTH_OFFSET_ADDRESS);	if(s_u32WriteAddr != (u32I+THE_DEV_PRG_STORAGE_BASEADDR+DEV_PROGRAM_VERSION_SIZE))		u32ReturnValue =  0x00;			#ifdef IWDG_ENABLED		IWDG_Feed();	#endif	u32I = IapExFlashCrc(THE_DEV_PRG_STORAGE_BASEADDR+DEV_PROGRAM_VERSION_SIZE,u32I);	u32Temp = IapReadCrc(THE_DEV_PRG_STORAGE_BASEADDR+PROG_CRCL_OFFSET_ADDRESS);	if(u32I != u32Temp)		u32ReturnValue = 0x00;	if(u32ReturnValue == 0x01)	{		u32Temp = YKQ_SHUTDOWN_NO_SLEEP;		LogicParamApi(LOGIC_SET_SHUTDOWM_FLAG,&u32Temp);		#if (BSP_PRG_STORAGE_FLASH_FLAG	==	BSP_PRG_STORAGE_INFLASH_USE)			__disable_fault_irq();			FLASH_SetLatency(THE_DEV_FLASH_Latency);//120 MHz< HCLK <= 168 MHz			FLASH_Unlock();					#endif					IapReadBuf((u8 *)&u32Temp,THE_DEV_PRG_STORAGE_BASEADDR+PROG_WRITE_BASE_ADDRESS,0x04);		IapWriteBuf((u8 *)&u32Temp, APP_WRITE_BASEADDRESS, 0x04);		IapWriteBuf((u8 *)&u32Temp, APP_WRITE_BASEADDRESS, 0x04);				IapReadBuf((u8 *)&u32Temp,THE_DEV_PRG_STORAGE_BASEADDR+PROG_DEVTYPE_OFFSET_ADDRESS,0x04);		IapWriteBuf((u8 *)&u32Temp, MY_DEV_TYPE_ADDRESS, 0x04);		IapWriteBuf((u8 *)&u32Temp, MY_DEV_TYPE_ADDRESS, 0x04);				u32Temp = RROG_DOWNLOAD_FLAG;		IapWriteBuf((u8 *)&u32Temp, APP_DOWNLOAD_OFFSET_ADDRESS, 0x04);		IapWriteBuf((u8 *)&u32Temp, APP_DOWNLOAD_OFFSET_ADDRESS, 0x04);				u32Temp = RROG_UPDATE_FLAG;		IapWriteBuf((u8 *)&u32Temp, APP_UPDATE_OFFSET_ADDRESS, 0x04);			IapWriteBuf((u8 *)&u32Temp, APP_UPDATE_OFFSET_ADDRESS, 0x04);				IapReadBuf((u8 *)&u32Temp,YKQ_DEV_PROGRAM_BASE_ADDRESS|PROG_VERSION_OFFSET_ADDRESS,0x04);			IapWriteBuf((u8 *)&u32Temp, APP_VERSION_ADDRESS, 0x04);			IapWriteBuf((u8 *)&u32Temp, APP_VERSION_ADDRESS, 0x04);						#if (BSP_PRG_STORAGE_FLASH_FLAG	==	BSP_PRG_STORAGE_INFLASH_USE)			FLASH_Lock();			__enable_fault_irq();					#endif				#ifdef IWDG_ENABLED			IWDG_Feed();		#endif		OSTaskSuspend(INTERFACE_TASK_PRIO);		StateLed(0x00,ADJUST_CODE_ING_LED);			KeyLedOnOff(0x00,KEY_LED_ALL);				LcdAreaClear(OLED_DISPLAY_NORMAL,6,0,7,127);		ShowStr(OLED_DISPLAY_NORMAL,"接收已完成",6, 19);		OSTimeDly(1500/TICK_TIME);		LcdAreaClear(OLED_DISPLAY_NORMAL,6,0,7,127);		ShowStr(OLED_DISPLAY_NORMAL,"即将重启",6, 32);		OSTimeDly(1500/TICK_TIME);		//进行程序的跳转,跳至BOOTLOADER		IapJumpToBoot(IN_FLASH_BOOTLOADER_ADDR);	}	else	{		#if (BSP_PRG_STORAGE_FLASH_FLAG	==	BSP_PRG_STORAGE_INFLASH_USE)			__disable_fault_irq();			FLASH_SetLatency(THE_DEV_FLASH_Latency);//120 MHz< HCLK <= 168 MHz			FLASH_Unlock();					#endif					IapEraserSector(MY_DEV_TYPE_ADDRESS);					u32Temp = (Version[8]-0x30)|(((Version[6]-0x30)+(Version[5]-0x30)*10)<<8)|((Version[3]-0x30)<<16)|((Version[1]-0x30)<<24);			IapWriteBuf((u8 *)&u32Temp, APP_VERSION_ADDRESS, 0x04);			IapWriteBuf((u8 *)&u32Temp, APP_VERSION_ADDRESS, 0x04);						#if (BSP_PRG_STORAGE_FLASH_FLAG	==	BSP_PRG_STORAGE_INFLASH_USE)			FLASH_Lock();			__enable_fault_irq();					#endif				u32Temp = LOGIC_STATUS_IDLE;		LogicRunInfApi(LOGIC_SET_RUN_STATUS,&u32Temp);		InterfaceInsertNote(INTERFACE_NOTE_RECV_ERR);			InterfaceSetCtrlMode(INTERFACE_MODE_IDLE);		InterfaceSetUpdateMainMethod(INTERFACE_SHOW_MAIN_ALL);		OSSemPost(g_stSemInterface);				StateLed(0x00,ADJUST_CODE_ING_LED);							if(g_u32ID == B_type)		{			OS_ENTER_CRITICAL();			RFID_Init(RFID_ININT_SYNC0,RFID_ININT_SYNC1);			RfidMngSetRecvCallBack();			OS_EXIT_CRITICAL();		}		else		{			OSTaskResume(USART_TASK_PRIO);			SendSetupToWl(RFID_ININT_SYNC1);		}		OSTaskResume(IRMNG_TASK_PRIO);		OSTaskCreate(RfidMng_Task, (void *)0, &RfidMng_task_stk[RFIDMNG_TASK_STK_SIZE - 1], RFIDMNG_TASK_PRIO); 			OSTaskDel(RFIDMNG_UPDATE_TASK_PRIO);				}	return u32ReturnValue;}/*********************************************************************************** 函数名称: RfidUpdateVersionDwlProc** 功能描述：RFID接收数据处理** 函数输入：无** 函数输出：None** 注意事项：**********************************************************************************/static u32 WL_RfidUpdateVersionDwlProc(RFID_UPDATE_FRAME_TYPE *frame){	u32 u32Addr = 0x00;	u32 u32Length = 0x00;	u32 u32ReturnValue = 0x01;		if(frame->u32ID.ID.FrameType != WL_RFID_FT_UPDATE_DWL_VERSION)		u32ReturnValue = 0x00;		if(frame->u32ID.ID.SDL != (YKQ_WL_DEV_TYPE&0xFF))		u32ReturnValue = 0x00;		if(frame->u8DT[0x1] == 0x01)		s_u32DownloaderId = frame->u8DT[0x00] ;	if(frame->u8DT[0x00] !=  s_u32DownloaderId)		u32ReturnValue = 0x00;	s_u32RecvPacketBackup = frame->u8DT[0x01];	s_u32RecvPacketBackup |= (frame->u8DT[0x02]<<8) ;			switch (s_u32RecvPacketBackup - s_u32RecvPacketTimes)	{		case 0:               //重复的帧 两遍			s_u32RecvPacketTimes++;			cachuFlag = 0;		break;		case 1:              //相差一帧 为正常顺序帧			s_u32RecvPacketTimes = 1;			s_u32RecvPacketTimes = s_u32RecvPacketBackup;			cachuFlag = 1;			break;		default:   //错误帧序列				//return;		break;	}			if(s_u32RecvPacketBackup%0x05)	{		u32Addr = s_u32RecvPacketBackup%0x05;		u32Addr--;	}	else	{		u32Addr = 0x04;	}	u32Addr *=  (sizeof(RFID_UPDATE_FRAME_TYPE)-sizeof(u8)-sizeof(u32)-0x03);		memmove(s_u8RfidRecvBuf+u32Addr,&(frame->u8DT[0x03]) ,(frame->u8DLC)-0x03);	s_u32RfidRecvBufWrite	+=  frame->u8DLC-0x03;	if(cachuFlag == 1&& (frame->u8DT[0x1] == 0x01)&&((InterfaceGetCtrlMode() == INTERFACE_MODE_RECV_PRG_START)||(InterfaceGetCtrlMode() == INTERFACE_MODE_RECV_PRG_ING)))//第一帧的第一次进行擦除	{		InterfaceSetCtrlMode(INTERFACE_MODE_RECV_PRG_ING);		/**计算需要接收的时间***/				memmove(&u32Length,frame->u8DT+0x03+PROG_LENGTH_OFFSET_ADDRESS,0x04);		if(u32Length <= sizeof(ACTION_INFO))		//长度小于配置文件总大小，则为配置文件，程序文件不可能这么小，时间*4			InterfaceSetDownloadRemainTimer(((u32Length*3/100) * TRANS_RECV_PRG_HUNDRED_BYTES_TIME*TRANS_PROG_TIMES));		else			InterfaceSetDownloadRemainTimer(((u32Length/100) * TRANS_RECV_PRG_HUNDRED_BYTES_TIME*TRANS_PROG_TIMES));				u32ReturnValue = 0x00;		IapReadBuf((u8 *)&u32ReturnValue,YKQ_WL_PROGRAM_BASE_ADDRESS,0x04);		if(u32ReturnValue != 0x00)//未擦除时		{			IapGetPrgStorageAddr(YKQ_WL_DEV_TYPE, &u32Addr);			IapGetPrgSize(YKQ_WL_DEV_TYPE, &u32Length);						#if (BSP_PRG_STORAGE_FLASH_FLAG	==	BSP_PRG_STORAGE_INFLASH_USE)				__disable_fault_irq();				FLASH_SetLatency(THE_DEV_FLASH_Latency);//120 MHz< HCLK <= 168 MHz				FLASH_Unlock();						#endif							IapEraserSector(YKQ_WL_PROGRAM_BASE_ADDRESS);			for(u32Addr = YKQ_WL_PROGRAM_BASE_ADDRESS; (u32Addr < (u32Length+YKQ_WL_PROGRAM_BASE_ADDRESS));)			{				if((u32Length+YKQ_WL_PROGRAM_BASE_ADDRESS) - u32Addr>= THE_DEV_PRG_BULK_SIZE)				{					IapEraserBulk(u32Addr);					u32Addr += THE_DEV_PRG_BULK_SIZE;				}							else if((u32Length+YKQ_WL_PROGRAM_BASE_ADDRESS) - u32Addr>= THE_DEV_PRG_SECTOR_SIZE)				{					IapEraserSector(u32Addr);					u32Addr += THE_DEV_PRG_SECTOR_SIZE;				}				else				{					#if (BSP_PRG_STORAGE_FLASH_FLAG	==	BSP_PRG_STORAGE_INFLASH_USE)						InFlashErasePage(u32Addr,u32Length+YKQ_WL_PROGRAM_BASE_ADDRESS-0x01);					#endif					u32Addr += u32Length+YKQ_WL_PROGRAM_BASE_ADDRESS-u32Addr;								}				#ifdef IWDG_ENABLED					IWDG_Feed();				//喂狗				#endif			}		}		else		{									#if (BSP_PRG_STORAGE_FLASH_FLAG	==	BSP_PRG_STORAGE_INFLASH_USE)				__disable_fault_irq();				FLASH_SetLatency(THE_DEV_FLASH_Latency);//120 MHz< HCLK <= 168 MHz				FLASH_Unlock();						#endif						}				if(s_u32RecvPacketBackup%0x05)		{			u32Addr = s_u32RecvPacketBackup%0x05;			u32Addr--;		}		else		{			u32Addr = 0x04;		}		u32Addr *=  (sizeof(RFID_UPDATE_FRAME_TYPE)-sizeof(u8)-sizeof(u32)-0x03);			IapWriteBuf(&(frame->u8DT[0x03]),YKQ_WL_PROGRAM_BASE_ADDRESS+u32Addr,(frame->u8DLC)-0x03);				#if (BSP_PRG_STORAGE_FLASH_FLAG	==	BSP_PRG_STORAGE_INFLASH_USE)			__enable_fault_irq();					#endif					InterfaceSetUpdateMainMethod(INTERFACE_SHOW_SELF_RECV_PRG);//显示主屏所有信息		OSSemPost(g_stSemInterface);	}	else	{		if(InterfaceGetCtrlMode() != INTERFACE_MODE_RECV_PRG_ING)			return 0x00;				LedToggle(ADJUST_CODE_ING_LED);					#if (BSP_PRG_STORAGE_FLASH_FLAG	==	BSP_PRG_STORAGE_INFLASH_USE)			__disable_fault_irq();			FLASH_SetLatency(THE_DEV_FLASH_Latency);//120 MHz< HCLK <= 168 MHz			FLASH_Unlock();					#endif					IapWriteBuf(&(frame->u8DT[0x03]),YKQ_WL_PROGRAM_BASE_ADDRESS+u32Addr,(frame->u8DLC)-0x03);				#if (BSP_PRG_STORAGE_FLASH_FLAG	==	BSP_PRG_STORAGE_INFLASH_USE)			__enable_fault_irq();					#endif		}		InterfaceDecDownloadRemainTimer(TRANS_RECV_PRG_WRITE_TIME);	InterfaceSetCtrlMode(INTERFACE_MODE_RECV_PRG_ING);	return u32ReturnValue;}/*********************************************************************************** 函数名称: RfidUpdateVersionWriteProc** 功能描述：RFID接收数据处理** 函数输入：无** 函数输出：None** 注意事项：**********************************************************************************/static u32 WL_RfidUpdateVersionWriteProc(RFID_UPDATE_FRAME_TYPE *frame){	u32 u32I = 0x00;	u32 u32Crc = 0x00;	u32 u32ReturnValue = 0x01;		if(InterfaceGetCtrlMode() != INTERFACE_MODE_RECV_PRG_ING)			return 0x00;				if(frame->u32ID.ID.FrameType != WL_RFID_FT_UPDATE_WRITE_VERSION)		u32ReturnValue =  0x00;	if(frame->u8DT[0x00] !=  s_u32DownloaderId)		u32ReturnValue =  0x00;	if(s_u32RfidRecvBufWrite != RFIDUPDATE_RECV_BUF_SIZE)	{		u32ReturnValue = 0x00;		}		memmove(&u32I,s_u8RfidRecvBuf+PROG_DEVTYPE_OFFSET_ADDRESS,0x04); 	if(u32I!= YKQ_WL_DEV_TYPE)		u32ReturnValue = 0x00;			memmove(&u32I,s_u8RfidRecvBuf+PROG_TARGETYPE_OFFSET_ADDRESS,0x04); 	if(u32I!= TAGET_STM32L4_MCU)		u32ReturnValue = 0x00;		/**计算校验***/	memmove(&u32I,s_u8RfidRecvBuf+PROG_VER_CRCL_OFFSET_ADDRESS,0x04);	u32Crc = 0x00;	Crc16Ccitt(s_u8RfidRecvBuf,PROG_VER_CRCL_OFFSET_ADDRESS,(u16 *)&u32Crc);	if(u32Crc != u32I)	 	u32ReturnValue = 0x00;		/**写入FLASH***/	#if 0		if(u32ReturnValue == 0x01)		{			#if (BSP_PRG_STORAGE_FLASH_FLAG	==	BSP_PRG_STORAGE_INFLASH_USE)				__disable_fault_irq();				FLASH_SetLatency(THE_DEV_FLASH_Latency);//120 MHz< HCLK <= 168 MHz				FLASH_Unlock();						#endif				IapWriteBuf(s_u8RfidRecvBuf,THE_DEV_PRG_STORAGE_BASEADDR,s_u32RfidRecvBufWrite);						#if (BSP_PRG_STORAGE_FLASH_FLAG	==	BSP_PRG_STORAGE_INFLASH_USE)				__enable_fault_irq();						#endif			}	#endif		s_u32RecvPacketBackup = 0x00;	s_u32RecvPacketBackupLast = 0x00;	s_u32RfidRecvBufWrite = 0x00;	s_u32WriteAddr = YKQ_WL_PROGRAM_BASE_ADDRESS+DEV_PROGRAM_VERSION_SIZE;		InterfaceDecDownloadRemainTimer(TRANS_RECV_PRG_WRITE_TIME);		InterfaceSetCtrlMode(INTERFACE_MODE_RECV_PRG_ING);	LedToggle(ADJUST_CODE_ING_LED);			return u32ReturnValue;}/*********************************************************************************** 函数名称: RfidUpdateCodeDwlProc** 功能描述：RFID接收数据处理** 函数输入：无** 函数输出：None** 注意事项：**********************************************************************************/static u32 WL_RfidUpdateCodeDwlProc(RFID_UPDATE_FRAME_TYPE *frame){	u32 u32ReturnValue = 0x01;	u32 u32Addr = 0x00;		#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */		OS_CPU_SR  cpu_sr = 0;	#endif	if(InterfaceGetCtrlMode() != INTERFACE_MODE_RECV_PRG_ING)		return 0x00;			if(frame->u32ID.ID.FrameType != WL_RFID_FT_UPDATE_DWL_CODE)		u32ReturnValue =  0x00;		if(frame->u32ID.ID.SDL != (YKQ_WL_DEV_TYPE&0xFF))		u32ReturnValue =  0x00;		if(frame->u8DT[0x00] !=  s_u32DownloaderId)		u32ReturnValue = 0x00;	s_u32RecvPacketBackup = frame->u8DT[0x01] ;	s_u32RecvPacketBackup |= (frame->u8DT[0x02]<<8);			if(s_u32RecvPacketBackup-s_u32RecvPacketBackupLast>1)	{		#if (BSP_PRG_STORAGE_FLASH_FLAG	==	BSP_PRG_STORAGE_INFLASH_USE)			__disable_fault_irq();			FLASH_SetLatency(THE_DEV_FLASH_Latency);//120 MHz< HCLK <= 168 MHz			FLASH_Unlock();					#endif					IapEraserSector(MY_DEV_TYPE_ADDRESS);		#if (BSP_PRG_STORAGE_FLASH_FLAG	==	BSP_PRG_STORAGE_INFLASH_USE)			FLASH_Lock();			__enable_fault_irq();					#endif					u32ReturnValue = LOGIC_STATUS_IDLE;		LogicRunInfApi(LOGIC_SET_RUN_STATUS,&u32ReturnValue);		InterfaceInsertNote(INTERFACE_NOTE_RECV_ERR);			InterfaceSetCtrlMode(INTERFACE_MODE_IDLE);		InterfaceSetUpdateMainMethod(INTERFACE_SHOW_MAIN_ALL);		OSSemPost(g_stSemInterface);				StateLed(0x00,ADJUST_CODE_ING_LED);							if(g_u32ID == B_type)		{			OS_ENTER_CRITICAL();			RFID_Init(RFID_ININT_SYNC0,RFID_ININT_SYNC1);			RfidMngSetRecvCallBack();			OS_EXIT_CRITICAL();		}		else		{			OSTaskResume(USART_TASK_PRIO);			SendSetupToWl(RFID_ININT_SYNC1);		}		OSTaskResume(IRMNG_TASK_PRIO);		OSTaskCreate(RfidMng_Task, (void *)0, &RfidMng_task_stk[RFIDMNG_TASK_STK_SIZE - 1], RFIDMNG_TASK_PRIO); 			OSTaskDel(RFIDMNG_UPDATE_TASK_PRIO);						if(g_u32ID != B_type)		{			SendSetupToWl(RFID_ININT_SYNC1);		}			}	if(s_u32RecvPacketBackupLast == s_u32RecvPacketBackup)		return	u32ReturnValue;		s_u32RecvPacketBackupLast = s_u32RecvPacketBackup;		if(s_u32RecvPacketBackup%0x05)	{		u32Addr = s_u32RecvPacketBackup%0x05;		u32Addr--;	}	else	{		u32Addr = 0x04;	}	u32Addr *=  (sizeof(RFID_UPDATE_FRAME_TYPE)-sizeof(u8)-sizeof(u32)-0x03);		memmove(s_u8RfidRecvBuf+u32Addr,&(frame->u8DT[0x03]), (frame->u8DLC)-0x03);	s_u32RfidRecvBufWrite	+=  (frame->u8DLC)-0x03;	//第一次进入，判断是否是配置文件的标志	if(RecvActionInfoFlag == 0)	{		writeaddr = 0;		RecvActionInfoFlag = 1;		if(s_u8RfidRecvBuf[0+4] == 0x12 && s_u8RfidRecvBuf[1+4] == 0x34			&& s_u8RfidRecvBuf[2+4] == 0x55 && s_u8RfidRecvBuf[3+4] == 0x78)		{			RecvActionInfoFlag = 2;			memset(&ActionInformation.Head.Veron[0],0,sizeof(ACTION_INFO));		}	}	//如果是配置文件，将配置文件对应列表	if(RecvActionInfoFlag == 2)	{		memmove(&ActionInformation.Head.Veron[0]+writeaddr,&(frame->u8DT[0x03+4]), (frame->u8DLC)-0x03-4);		if(writeaddr < sizeof(ACTION_INFO))			writeaddr += (frame->u8DLC)-0x03-4;		RecvActionInfoFlag = 3;	}	else if(RecvActionInfoFlag == 3)	{		memmove(&ActionInformation.Head.Veron[0]+writeaddr,&(frame->u8DT[0x03]), (frame->u8DLC)-0x03);		if(writeaddr < sizeof(ACTION_INFO))			writeaddr += (frame->u8DLC)-0x03;	}	else	{		#if (BSP_PRG_STORAGE_FLASH_FLAG	==	BSP_PRG_STORAGE_INFLASH_USE)			__disable_fault_irq();			FLASH_SetLatency(THE_DEV_FLASH_Latency);//120 MHz< HCLK <= 168 MHz			FLASH_Unlock();					#endif					u32Addr += (s_u32RecvPacketBackup-0x01)/0x05*DEV_PROGRAM_VERSION_SIZE;				IapWriteBuf(&(frame->u8DT[0x03]),YKQ_WL_PROGRAM_BASE_ADDRESS+DEV_PROGRAM_VERSION_SIZE+u32Addr,(frame->u8DLC)-0x03);				#if (BSP_PRG_STORAGE_FLASH_FLAG	==	BSP_PRG_STORAGE_INFLASH_USE)			__enable_fault_irq();					#endif			s_u32WriteAddr = YKQ_WL_PROGRAM_BASE_ADDRESS+DEV_PROGRAM_VERSION_SIZE+u32Addr+(frame->u8DLC)-0x03;		}		InterfaceDecDownloadRemainTimer(TRANS_RECV_PRG_WRITE_TIME);	InterfaceSetCtrlMode(INTERFACE_MODE_RECV_PRG_ING);	LedToggle(ADJUST_CODE_ING_LED);			return	u32ReturnValue;}/*********************************************************************************** 函数名称: RfidUpdateCodeWriteProc** 功能描述：RFID接收数据处理** 函数输入：无** 函数输出：None** 注意事项：**********************************************************************************/static u32 WL_RfidUpdateCodeWriteProc(RFID_UPDATE_FRAME_TYPE *frame){	u32 u32ReturnValue = 0x01;	u32 u32I = 0x00;	if(InterfaceGetCtrlMode() != INTERFACE_MODE_RECV_PRG_ING)		return 0x00;			if(frame->u32ID.ID.FrameType != WL_RFID_FT_UPDATE_WRITE_CODE)		u32ReturnValue =  0x00;	if(frame->u8DT[0x00] !=  s_u32DownloaderId)		u32ReturnValue= 0x00;	u32I = (frame->u8DT[0x01] |(frame->u8DT[0x02]<<8));	if((u32I%0x05) == 0x00)	{			u32I/=0x05;		u32I--;		u32I = YKQ_WL_PROGRAM_BASE_ADDRESS+DEV_PROGRAM_VERSION_SIZE+u32I*DEV_PROGRAM_VERSION_SIZE;	}	else	{		u32I/=0x05;		u32I = YKQ_WL_PROGRAM_BASE_ADDRESS+DEV_PROGRAM_VERSION_SIZE+u32I*DEV_PROGRAM_VERSION_SIZE;			}		/**写入FLASH***/	#if 0		if(u32ReturnValue == 0x01)		{			#if (BSP_PRG_STORAGE_FLASH_FLAG	==	BSP_PRG_STORAGE_INFLASH_USE)				__disable_fault_irq();				FLASH_SetLatency(THE_DEV_FLASH_Latency);//120 MHz< HCLK <= 168 MHz				FLASH_Unlock();						#endif				IapWriteBuf(s_u8RfidRecvBuf, u32I, s_u32RfidRecvBufWrite);						#if (BSP_PRG_STORAGE_FLASH_FLAG	==	BSP_PRG_STORAGE_INFLASH_USE)				FLASH_Lock();				__enable_fault_irq();						#endif			}	#endif		s_u32RfidRecvBufWrite = 0x00;		InterfaceDecDownloadRemainTimer(TRANS_RECV_PRG_WRITE_TIME);		InterfaceSetCtrlMode(INTERFACE_MODE_RECV_PRG_ING);	LedToggle(ADJUST_CODE_ING_LED);			return u32ReturnValue;}/*********************************************************************************** 函数名称: RfidUpdateTransEndProc** 功能描述：RFID接收数据处理** 函数输入：无** 函数输出：None** 注意事项：**********************************************************************************/static u32 WL_RfidUpdateTransEndProc(RFID_UPDATE_FRAME_TYPE *frame){	u32 u32ReturnValue = 0x01;	u32 u32I = 0x00;	u32 u32Temp = 0x00;	u16 u16SignalStatus;	#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */		 OS_CPU_SR  cpu_sr = 0;	#endif	if(InterfaceGetCtrlMode() != INTERFACE_MODE_RECV_PRG_ING)		return 0x00;			LedToggle(ADJUST_CODE_ING_LED);		if(frame->u32ID.ID.FrameType != WL_RFID_FT_UPDATE_END)		u32ReturnValue =  0x00;	if(frame->u8DT[0x00] !=  s_u32DownloaderId)		u32ReturnValue= 0x00;	u32I =0x00;	u32I = IapReadCodeLen(YKQ_WL_PROGRAM_BASE_ADDRESS+PROG_LENGTH_OFFSET_ADDRESS);	if(s_u32WriteAddr != (u32I+YKQ_WL_PROGRAM_BASE_ADDRESS+DEV_PROGRAM_VERSION_SIZE))		u32ReturnValue =  0x00;			#ifdef IWDG_ENABLED		IWDG_Feed();	#endif	if(RecvActionInfoFlag == 3)	{		u16 OldCrc = 0;		u32ReturnValue = 1;		//CRC校验，对比校验数据与头部crc数据是否相同		Crc16UsartSendChick((const u8 *)(&ActionInformation.Body),sizeof(ActionInformation.Body[0])*ActionInformation.Head.TotalAction,&OldCrc);		u32Temp = ActionInformation.Head.Verify;		if(OldCrc != u32Temp)			u32ReturnValue = 0x00;	}	else	{		u32I = IapExFlashCrc(YKQ_WL_PROGRAM_BASE_ADDRESS+DEV_PROGRAM_VERSION_SIZE,u32I);		u32Temp = IapReadCrc(YKQ_WL_PROGRAM_BASE_ADDRESS+PROG_CRCL_OFFSET_ADDRESS);		if(u32I != u32Temp)			u32ReturnValue = 0x00;		}	if(u32ReturnValue == 0x01)	{		#ifdef IWDG_ENABLED			IWDG_Feed();		#endif		StateLed(0x00,ADJUST_CODE_ING_LED);			KeyLedOnOff(0x00,KEY_LED_ALL);					u16SignalStatus = RFID_SIGNAL_TOO_SMALL;		LogicRunInfApi(LOGIC_SET_RFID_SIGNAL_STATUS, &u16SignalStatus);				LcdAreaClear(OLED_DISPLAY_NORMAL,6,0,7,127);		ShowStr(OLED_DISPLAY_NORMAL,"接收已完成",6, 19);						OSTimeDly(4500/TICK_TIME);						if(g_u32ID != B_type)		{			OSTaskResume(USART_TASK_PRIO);			if(RecvActionInfoFlag > 1)		//将配置文件写入flash			{				WriteActionInfo();				LcdAreaClear(OLED_DISPLAY_NORMAL,6,0,7,127);				ShowStr(OLED_DISPLAY_NORMAL,"即将重启",6, 32);				OSTimeDly(1500/TICK_TIME);				//进行程序的跳转,跳至BOOTLOADER				IapJumpToBoot(IN_FLASH_BOOTLOADER_ADDR);			}			else			{				YKQUpdateStatus = YKQ_UPDATE_PRG_SELF;				u32I = YKQ_UPDATE_PRG_SELF;				LogicParamApi(LOGIC_UPDATE_WL_PRG, &u32I);						}			#ifdef IWDG_ENABLED				IWDG_Feed();			#endif		}		else		{			u32Temp = LOGIC_STATUS_IDLE;			LogicRunInfApi(LOGIC_SET_RUN_STATUS,&u32Temp);			InterfaceInsertNote(INTERFACE_NOTE_SYSTEM_IDLE);				InterfaceSetCtrlMode(INTERFACE_MODE_IDLE);			InterfaceSetUpdateMainMethod(INTERFACE_SHOW_MAIN_ALL);			OSSemPost(g_stSemInterface);						StateLed(0x00,ADJUST_CODE_ING_LED);						OSTaskDel(RFIDMNG_UPDATE_TASK_PRIO);							OS_ENTER_CRITICAL();			RFID_Init(RFID_ININT_SYNC0,RFID_ININT_SYNC1);			RfidMngSetRecvCallBack();			OS_EXIT_CRITICAL();						OSTaskResume(IRMNG_TASK_PRIO);			OSTaskCreate(RfidMng_Task, (void *)0, &RfidMng_task_stk[RFIDMNG_TASK_STK_SIZE - 1], RFIDMNG_TASK_PRIO); 			}	}	else	{		#if (BSP_PRG_STORAGE_FLASH_FLAG	==	BSP_PRG_STORAGE_INFLASH_USE)			__disable_fault_irq();			FLASH_SetLatency(THE_DEV_FLASH_Latency);//120 MHz< HCLK <= 168 MHz			FLASH_Unlock();					#endif					IapEraserSector(YKQ_WL_PROGRAM_BASE_ADDRESS);		#if (BSP_PRG_STORAGE_FLASH_FLAG	==	BSP_PRG_STORAGE_INFLASH_USE)			FLASH_Lock();			__enable_fault_irq();					#endif						u16SignalStatus = RFID_SIGNAL_TOO_SMALL;		LogicRunInfApi(LOGIC_SET_RFID_SIGNAL_STATUS, &u16SignalStatus);			u32Temp = LOGIC_STATUS_IDLE;		LogicRunInfApi(LOGIC_SET_RUN_STATUS,&u32Temp);		InterfaceInsertNote(INTERFACE_NOTE_RECV_ERR);			InterfaceSetCtrlMode(INTERFACE_MODE_IDLE);		InterfaceSetUpdateMainMethod(INTERFACE_SHOW_MAIN_ALL);		OSSemPost(g_stSemInterface);				StateLed(0x00,ADJUST_CODE_ING_LED);							if(g_u32ID == B_type)		{			OS_ENTER_CRITICAL();			RFID_Init(RFID_ININT_SYNC0,RFID_ININT_SYNC1);			RfidMngSetRecvCallBack();			OS_EXIT_CRITICAL();		}		else		{			SendSetupToWl(RFID_ININT_SYNC1);			OSTaskResume(USART_TASK_PRIO);		}		OSTaskResume(IRMNG_TASK_PRIO);		OSTaskCreate(RfidMng_Task, (void *)0, &RfidMng_task_stk[RFIDMNG_TASK_STK_SIZE - 1], RFIDMNG_TASK_PRIO); 			OSTaskDel(RFIDMNG_UPDATE_TASK_PRIO);				}	RecvActionInfoFlag = 0;	return u32ReturnValue;}//配置参数版本信息帧	zzwstatic u32 ActionInfoSynchroVersionDwlProc(RFID_UPDATE_FRAME_TYPE *frame){	u32 u32Addr = 0x00;	u32 u32Length = 0x00;	u32 u32ReturnValue = 0x01;	u16 u16i,u16j;	#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */		OS_CPU_SR  cpu_sr = 0;	#endif		if(frame->u32ID.ID.FrameType != ACTION_INFO_SYNCHRO_DWL_VERSION)		u32ReturnValue = 0x00;		if(frame->u32ID.ID.SDL != (THE_DEV_TYPE&0xFF))		u32ReturnValue = 0x00;		if(frame->u8DT[0x1] == 0x01)		s_u32DownloaderId = frame->u8DT[0x00] ;	if(frame->u8DT[0x00] !=  s_u32DownloaderId)		u32ReturnValue = 0x00;	s_u32RecvPacketBackup = frame->u8DT[0x01];	s_u32RecvPacketBackup |= (frame->u8DT[0x02]<<8) ;		switch (s_u32RecvPacketBackup - s_u32RecvPacketTimes)	{		case 0:               //重复的帧 两遍			s_u32RecvPacketTimes++;			cachuFlag = 0;		break;		case 1:              //相差一帧 为正常顺序帧			s_u32RecvPacketTimes = 1;			s_u32RecvPacketTimes = s_u32RecvPacketBackup;			cachuFlag = 1;			break;		default:   //错误帧序列			break;	}		if(s_u32RecvPacketBackup%0x08)	{		u32Addr = s_u32RecvPacketBackup%0x08;		u32Addr--;	}	else	{		u32Addr = 0x07;	}	u32Addr *=  32;		memmove(s_u8RfidRecvBuf+u32Addr,&(frame->u8DT[0x03]) ,(frame->u8DLC)-0x03);	s_u32RfidRecvBufWrite	+=  frame->u8DLC-0x03;	s_u32WriteAddr = 0;	u32Length = frame->u8DT[8];	InterfaceSetDownloadRemainTimer(((u32Length) * TRANS_RECV_ACTION_INFO_BYTES_TIME*TRANS_PROG_TIMES));	#ifdef IWDG_ENABLED		IWDG_Feed();				//喂狗	#endif				InterfaceSetUpdateMainMethod(INTERFACE_SHOW_SELF_RECV_PRG);//显示主屏所有信息	OSSemPost(g_stSemInterface);	LedToggle(ADJUST_CODE_ING_LED);		InterfaceDecDownloadRemainTimer(TRANS_RECV_PRG_WRITE_TIME);	InterfaceSetCtrlMode(INTERFACE_MODE_RECV_PRG_ING);	return u32ReturnValue;}//配置参数版本信息写入帧	zzwstatic u32 ActionInfoSynchroVersionWriteProc(RFID_UPDATE_FRAME_TYPE *frame){	u32 u32I = 0x00;	u32 u32Crc = 0x00;	u32 u32ReturnValue = 0x01;		if(InterfaceGetCtrlMode() != INTERFACE_MODE_RECV_PRG_ING)		return 0x00;				if(frame->u32ID.ID.FrameType != ACTION_INFO_SYNCHRO_WRITE_VERSION)		u32ReturnValue =  0x00;	if(frame->u8DT[0x00] !=  s_u32DownloaderId)		u32ReturnValue =  0x00;	if(s_u32RfidRecvBufWrite != ACTION_INFO_HEAD_SIZE)	{		u32ReturnValue = 0x00;		}	//	memmove(&u32I,s_u8RfidRecvBuf+PROG_DEVTYPE_OFFSET_ADDRESS,0x04);// 	if(u32I!= YKQ_WL_DEV_TYPE)//		u32ReturnValue = 0x00;	//	//	memmove(&u32I,s_u8RfidRecvBuf+PROG_TARGETYPE_OFFSET_ADDRESS,0x04);// 	if(u32I!= TAGET_STM32L4_MCU)//		u32ReturnValue = 0x00;	s_u32RfidRecvBufWrite = ACTION_INFO_HEAD_SIZE;		//将缓存数据拷贝到配置文件头部信息	memmove(&ActionInformation+s_u32WriteAddr,s_u8RfidRecvBuf,s_u32RfidRecvBufWrite-s_u32WriteAddr);	s_u32WriteAddr += s_u32RfidRecvBufWrite - s_u32WriteAddr;		s_u32RecvPacketBackup = 0x00;	s_u32RecvPacketBackupLast = 0x00;//	s_u32WriteAddr = YKQ_WL_PROGRAM_BASE_ADDRESS+DEV_PROGRAM_VERSION_SIZE;		InterfaceDecDownloadRemainTimer(TRANS_RECV_PRG_WRITE_TIME);		InterfaceSetCtrlMode(INTERFACE_MODE_RECV_PRG_ING);	LedToggle(ADJUST_CODE_ING_LED);			return u32ReturnValue;}//配置参数数据帧	zzwstatic u32 ActionInfoSynchroCodeDwlProc(RFID_UPDATE_FRAME_TYPE *frame){	u32 u32ReturnValue = 0x01;	u32 u32Addr = 0x00;	#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */		OS_CPU_SR  cpu_sr = 0;	#endif	if(InterfaceGetCtrlMode() != INTERFACE_MODE_RECV_PRG_ING)		return 0x00;			if(frame->u32ID.ID.FrameType != ACTION_INFO_SYNCHRO_DWL_CODE)		u32ReturnValue =  0x00;	//	if(frame->u32ID.ID.SDL != (YKQ_WL_DEV_TYPE&0xFF))//		u32ReturnValue =  0x00;		if(frame->u8DT[0x00] !=  s_u32DownloaderId)		u32ReturnValue = 0x00;	s_u32RecvPacketBackup = frame->u8DT[0x01] ;	s_u32RecvPacketBackup |= (frame->u8DT[0x02]<<8);	s_u32RecvPacketBackup -= 1;	if(s_u32RecvPacketBackup == s_u32RecvPacketBackupLast)	{		s_u32RecvPacketBackupLast = s_u32RecvPacketBackup;		return 0x01;	}		if(s_u32RecvPacketBackup-s_u32RecvPacketBackupLast>1)		return 0;//	{//		u32ReturnValue = LOGIC_STATUS_IDLE;//		LogicRunInfApi(LOGIC_SET_RUN_STATUS,&u32ReturnValue);//		InterfaceInsertNote(INTERFACE_NOTE_RECV_ERR);	//		InterfaceSetCtrlMode(INTERFACE_MODE_IDLE);//		InterfaceSetUpdateMainMethod(INTERFACE_SHOW_MAIN_ALL);//		OSSemPost(g_stSemInterface);//		//		StateLed(0x00,ADJUST_CODE_ING_LED);	//		////		OS_ENTER_CRITICAL();		//		if(g_u32ID == B_type)//		{//			RFID_Init(RFID_ININT_SYNC0,RFID_ININT_SYNC1);//			RfidMngSetRecvCallBack();	//		}//		else//		{//			OSTaskResume(USART_TASK_PRIO);////			SendSetupToWl(RFID_ININT_SYNC1);//		}//		OSTaskResume(IRMNG_TASK_PRIO);//		OSTaskCreate(RfidMng_Task, (void *)0, &RfidMng_task_stk[RFIDMNG_TASK_STK_SIZE - 1], RFIDMNG_TASK_PRIO); 	//		OSTaskDel(RFIDMNG_UPDATE_TASK_PRIO);////		OS_EXIT_CRITICAL();	//	}		s_u32RecvPacketBackupLast = s_u32RecvPacketBackup;		if(s_u32RecvPacketBackup%0x08)	{		u32Addr = s_u32RecvPacketBackup%0x08;		u32Addr--;	}	else	{		u32Addr = 0x07;	}	u32Addr *=  32;		memmove(s_u8RfidRecvBuf+u32Addr,&(frame->u8DT[0x03]), (frame->u8DLC)-0x03);	s_u32RfidRecvBufWrite	+=  (frame->u8DLC)-0x03;			InterfaceDecDownloadRemainTimer(TRANS_RECV_PRG_WRITE_TIME);	InterfaceSetCtrlMode(INTERFACE_MODE_RECV_PRG_ING);	LedToggle(ADJUST_CODE_ING_LED);			return	u32ReturnValue;}//配置参数数据写入帧	zzwstatic u32 ActionInfoSynchroCodeWriteProc(RFID_UPDATE_FRAME_TYPE *frame){	u32 u32ReturnValue = 0x01;	u32 u32I = 0x00;	static u32 LastRfidRecvBufWrite;	if(LastRfidRecvBufWrite == s_u32RfidRecvBufWrite)	{		LastRfidRecvBufWrite = s_u32RfidRecvBufWrite;		return 0;	}	if(InterfaceGetCtrlMode() != INTERFACE_MODE_RECV_PRG_ING)		return 0x00;			if(frame->u32ID.ID.FrameType != ACTION_INFO_SYNCHRO_WRITE_CODE)		u32ReturnValue =  0x00;	if(frame->u8DT[0x00] !=  s_u32DownloaderId)		u32ReturnValue= 0x00;//	if(s_u32RecvPacketBackup == s_u32RecvPacketBackupLast)//	{//		s_u32RecvPacketBackupLast = s_u32RecvPacketBackup;//		return 0x01;//	}	if(s_u32RfidRecvBufWrite >= sizeof(ActionInformation))		return 0;		//将接收缓存中的数写入配置文件中	memmove(&ActionInformation.Head.Veron[0]+s_u32WriteAddr,s_u8RfidRecvBuf,s_u32RfidRecvBufWrite-s_u32WriteAddr);	s_u32WriteAddr += s_u32RfidRecvBufWrite - s_u32WriteAddr;		LastRfidRecvBufWrite = s_u32RfidRecvBufWrite;	InterfaceDecDownloadRemainTimer(TRANS_RECV_PRG_WRITE_TIME);		InterfaceSetCtrlMode(INTERFACE_MODE_RECV_PRG_ING);	LedToggle(ADJUST_CODE_ING_LED);			return u32ReturnValue;}//配置参数结束帧	zzwstatic u32 ActionInfoSynchroTransEndProc(RFID_UPDATE_FRAME_TYPE *frame){	u32 u32ReturnValue = 0x01;	u32 u32I = 0x00;	u32 u32Temp = 0x00;	u16 OldCrc = 0;	#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */		 OS_CPU_SR  cpu_sr = 0;	#endif	if(InterfaceGetCtrlMode() != INTERFACE_MODE_RECV_PRG_ING)		return 0x00;			LedToggle(ADJUST_CODE_ING_LED);		if(frame->u32ID.ID.FrameType != ACTION_INFO_SYNCHRO_END)		u32ReturnValue =  0x00;	if(frame->u8DT[0x00] !=  s_u32DownloaderId)		u32ReturnValue= 0x00;//	if(s_u32WriteAddr != (u32I+THE_DEV_PRG_STORAGE_BASEADDR+DEV_PROGRAM_VERSION_SIZE))//		u32ReturnValue =  0x00;			#ifdef IWDG_ENABLED		IWDG_Feed();	#endif	//CRC校验，对比校验数据与头部crc数据是否相同	Crc16UsartSendChick((const u8 *)(&ActionInformation.Body),sizeof(ActionInformation.Body[0])*ActionInformation.Head.TotalAction,&OldCrc);	u32Temp = ActionInformation.Head.Verify;	//zzw	清除心跳	if(RfidGetDataLimitlessSendFlag())	{		RfidSetDataLimitlessSendEnd();	}	if(OldCrc != u32Temp)		u32ReturnValue = 0x00;	//校验成功，写入flash中	if(u32ReturnValue == 0x01)	{		InterfaceSetDownloadRemainTimer(0);			WriteActionInfo();		#ifdef IWDG_ENABLED			IWDG_Feed();		#endif						StateLed(0x00,ADJUST_CODE_SUCCEED_LED);					LcdAreaClear(OLED_DISPLAY_NORMAL,6,0,7,127);//		ShowStr(OLED_DISPLAY_NORMAL,"即将重启",6, 32);		ShowStr(OLED_DISPLAY_NORMAL,"同步完成 重启",6, 8);				OSTaskResume(IRMNG_TASK_PRIO);		OSTaskCreate(RfidMng_Task, (void *)0, &RfidMng_task_stk[RFIDMNG_TASK_STK_SIZE - 1], RFIDMNG_TASK_PRIO); 		u32I = LOGIC_STATUS_RFID_UNCOLIBRATE;		LogicRunInfApi(LOGIC_SET_RUN_STATUS,&u32I);//		OSTimeDly(1500/TICK_TIME);		RebootSet = 1;		OSTaskDel(RFIDMNG_UPDATE_TASK_PRIO);		//进行程序的跳转,跳至BOOTLOADER//		IapJumpToBoot(IN_FLASH_BOOTLOADER_ADDR);		//没起作用，应该是看门狗复位	}	//校验失败，读取flash中的数据。	else	{		InterfaceSetDownloadRemainTimer(0);				StateLed(0x00,ADJUST_CODE_SUCCEED_LED);					LcdAreaClear(OLED_DISPLAY_NORMAL,6,0,7,127);		ShowStr(OLED_DISPLAY_NORMAL,"同步失败 重启",6, 8);		StateLed(0x00,ADJUST_CODE_ING_LED);			RebootSet = 1;		OSTaskResume(IRMNG_TASK_PRIO);		OSTaskCreate(RfidMng_Task, (void *)0, &RfidMng_task_stk[RFIDMNG_TASK_STK_SIZE - 1], RFIDMNG_TASK_PRIO); 			OSTaskDel(RFIDMNG_UPDATE_TASK_PRIO);			}	return u32ReturnValue;}/*********************************************************************************** 函数名称: RfidUpdateRecvDataProc** 功能描述：RFID接收数据处理** 函数输入：无** 函数输出：None** 注意事项：**********************************************************************************/static u32 RfidUpdateRecvDataProc(void){	st_RFIDRcvFrame RfidRcvFrm;	RFID_UPDATE_FRAME_TYPE stRxFrame;	u32 u32Temp= 0x00;	u32 u32Temp2 = 0x00;	s8 s8RssiSignalInf;	LOGIC_RUN_STATUS_TYPE stLogicRunStatus;		RFID_FetchData(&RfidRcvFrm);	LogicParamApi(LOGIC_GET_YKQ_NUMBER,&u32Temp);	if((RfidRcvFrm.u8DestAddr != (u8)u32Temp) && (RfidRcvFrm.u8DestAddr != 0x00))		return 0x00;	LogicRunInfApi(LOGIC_GET_RUN_STATUS,&stLogicRunStatus);	if((stLogicRunStatus != LOGIC_STATUS_RFID_RECV_PRG)		&&(stLogicRunStatus != LOGIC_STATUS_ACTION_MESS_REQ))		return 0x00;		stRxFrame.u32ID.u32Id = RfidRcvFrm.u8Data[0x00];	stRxFrame.u32ID.u32Id |= (u32)(RfidRcvFrm.u8Data[0x01]<<8);	stRxFrame.u32ID.u32Id |= (u32)(RfidRcvFrm.u8Data[0x02]<<16);	stRxFrame.u32ID.u32Id |= (u32)(RfidRcvFrm.u8Data[0x03]<<24);		stRxFrame.u8DLC = RfidRcvFrm.u8Data[0x04];	s8RssiSignalInf = RfidRcvFrm.u8AppendStatus[0x00];	//s8IqiSignalInf = RfidRcvFrm.u8AppendStatus[0x01];	if(s8RssiSignalInf >= 128)		s8RssiSignalInf = (s8RssiSignalInf-256)/2-RSSI_OFFSET_VALUE;	else		s8RssiSignalInf = (s8RssiSignalInf)/2-RSSI_OFFSET_VALUE;	if(s8RssiSignalInf >= -30)		u32Temp = RFID_SIGNAL_NEGATIVE_30;	else if(s8RssiSignalInf >= -40)		u32Temp = RFID_SIGNAL_NEGATIVE_40;	else if(s8RssiSignalInf >= -50)		u32Temp = RFID_SIGNAL_NEGATIVE_50;	else if(s8RssiSignalInf >= -60)		u32Temp = RFID_SIGNAL_NEGATIVE_60;	else if(s8RssiSignalInf >= -80)		u32Temp= RFID_SIGNAL_NEGATIVE_80;	else		u32Temp = RFID_SIGNAL_TOO_SMALL;	LogicRunInfApi(LOGIC_GET_RFID_SIGNAL_STATUS, &u32Temp2);	if(u32Temp != u32Temp2)	{		LogicRunInfApi(LOGIC_SET_RFID_SIGNAL_STATUS, &u32Temp);		u32Temp2 = (u32)(InterfaceGetCtrlMode());		if((u32Temp2 == INTERFACE_MODE_RECV_PRG_ING)\		  ||(u32Temp2 == INTERFACE_MODE_RECV_PRG_START))		{			InterfaceSetUpdateMainMethod(INTERFACE_SHOW_MAIN_RFIDSIGNAL);			OSSemPost(g_stSemInterface);						}					}		for(u32Temp = 0x00; u32Temp < stRxFrame.u8DLC; u32Temp++)	{		stRxFrame.u8DT[u32Temp] = RfidRcvFrm.u8Data[0x05+u32Temp];	}	if((stRxFrame.u32ID.ID.FrameType >= RFID_FT_UPDATE_END) && (stRxFrame.u32ID.ID.FrameType <= RFID_FT_UPDATE_DWL_VERSION))	{		u32Temp = (*RfidUpdateProcFuncs[stRxFrame.u32ID.ID.FrameType-RFID_FT_UPDATE_END])(&stRxFrame);	}			if((stRxFrame.u32ID.ID.FrameType >= WL_RFID_FT_UPDATE_END) && (stRxFrame.u32ID.ID.FrameType <= WL_RFID_FT_UPDATE_DWL_VERSION))	{		u32Temp = (*WL_RfidUpdateProcFuncs[stRxFrame.u32ID.ID.FrameType-WL_RFID_FT_UPDATE_END])(&stRxFrame);	}	//配置文件同步	if((stRxFrame.u32ID.ID.FrameType >= ACTION_INFO_SYNCHRO_END) && (stRxFrame.u32ID.ID.FrameType <= ACTION_INFO_SYNCHRO_DWL_VERSION))	{		u32Temp = (*ActionInfoSynchroProcFuncs[stRxFrame.u32ID.ID.FrameType-ACTION_INFO_SYNCHRO_END])(&stRxFrame);	}		return u32Temp;}/*********************************************************************************** 函数名称: RfidUpdateSendDataProc** 功能描述：RFID发送数据处理** 函数输入：无** 函数输出：None** 注意事项：**********************************************************************************/static u32 RfidUpdateSendDataProc(void){	u32 u32ReturnFlag = 0x00;		if(s_u32RfidSendBufRead != s_u32RfidSendBufWrite)	{		if(s_u32SendTimer == 0x00)		{			if(s_stRfidSendBuf[s_u32RfidSendBufRead].u32SendTimes)			{				u32ReturnFlag = RfidUpdateSendFrame(&(s_stRfidSendBuf[s_u32RfidSendBufRead]));				LedToggle(ADJUST_CODE_ING_LED);				if(s_stRfidSendBuf[s_u32RfidSendBufRead].u32SendTimes != RFID_SEND_TIMES_LIMITLESS)					s_stRfidSendBuf[s_u32RfidSendBufRead].u32SendTimes--;				if(s_stRfidSendBuf[s_u32RfidSendBufRead].u32SendTimes && (s_stRfidSendBuf[s_u32RfidSendBufRead].u32SendInterval != RFID_SEND_INTERVAL_CLOSED))					s_u32SendTimer = s_stRfidSendBuf[s_u32RfidSendBufRead].u32SendInterval;								}			else			{				s_u32RfidSendBufRead++;				s_u32RfidSendBufRead %= RFIDUPDATE_SEND_BUF_SIZE;								s_u32SendTimer = 0x00;							}		}				}	else	{		s_u32SendTimer = 0x00;	}		if(s_u32SendTimer && (s_u32SendTimer != RFID_SEND_INTERVAL_CLOSED))	{		if(s_u32SendTimer >= RFIDMNG_UPDATE_TASK_TIME_SET)			s_u32SendTimer -= RFIDMNG_UPDATE_TASK_TIME_SET;		else			s_u32SendTimer = 0x00;	}		return u32ReturnFlag;}/*********************************************************************************** 函数名称: RfidUpdateSendDataProc** 功能描述：RFID发送数据处理** 函数输入：无** 函数输出：None** 注意事项：**********************************************************************************/void RfidUpdateRecvNoDataProc(void){	u32	j;	static u32 RFID_StateInquireIntv = 0;	static u32 RFID_Init_Num = 0;	#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */		OS_CPU_SR  cpu_sr = 0;	#endif		RFID_StateInquireIntv++;				//周期检查无线是否处于正确状态	if (RFID_StateInquireIntv >= 5)			//100ms =5*WL_RX_TASK_INTERVAL	{		RFID_StateInquireIntv = 0;		//获取RDID状态		j = GetRfidCurStatus();		switch(j&0xf0)		{			case CC1101_STATE_IDLE:				SetRfidSRX();				//设置RFID进入接收状态				RFID_Init_Num = 0;				break;						case CC1101_STATE_RX:			case CC1101_STATE_TX:			case CC1101_STATE_FSTXON:			case CC1101_STATE_CALIBRATE:			case CC1101_STATE_SETTLING:				RFID_Init_Num = 0;				break;						case CC1101_STATE_RX_OVERFLOW:				RfidStrobe(CC1101_SFRX);	//冲洗 RX FIFO buffer.				RfidStrobe(CC1101_SRX);		//进入接收状态					RFID_Init_Num = 0;				break;						case CC1101_STATE_TX_UNDERFLOW:				RfidStrobe(CC1101_SFTX);    //冲洗 TX FIFO buffer.				RfidStrobe(CC1101_SRX);		//进入接收状态					RFID_Init_Num = 0;				break;						default:				if (j == TIME_OVER && RFID_Init_Num < 5)	//重新初始化RFID				{					RFID_Init_Num++;					OS_ENTER_CRITICAL();					RFID_Init(RFID_PRG_ININT_SYNC0,RFID_PRG_ININT_SYNC1);					RfidMngSetRecvCallBack();					OS_EXIT_CRITICAL();				}			break;					}	}		}/*********************************************************************************** 函数名称: RfidMng_Update_Task** 功能描述：RFID无线管理管理任务处理** 函数输入：无** 函数输出：None** 注意事项：**********************************************************************************/void RfidMng_Update_Task(void *p_arg){	INT8U err;	cachuFlag = 0;	s_u32RecvPacketTimes = 0;	while(1)	{				OSSemPend(s_stRfidRecvd, RFIDMNG_UPDATE_TASK_TIME_SET/TICK_TIME, &err);//发送间隔			if(err == OS_ERR_NONE)//接收数据，处理		{			RfidUpdateRecvDataProc();//接收数据处理		}		else		{			LogicRunInfApi(LOGIC_GET_RUN_STATUS,&err);			if((err == LOGIC_STATUS_RFID_TRANS_PRG)||(err == LOGIC_STATUS_RFID_TRANS_WL_PRG)				|| (err == LOGIC_STATUS_ACTION_MESS_REQ))			{				RfidUpdateSendDataProc();//发送数据处理 			}			else			{				if(g_u32ID == B_type)					RfidUpdateRecvNoDataProc();//无接收数据处理			}		}	}}#endif