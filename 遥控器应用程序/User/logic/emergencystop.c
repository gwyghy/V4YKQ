/********************************************************************************* 模块名：emergencystop.c* 作者：	马如意 * 版本：   	v1.0* 日期：    2015.5.18* 功能描述:  用于急停信号检测和处理* 修改说明：   **       >>>>  在工程中的位置  <<<<*             3-应用层*             2-协议层*           √ 1-硬件驱动层*********************************************************************************//********************************************************************************* .h头文件*********************************************************************************/#include	"includes.h"/********************************************************************************* #define宏定义*********************************************************************************//********************************************************************************* 常量定义*********************************************************************************//********************************************************************************* 变量定义*********************************************************************************//********************************************************************************* 函数定义*********************************************************************************/void ADC_Configuration(void){	GPIO_InitTypeDef GPIO_InitStructure;//	ADC_InitTypeDef ADC_InitStructure;	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOB, ENABLE);	RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1, ENABLE); 		/* Configure PB0 (ADC Channel8) as analog input -------------------------*/	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;	GPIO_Init(GPIOB, &GPIO_InitStructure);	   //  /* ADC1 configuration ------------------------------------------------------*///  ADC_InitStructure.ADC_Mode = ADC_Mode_Independent;	   /* 独立模式 *///  ADC_InitStructure.ADC_ScanConvMode = ENABLE;			   /* 连续多通道模式 *///  ADC_InitStructure.ADC_ContinuousConvMode = ENABLE;	   /* 连续转换 *///  ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;  /* 转换不受外界决定 *///  ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;		       /* 右对齐 *///  ADC_InitStructure.ADC_NbrOfChannel = 1;					   /* 扫描通道数 *///  ADC_Init(ADC1, &ADC_InitStructure);//  /* ADC1 regular channel8 configuration */ //  ADC_RegularChannelConfig(ADC1, ADC_Channel_8, 1, ADC_SampleTime_239Cycles5);  /* 通道X,采用时间为55.5周期,1代表规则通道第1个 */	//  ADC_Cmd(ADC1, ENABLE);                 /* Enable ADC1 */                      //  ADC_SoftwareStartConvCmd(ADC1,ENABLE);    /* 使能转换开始 */}unsigned short ADCRead(void){	unsigned short TempValue;	TempValue=ADC_GetConversionValue(ADC1);	//TempValue=(unsigned short)((((unsigned int)TempValue)*6325)/1024);	return TempValue;}void BS_Init(void){	GPIO_InitTypeDef GPIO_InitStructure; 	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOC, ENABLE);	/* Configure PC6~7 in output pushpull mode */			//急停指示灯	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6;	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;	GPIO_InitStructure.GPIO_Mode =GPIO_Mode_OUT;	GPIO_InitStructure.GPIO_OType=GPIO_OType_PP;	GPIO_Init(GPIOC, &GPIO_InitStructure);	/* Set the PC6 */	GPIO_SetBits(GPIOC, GPIO_Pin_6);	StateLed(0x0, LED_STOP | LED_LOCK);}void StopLockInit(void){	ADC_Configuration();	BS_Init();}u16 CheckBS(void){	static u16 u16Lock=FALSE;	static u16 u16LockEnabledCount=0;	static u16 u16LockDisabledCount=0;	if (GPIO_ReadInputDataBit(GPIOE,GPIO_Pin_6)==1)		//	{		u16LockDisabledCount = 0;		if (u16LockEnabledCount < 3)			u16LockEnabledCount++;	}else	{		u16LockEnabledCount = 0;		if (u16LockDisabledCount < 3)			u16LockDisabledCount++;	}	if ((u16LockEnabledCount == 3) && (u16Lock == FALSE))	{		u16Lock = TRUE;		StateLed(LED_LOCK, 0x00);	}	else if((u16LockDisabledCount == 3) && (u16Lock == TRUE))	{		u16Lock = FALSE;		StateLed(0x00, LED_LOCK);	}	return(u16Lock);}u16 CheckJT(void){	if(ADCRead()>0x0800)	{		return(TRUE);	}	else	{		return(FALSE);	}}