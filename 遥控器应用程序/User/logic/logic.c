/********************************************************************************* 文件名：	logic.c* 作者：    马如意* 版本：   	V1.0* 日期：    2015.05.15  * 功能描述: 无线遥控器逻辑层主处理模块。* 			 *			 *			 *			 *			 * 修改说明：   **       >>>>  在工程中的位置  <<<<*             3-应用层*          √ 2-协议层*             1-硬件驱动层********************************************************************************** @copy* <h2><center>&copy; COPYRIGHT 天津华宁电子有限公司 研发中心 软件部</center></h2>*********************************************************************************//********************************************************************************* .h头文件*********************************************************************************/#include "includes.h"#include "InterfaceApp.h"/********************************************************************************* #define宏定义*********************************************************************************/u16 IRSEND;#define LOGIC_PARAM_STORAGE_BASEADDR			DATA_EEPROM_START_ADDR#define LOGIC_PARAM_STORAGE_TURNON_ADDRESS		LOGIC_PARAM_STORAGE_BASEADDR+sizeof(LOGIC_PARAM_TYPE)+0x00#define LOGIC_PARAM_STORAGE_ACR_ADDRESS			LOGIC_PARAM_STORAGE_BASEADDR+sizeof(LOGIC_PARAM_TYPE)+0x04#define LOGIC_PARAM_STORAGE_COLDATA_ADDRESS		LOGIC_PARAM_STORAGE_BASEADDR+sizeof(LOGIC_PARAM_TYPE)+0x08#define LOGIC_PARAM_STORAGE_VOLTAGE_ADDRESS		LOGIC_PARAM_STORAGE_BASEADDR+sizeof(LOGIC_PARAM_TYPE)+0x0C#define LOGIC_PARAM_STORAGE_INCHARGE_TIMER		LOGIC_PARAM_STORAGE_BASEADDR+sizeof(LOGIC_PARAM_TYPE)+0x10#define	YK_PRG_SEC_NUMBER						0x17032010//程序随机编号#define	LOGIC_TASK_TIME_SET						10//任务执行周期#define	RFID_SAMPLE_TIME_SET					1000//单位ms#define	LOGIC_TASK_POWERUP_DELAY				1000//任务执行周期#define BATTERY_LOW_SHUTDOWN_TIMER				10000//即将关机时间#if (ONLINE_UPDATE_SELF_PRG_PT_FLAG	!= DISABLED)	#define	LOGIC_UPDATE_SEND_INTERVAL_SET		230		//160//发送间隔	zzw#endifu8 u8tmp_Logic[30];u32 YKQUpdateStatus;u16 Iwdg_Logic = 0;extern u8 RebootSet;/********************************************************************************* 常量定义*********************************************************************************//**默认参数值**********/LOGIC_PARAM_TYPE	const	s_stLogicParamDefault = {	YK_PRG_SEC_NUMBER,//程序的随机号		0x01,//支架遥控器编号	0xFE,//RFID发射对应的编号	300,//Ir对码超时时间,ms			10,	//Ir对码次数,次		60,//Rfid对码超时时间,ms		5,//Rfid对码次数,次		150,//oled屏亮度的参数		0,//屏保时亮度	0x00,//预留	#if (INTERFACE_UNCOLIBRATE_LONGER_TIMER_FLAG != 0)		120000,//对码超时	#else		30000,//对码超时	#endif		20000,//显示控制计时，,ms	30000,//休屏的时间设定,ms	5000,//提示信息显示计时,ms	300000,//自动关机时间，ms		#if (QUICK_KEY_CTRL_ENABLE_FLAG	!= DISABLED)		#if (QUICK_KEY_1_ENABLE_FLAG != DISABLED)			/**快捷键1参数**/			ENABLED,			0x04,			0x00,							{0x01,	0x04,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00},			{0,		30,		0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00},//以0.1秒进行参数存储			{30,	6000,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00},//以0.1秒进行参数存储		#endif		#if (QUICK_KEY_2_ENABLE_FLAG != DISABLED)			/**快捷键2参数**/			DISABLED,			0x00,			50,			{0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00},			{0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00},//以0.1秒进行参数存储			{0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00},//以0.1秒进行参数存储		#endif	#endif		#if (SET_YKQ_PRGPT_USE_FLAG != 0)		0x00,		0x00,			0x00,				"V1.0.0.0f",	#endif	#if (ZIBAO_CTRL_ENABLE_FLAG != DISABLED)		ENABLED,		0x06,				#if (ZIBAO_CTRL_METHOD_TYPE == ZIBAO_PARAM_CTRL_METHOD)			5000,//以1毫秒进行参数存储					{				ENABLED,ENABLED,ENABLED,ENABLED,\				ENABLED,ENABLED,ENABLED,ENABLED,\			 	DISABLED,DISABLED,ENABLED,ENABLED,\			 	ENABLED,DISABLED,DISABLED,DISABLED,\				DISABLED,DISABLED,DISABLED,DISABLED,\				DISABLED,DISABLED,DISABLED,DISABLED,\				DISABLED,DISABLED,DISABLED,DISABLED,\				DISABLED,DISABLED,			},						{				/*以0.1秒进行参数存储*/				50,50,50,50,\				50,50,50,50,\				50,50,50,50,\				50,50,50,50,\				50,50,50,50,\				50,50,50,50,\				50,50,50,50,\				50,50,						},		#endif			#endif	#if IR_SEND > 0	0 ,	#endif	10000,//预留	ENABLED,//   jhy    DISABLE,   //无线测试	0x00//CRC校验值，在将参数写入到E2PROM时，会重新计算CRC校验值	};LOGIC_PARAM_TYPE	const	s_stLogicParamDefault_D = {	YK_PRG_SEC_NUMBER,//程序的随机号		0x01,//支架遥控器编号	0xFE,//RFID发射对应的编号	300,//Ir对码超时时间,ms			10,	//Ir对码次数,次		100,//Rfid对码超时时间,ms		3,//Rfid对码次数,次		150,//oled屏亮度的参数		0,//屏保时亮度	0x00,//预留	#if (INTERFACE_UNCOLIBRATE_LONGER_TIMER_FLAG != 0)		120000,//对码超时	#else		30000,//对码超时	#endif		20000,//显示控制计时，,ms	30000,//休屏的时间设定,ms	5000,//提示信息显示计时,ms	300000,//自动关机时间，ms		#if (QUICK_KEY_CTRL_ENABLE_FLAG	!= DISABLED)		#if (QUICK_KEY_1_ENABLE_FLAG != DISABLED)			/**快捷键1参数**/			ENABLED,			0x04,			0x00,							{0x01,	0x04,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00},			{0,		30,		0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00},//以0.1秒进行参数存储			{30,	6000,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00},//以0.1秒进行参数存储		#endif		#if (QUICK_KEY_2_ENABLE_FLAG != DISABLED)			/**快捷键2参数**/			DISABLED,			0x00,			50,			{0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00},			{0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00},//以0.1秒进行参数存储			{0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00},//以0.1秒进行参数存储		#endif	#endif		#if (SET_YKQ_PRGPT_USE_FLAG != 0)		0x00,		0x00,			0x00,				"V1.0.0.0f",	#endif	#if (ZIBAO_CTRL_ENABLE_FLAG != DISABLED)		ENABLED,		0x06,				#if (ZIBAO_CTRL_METHOD_TYPE == ZIBAO_PARAM_CTRL_METHOD)			5000,//以1毫秒进行参数存储					{				ENABLED,ENABLED,ENABLED,ENABLED,\				ENABLED,ENABLED,ENABLED,ENABLED,\			 	DISABLED,DISABLED,ENABLED,ENABLED,\			 	ENABLED,DISABLED,DISABLED,DISABLED,\				DISABLED,DISABLED,DISABLED,DISABLED,\				DISABLED,DISABLED,DISABLED,DISABLED,\				DISABLED,DISABLED,DISABLED,DISABLED,\				DISABLED,DISABLED,			},						{				/*以0.1秒进行参数存储*/				50,50,50,50,\				50,50,50,50,\				50,50,50,50,\				50,50,50,50,\				50,50,50,50,\				50,50,50,50,\				50,50,50,50,\				50,50,						},		#endif			#endif	#if IR_SEND > 0	0 ,	#endif	10000,//预留				ENABLED,//   jhy    DISABLE,    //无线测试	0x00//CRC校验值，在将参数写入到E2PROM时，会重新计算CRC校验值	};/**逻辑层可以支持的键盘膜定义***/	//选择键盘膜	2020.01.15 parry//const u8 u8LogicSupportKeyFilm[][9] = //{//	"四柱综放",//	"两柱综采",//	"自定义",//};	/**逻辑层可以支持的动作定义***/	//const u8 u8LogicSupportAction[][9] = 	//顺序须和InterfaceApp.h中的宏定义一致	设定按键动作	2020.01.15 parry//{//	/*无效*///	"无",//	//	/*单架动作**///	//"菜单菜单菜单菜单"	//	"升柱",//	"降柱",//	"推溜",//	"移架",//	"伸伸缩梁",	//	//	"收伸缩梁",//	"伸摆梁",//	"收摆梁",//	"伸护帮",//	"收护帮",//	//	"伸侧护",//	"收侧护",//	"抬底",//	"降底",//	"伸护帮2",//	//	"收护帮2",//	"伸尾梁",//	"收尾梁",//	"伸插板",//	"收插板",//	//	"升后柱",	//	"降后柱",//	"喷雾",//	"后喷雾",//	"松后溜",//	//	"拉后溜", //	"伸底调",//	"收底调",//	"伸前梁",//	"收前梁",//	"反冲1",//	"反冲2",//	"伸掩侧",//	"收掩侧",//	"伸护帮3",//	//	"收护帮3",//	"伸平衡",//	"收平衡",//	"伸调溜",//	"收调溜",//	//	"快捷键F1",//	"快捷键F2",//	"升前柱",//	"降前柱",	//	"伸顶侧",//	//	"收顶侧",//};#if (QUICK_KEY_CTRL_ENABLE_FLAG != 0)	const u32 u32LogicSupportRfidData[] = 	{		0x00,		RFID_ACTION_JIANGZHU|RFID_ACTION_JIANG_HOUZHU,		RFID_ACTION_JIANG_HOUZHU,		RFID_ACTION_JIANGZHU,				RFID_ACTION_YIJIA ,//包含移架(拉溜)				RFID_ACTION_SHENGZHU|RFID_ACTION_SHENG_HOUZHU,		RFID_ACTION_SHENG_HOUZHU,		RFID_ACTION_SHENGZHU,				RFID_ACTION_TUILIU,		RFID_ACTION_LA_HOULIU,		RFID_ACTION_FANGMEI_PENWU ,//在阳煤矿中，以此代替松后溜		RFID_ACTION_SHEN_CEHU,		RFID_ACTION_SHOU_CEHU,			RFID_ACTION_SHEN_SHENSUOLIANG ,		RFID_ACTION_SHOU_SHENSUOLIANG ,		RFID_ACTION_WEILIANG_SHANGBAI ,		RFID_ACTION_WEILIANG_XIABAI,		RFID_ACTION_SHEN_CHABAN,		RFID_ACTION_SHOU_CHABAN,			RFID_ACTION_TAI_DIZUO,		RFID_ACTION_JIANG_DIZUO		};#endif	/********************************************************************************* 变量定义*********************************************************************************/static LOGIC_PARAM_TYPE	s_stLogicParamSystem;//系统运行过程中使用的参数static LOGIC_RUNINF_TYPE	s_stLogicRunInf;//系统运行信息static u32 s_u32LogicSampleTimer;//采样周期static u8 s_u8YkqIdBackup;OS_EVENT  *g_stLogicSem;	//逻辑层信号量static u32 u32ShutDownTimer = 0x00;//关机计时器#if (ZIBAO_CTRL_ENABLE_FLAG != DISABLED)		static u32 s_u32ZibaoCtrlTimer = 0x00;	#if (ZIBAO_CTRL_METHOD_TYPE	==	ZIBAO_PARAM_CTRL_METHOD)		static u32 s_u32ZibaoAcionKeyBackup = 0x00;		static u32 s_u32ZibaoActionIngTime[LOGIC_ZIBAO_ACTIONNUMB_MAX];	#endif#endif#if (ONLINE_UPDATE_SELF_PRG_PT_FLAG	!= DISABLED)	//马如意，2017.06.20定义的一些变量，用于程序的下载以及参数的传递(此时，需进行强制类型转化)。	u32 s_u32DownProgramType;//传递设备类型	u32 s_u32DownProgLength;//程序的总长度	u32 s_u32DownProgTotalPacketNumb = 0x00;//程序的总包数	u32 s_u32DownProgSendPacketNumb =0x00;//程序的当前传递包数	u32 s_u32DownProgAddr =0x00;//程序读取的地址	u32 s_u32SendInterval;//两次发送的间隔，需考虑FLASH的擦除时间	u32 s_u32DestDevID;		extern OS_STK  RfidMng_task_stk[RFIDMNG_TASK_STK_SIZE];			//开辟任务堆栈	#endif	//u16 u16KeySetActionNameRam[LOGIC_KEYSET_ACTIONNUMB_MAX];		//设定按键动作	2020.01.15 parry//u16 u16KeyFilmNameRam; //=0 综放键盘膜；=1 综采键盘膜；=2 自定义键盘膜extern u16 KEY_SC_GRP_OFF_LED; 	//成组模式下第一功能中不能成组的键的灯值	2020.04.27  parryextern u16 KEY_SC_GRP_SHIFT_OFF_LED; 	//成组模式下第二功能中不能成组的键的灯值/********************************************************************************* 函数声明*********************************************************************************//**参数读写相关的接口函数声明**/static u32 LogicSetPrgSecProc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData);static u32 LogicSetYkqNumbProc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData);static u32 LogicSetRfidSelfNumbProc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData);static u32 LogicSetIrSendTimeoutProc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData);static u32 LogicSetIrSendTimesProc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData);static u32 LogicSetRfidSendTimeoutProc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData);static u32 LogicSetRfidSendTimesProc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData);static u32 LogicSetOledScrLightProc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData);static u32 LogicSetOledProtectBrightnessProc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData);static u32 LogicSetOledProtectedTimerProc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData);static u32 LogicSetOledShutdownTimerProc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData);static u32 LogicSetColibarateTimeoutProc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData);static u32 LogicSetInterCtrlTimerProc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData);static u32 LogicSetNoteShowTimerProc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData);static u32 LogicSetScCtrlDislayTimerProc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData);static u32 LogicSetYkqIdBackupProc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData);static u32 LogicSetShutDownFlagProc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData);static u32 LogicSetBatteryAcrBackupProc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData);static u32 LogicSetBatteryColDataBackupProc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData);static u32 LogicSetBatterVoltageBackupProc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData);static u32 LogicSetBatterInchargeTimerProc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData);static u32 LogicSetWLVersionProc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData);#if (QUICK_KEY_CTRL_ENABLE_FLAG	!= DISABLED)	#if (QUICK_KEY_1_ENABLE_FLAG != DISABLED)		static u32 LogicSetQuick1EnableFalg(LOGIC_PARAM_MSG_TYPE sMsg,void *pData);		static u32 LogicSetQuick1ActionNumb(LOGIC_PARAM_MSG_TYPE sMsg,void *pData);		static u32 LogicSetQuick1AlaramTime(LOGIC_PARAM_MSG_TYPE sMsg,void *pData);		static u32 LogicSetQuick1ActionName(LOGIC_PARAM_MSG_TYPE sMsg,void *pData);		static u32 LogicSetQuick1ActionTime(LOGIC_PARAM_MSG_TYPE sMsg,void *pData);		static u32 LogicSetQuick1ActionInterval(LOGIC_PARAM_MSG_TYPE sMsg,void *pData);	#endif		#if (QUICK_KEY_2_ENABLE_FLAG != DISABLED)		static u32 LogicSetQuick2EnableFalg(LOGIC_PARAM_MSG_TYPE sMsg,void *pData);		static u32 LogicSetQuick2ActionNumb(LOGIC_PARAM_MSG_TYPE sMsg,void *pData);		static u32 LogicSetQuick2AlaramTime(LOGIC_PARAM_MSG_TYPE sMsg,void *pData);		static u32 LogicSetQuick2ActionName(LOGIC_PARAM_MSG_TYPE sMsg,void *pData);		static u32 LogicSetQuick2ActionTime(LOGIC_PARAM_MSG_TYPE sMsg,void *pData);		static u32 LogicSetQuick2ActionInterval(LOGIC_PARAM_MSG_TYPE sMsg,void *pData);	#endif#endif#if (SET_YKQ_PRGPT_USE_FLAG != 0)	static u32 LogicSetColibrateYkqIdProc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData);		static u32 LogicSetColibrateYkqTypeProc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData);		static u32 LogicSetColibrateYkqStationProc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData);	static u32 LogicSetColibrateYkqVersionProc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData);	#endif	static u32 LogicSetFastColiearateEnableProc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData);#if (ZIBAO_CTRL_ENABLE_FLAG != DISABLED)	static u32 LogicSetZibaoEnabledFlagProc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData);		static u32 LogicSetZibaoActionMaxProc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData);		#if (ZIBAO_CTRL_METHOD_TYPE	== ZIBAO_PARAM_CTRL_METHOD)//自保动作使能设置		static u32 LogicSetZibaoTimeOutProc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData);			static u32 LogicSetZibaoActionEnableFlagProc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData);				static u32 LogicSetZibaoActionIngTimeProc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData);		#endif		#endif#if (ONLINE_UPDATE_SELF_PRG_PT_FLAG	!= DISABLED)	static u32 LogicUpdateYkqPrgProc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData);	static u32 LogicUpdateCxbPrgProc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData);	static u32 LogicUpdateWLPrgProc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData);	static u32 LogicUpdateCxbWLPrgProc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData);#endif/**************************获取参数*************************/static u32 LogicGetPrgSecProc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData);static u32 LogicGetYkqNumbProc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData);static u32 LogicGetRfidSelfNumbProc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData);static u32 LogicGetIrSendTimeoutProc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData);static u32 LogicGetIrSendTimesProc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData);static u32 LogicGetRfidSendTimeoutProc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData);static u32 LogicGetRfidSendTimesProc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData);static u32 LogicGetOledScrLightProc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData);static u32 LogicGetOledProtectBrightnessProc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData);static u32 LogicGetOledProtectedTimerProc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData);static u32 LogicGetOledShutdownTimerProc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData);static u32 LogicgGetColibarateTimeoutProc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData);static u32 LogicGetInterCtrlTimerProc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData);static u32 LogicGetNoteShowTimerProc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData);static u32 LogicGetScCtrlDislayTimerProc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData);static u32 LogicGetYkqIdBackupProc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData);static u32 LogicGetShutDownFlagProc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData);static u32 LogicGetBatteryAcrBackupProc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData);static u32 LogicGetBatteryColDataBackupProc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData);static u32 LogicGetBatterVoltageBackupProc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData);static u32 LogicGetBatterInchargeTimerProc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData);static u32 LogicGetWLVersionProc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData);static u32 LogicGetBatteryVoltage1Proc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData);static u32 LogicGetBatteryVoltage2Proc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData);#if (QUICK_KEY_CTRL_ENABLE_FLAG	!= DISABLED)	#if (QUICK_KEY_1_ENABLE_FLAG != DISABLED)		static u32 LogicGetQuick1EnableFalg(LOGIC_PARAM_MSG_TYPE sMsg,void *pData);		static u32 LogicGetQuick1ActionNumb(LOGIC_PARAM_MSG_TYPE sMsg,void *pData);		static u32 LogicGetQuick1AlaramTime(LOGIC_PARAM_MSG_TYPE sMsg,void *pData);		static u32 LogicGetQuick1ActionName(LOGIC_PARAM_MSG_TYPE sMsg,void *pData);		static u32 LogicGetQuick1ActionTime(LOGIC_PARAM_MSG_TYPE sMsg,void *pData);		static u32 LogicGetQuick1ActionInterval(LOGIC_PARAM_MSG_TYPE sMsg,void *pData);	#endif	#if (QUICK_KEY_2_ENABLE_FLAG != DISABLED)		static u32 LogicGetQuick2EnableFalg(LOGIC_PARAM_MSG_TYPE sMsg,void *pData);		static u32 LogicGetQuick2ActionNumb(LOGIC_PARAM_MSG_TYPE sMsg,void *pData);		static u32 LogicGetQuick2AlaramTime(LOGIC_PARAM_MSG_TYPE sMsg,void *pData);		static u32 LogicGetQuick2ActionName(LOGIC_PARAM_MSG_TYPE sMsg,void *pData);		static u32 LogicGetQuick2ActionTime(LOGIC_PARAM_MSG_TYPE sMsg,void *pData);		static u32 LogicGetQuick2ActionInterval(LOGIC_PARAM_MSG_TYPE sMsg,void *pData);	#endif#endif#if (QUICK_KEY_CTRL_ENABLE_FLAG	!= DISABLED)	static u32 LogicGetQuickActionInvaild(LOGIC_PARAM_MSG_TYPE sMsg,void *pData);#endifstatic u32 LogicGetYkqAppStationProc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData);static u32 LogicResumeDefaultParamProc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData); #if IR_SEND > 0static u32 LogicIRSendParamProc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData);static u32 LogicGETIRSendParamProc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData);#endif#if (SET_YKQ_PRGPT_USE_FLAG != 0)	static u32 LogicGetColibrateYkqIdProc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData);		static u32 LogicGetColibrateYkqTypeProc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData);		static u32 LogicGetColibrateYkqStationProc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData);	static u32 LogicGetColibrateYkqVersionProc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData);	#endif	static u32 LogicGetFastColiearateEnableProc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData);#if (ZIBAO_CTRL_ENABLE_FLAG != DISABLED)	static u32 LogicGetZibaoEnabledFlagProc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData);		static u32 LogicGetZibaoActionMaxProc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData);		#if (ZIBAO_CTRL_METHOD_TYPE	== ZIBAO_PARAM_CTRL_METHOD)//自保动作使能设置		static u32 LogicGetZibaoTimeOutProc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData);			static u32 LogicGetZibaoActionEnableFlagProc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData);			static u32 LogicGetZibaoActionIngTimeProc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData);		#endif		#endif//static u32 LogicGetKeyFilmName(LOGIC_PARAM_MSG_TYPE sMsg,void *pData);		//选择键盘膜	2020.01.15 parry//static u32 LogicSetKeyFilmName(LOGIC_PARAM_MSG_TYPE sMsg,void *pData);		//static u32 LogicGetKeySetActionName(LOGIC_PARAM_MSG_TYPE sMsg,void *pData);		//设定按键动作	2020.01.15 parry	//static u32 LogicSetKeySetActionName(LOGIC_PARAM_MSG_TYPE sMsg,void *pData);static u32 LogicSetCtrlModeProc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData);static u32 LogicGetCtrlModeProc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData);//无线测试static u32 LogicWlTestParamProc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData);static u32 LogicGetWlTestParamProc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData);//LOGIC API 接口函数指针数组u32 (*LogicParamApiProcFuncs[LOGIC_PARAM_MSG_MAX])(LOGIC_PARAM_MSG_TYPE sMsg,void *pData) ={	/**参数读写相关的接口函数**/	LogicSetPrgSecProc,	LogicSetYkqNumbProc,	LogicSetRfidSelfNumbProc,	LogicSetIrSendTimeoutProc,	LogicSetIrSendTimesProc,	LogicSetRfidSendTimeoutProc,	LogicSetRfidSendTimesProc,	LogicSetOledScrLightProc,	LogicSetOledProtectBrightnessProc,	LogicSetOledProtectedTimerProc,	LogicSetOledShutdownTimerProc,		LogicSetColibarateTimeoutProc,	LogicSetInterCtrlTimerProc,	LogicSetNoteShowTimerProc,	LogicSetScCtrlDislayTimerProc,	LogicSetYkqIdBackupProc,	LogicSetShutDownFlagProc,	LogicSetBatteryAcrBackupProc,	LogicSetBatteryColDataBackupProc,	LogicSetBatterVoltageBackupProc,	LogicSetBatterInchargeTimerProc,		#if (QUICK_KEY_CTRL_ENABLE_FLAG	!= DISABLED)		#if (QUICK_KEY_1_ENABLE_FLAG != DISABLED)			/**快捷键1参数**/			LogicSetQuick1EnableFalg,			LogicSetQuick1ActionNumb,			LogicSetQuick1AlaramTime,						LogicSetQuick1ActionName,			LogicSetQuick1ActionName,			LogicSetQuick1ActionName,			LogicSetQuick1ActionName,			LogicSetQuick1ActionName,			LogicSetQuick1ActionName,			LogicSetQuick1ActionName,			LogicSetQuick1ActionName,			LogicSetQuick1ActionName,			LogicSetQuick1ActionName,						LogicSetQuick1ActionTime,			LogicSetQuick1ActionTime,			LogicSetQuick1ActionTime,			LogicSetQuick1ActionTime,			LogicSetQuick1ActionTime,			LogicSetQuick1ActionTime,			LogicSetQuick1ActionTime,			LogicSetQuick1ActionTime,			LogicSetQuick1ActionTime,			LogicSetQuick1ActionTime,						LogicSetQuick1ActionInterval,			LogicSetQuick1ActionInterval,			LogicSetQuick1ActionInterval,			LogicSetQuick1ActionInterval,			LogicSetQuick1ActionInterval,			LogicSetQuick1ActionInterval,			LogicSetQuick1ActionInterval,			LogicSetQuick1ActionInterval,			LogicSetQuick1ActionInterval,			LogicSetQuick1ActionInterval,			#endif		#if (QUICK_KEY_2_ENABLE_FLAG != DISABLED)				/**快捷键2参数**/				LogicSetQuick2EnableFalg,			LogicSetQuick2ActionNumb,			LogicSetQuick2AlaramTime,						LogicSetQuick2ActionName,			LogicSetQuick2ActionName,			LogicSetQuick2ActionName,			LogicSetQuick2ActionName,			LogicSetQuick2ActionName,			LogicSetQuick2ActionName,			LogicSetQuick2ActionName,			LogicSetQuick2ActionName,			LogicSetQuick2ActionName,			LogicSetQuick2ActionName,						LogicSetQuick2ActionTime,			LogicSetQuick2ActionTime,			LogicSetQuick2ActionTime,			LogicSetQuick2ActionTime,			LogicSetQuick2ActionTime,			LogicSetQuick2ActionTime,			LogicSetQuick2ActionTime,			LogicSetQuick2ActionTime,			LogicSetQuick2ActionTime,			LogicSetQuick2ActionTime,						LogicSetQuick2ActionInterval,			LogicSetQuick2ActionInterval,			LogicSetQuick2ActionInterval,			LogicSetQuick2ActionInterval,			LogicSetQuick2ActionInterval,			LogicSetQuick2ActionInterval,			LogicSetQuick2ActionInterval,			LogicSetQuick2ActionInterval,			LogicSetQuick2ActionInterval,			LogicSetQuick2ActionInterval,			#endif	#endif		#if (SET_YKQ_PRGPT_USE_FLAG != 0)		LogicSetColibrateYkqIdProc,			LogicSetColibrateYkqTypeProc,			LogicSetColibrateYkqStationProc,		LogicSetColibrateYkqVersionProc,			#endif		#if (ZIBAO_CTRL_ENABLE_FLAG != DISABLED)		LogicSetZibaoEnabledFlagProc,			LogicSetZibaoActionMaxProc,			#if (ZIBAO_CTRL_METHOD_TYPE	== ZIBAO_PARAM_CTRL_METHOD)//自保动作使能设置			LogicSetZibaoTimeOutProc,//自保超时时间设置			LogicSetZibaoActionEnableFlagProc,			LogicSetZibaoActionEnableFlagProc,			LogicSetZibaoActionEnableFlagProc,			LogicSetZibaoActionEnableFlagProc,			LogicSetZibaoActionEnableFlagProc,			LogicSetZibaoActionEnableFlagProc,			LogicSetZibaoActionEnableFlagProc,			LogicSetZibaoActionEnableFlagProc,			LogicSetZibaoActionEnableFlagProc,			LogicSetZibaoActionEnableFlagProc,			LogicSetZibaoActionEnableFlagProc,			LogicSetZibaoActionEnableFlagProc,			LogicSetZibaoActionEnableFlagProc,			LogicSetZibaoActionEnableFlagProc,			LogicSetZibaoActionEnableFlagProc,			LogicSetZibaoActionEnableFlagProc,			LogicSetZibaoActionEnableFlagProc,			LogicSetZibaoActionEnableFlagProc,			LogicSetZibaoActionEnableFlagProc,			LogicSetZibaoActionEnableFlagProc,						LogicSetZibaoActionEnableFlagProc,			LogicSetZibaoActionEnableFlagProc,			LogicSetZibaoActionEnableFlagProc,			LogicSetZibaoActionEnableFlagProc,			LogicSetZibaoActionEnableFlagProc,			LogicSetZibaoActionEnableFlagProc,			LogicSetZibaoActionEnableFlagProc,			LogicSetZibaoActionEnableFlagProc,						LogicSetZibaoActionEnableFlagProc,			LogicSetZibaoActionEnableFlagProc,		#endif		#if (ZIBAO_CTRL_METHOD_TYPE	== ZIBAO_PARAM_CTRL_METHOD)//自保动作时间设置			LogicSetZibaoActionIngTimeProc,			LogicSetZibaoActionIngTimeProc,			LogicSetZibaoActionIngTimeProc,			LogicSetZibaoActionIngTimeProc,			LogicSetZibaoActionIngTimeProc,			LogicSetZibaoActionIngTimeProc,			LogicSetZibaoActionIngTimeProc,			LogicSetZibaoActionIngTimeProc,			LogicSetZibaoActionIngTimeProc,			LogicSetZibaoActionIngTimeProc,			LogicSetZibaoActionIngTimeProc,			LogicSetZibaoActionIngTimeProc,			LogicSetZibaoActionIngTimeProc,			LogicSetZibaoActionIngTimeProc,			LogicSetZibaoActionIngTimeProc,			LogicSetZibaoActionIngTimeProc,			LogicSetZibaoActionIngTimeProc,			LogicSetZibaoActionIngTimeProc,			LogicSetZibaoActionIngTimeProc,			LogicSetZibaoActionIngTimeProc,			LogicSetZibaoActionIngTimeProc,			LogicSetZibaoActionIngTimeProc,			LogicSetZibaoActionIngTimeProc,			LogicSetZibaoActionIngTimeProc,			LogicSetZibaoActionIngTimeProc,			LogicSetZibaoActionIngTimeProc,			LogicSetZibaoActionIngTimeProc,			LogicSetZibaoActionIngTimeProc,			LogicSetZibaoActionIngTimeProc,			LogicSetZibaoActionIngTimeProc,		#endif	#endif	#if (ONLINE_UPDATE_SELF_PRG_PT_FLAG	!= DISABLED)		LogicUpdateYkqPrgProc,		LogicUpdateCxbPrgProc,		LogicUpdateWLPrgProc,		LogicUpdateCxbWLPrgProc,	#endif			/*********************获取参数***********************/	LogicGetPrgSecProc, 	LogicGetYkqNumbProc,	LogicGetRfidSelfNumbProc,	LogicGetIrSendTimeoutProc,	LogicGetIrSendTimesProc,	LogicGetRfidSendTimeoutProc,	LogicGetRfidSendTimesProc,	LogicGetOledScrLightProc,	LogicGetOledProtectBrightnessProc,	LogicGetOledProtectedTimerProc,	LogicGetOledShutdownTimerProc,		LogicgGetColibarateTimeoutProc,	LogicGetInterCtrlTimerProc,	LogicGetNoteShowTimerProc,	LogicGetScCtrlDislayTimerProc,	LogicGetYkqIdBackupProc,	LogicGetShutDownFlagProc,	LogicGetBatteryAcrBackupProc,	LogicGetBatteryColDataBackupProc,	LogicGetBatterVoltageBackupProc,	LogicGetBatterInchargeTimerProc,			#if (QUICK_KEY_CTRL_ENABLE_FLAG	!= DISABLED)		#if (QUICK_KEY_1_ENABLE_FLAG != DISABLED)			/**快捷键1参数**/			LogicGetQuick1EnableFalg,			LogicGetQuick1ActionNumb,			LogicGetQuick1AlaramTime,						LogicGetQuick1ActionName,			LogicGetQuick1ActionName,			LogicGetQuick1ActionName,			LogicGetQuick1ActionName,			LogicGetQuick1ActionName,			LogicGetQuick1ActionName,			LogicGetQuick1ActionName,			LogicGetQuick1ActionName,			LogicGetQuick1ActionName,			LogicGetQuick1ActionName,						LogicGetQuick1ActionTime,			LogicGetQuick1ActionTime,			LogicGetQuick1ActionTime,			LogicGetQuick1ActionTime,			LogicGetQuick1ActionTime,			LogicGetQuick1ActionTime,			LogicGetQuick1ActionTime,			LogicGetQuick1ActionTime,			LogicGetQuick1ActionTime,			LogicGetQuick1ActionTime,						LogicGetQuick1ActionInterval,			LogicGetQuick1ActionInterval,			LogicGetQuick1ActionInterval,			LogicGetQuick1ActionInterval,			LogicGetQuick1ActionInterval,			LogicGetQuick1ActionInterval,			LogicGetQuick1ActionInterval,			LogicGetQuick1ActionInterval,			LogicGetQuick1ActionInterval,			LogicGetQuick1ActionInterval,			#endif		#if (QUICK_KEY_2_ENABLE_FLAG != DISABLED)				/**快捷键2参数**/				LogicGetQuick2EnableFalg,			LogicGetQuick2ActionNumb,			LogicGetQuick2AlaramTime,						LogicGetQuick2ActionName,			LogicGetQuick2ActionName,			LogicGetQuick2ActionName,			LogicGetQuick2ActionName,			LogicGetQuick2ActionName,			LogicGetQuick2ActionName,			LogicGetQuick2ActionName,			LogicGetQuick2ActionName,			LogicGetQuick2ActionName,			LogicGetQuick2ActionName,						LogicGetQuick2ActionTime,			LogicGetQuick2ActionTime,			LogicGetQuick2ActionTime,			LogicGetQuick2ActionTime,			LogicGetQuick2ActionTime,			LogicGetQuick2ActionTime,			LogicGetQuick2ActionTime,			LogicGetQuick2ActionTime,			LogicGetQuick2ActionTime,			LogicGetQuick2ActionTime,						LogicGetQuick2ActionInterval,			LogicGetQuick2ActionInterval,			LogicGetQuick2ActionInterval,			LogicGetQuick2ActionInterval,			LogicGetQuick2ActionInterval,			LogicGetQuick2ActionInterval,			LogicGetQuick2ActionInterval,			LogicGetQuick2ActionInterval,			LogicGetQuick2ActionInterval,			LogicGetQuick2ActionInterval,			#endif	#endif		#if (QUICK_KEY_CTRL_ENABLE_FLAG	!= DISABLED)		#if (QUICK_KEY_1_ENABLE_FLAG != DISABLED)			LogicGetQuickActionInvaild,		#endif				#if (QUICK_KEY_2_ENABLE_FLAG != DISABLED)			LogicGetQuickActionInvaild,		#endif	#endif		LogicGetYkqAppStationProc,	LogicResumeDefaultParamProc,	#if IR_SEND > 0	LogicIRSendParamProc,	LogicGETIRSendParamProc,	#endif		#if (SET_YKQ_PRGPT_USE_FLAG != 0)		LogicGetColibrateYkqIdProc,			LogicGetColibrateYkqTypeProc,			LogicGetColibrateYkqStationProc,		LogicGetColibrateYkqVersionProc,	#endif		#if (ZIBAO_CTRL_ENABLE_FLAG != DISABLED)		LogicGetZibaoEnabledFlagProc,			LogicGetZibaoActionMaxProc,			#if (ZIBAO_CTRL_METHOD_TYPE	== ZIBAO_PARAM_CTRL_METHOD)//自保动作使能回读			LogicGetZibaoTimeOutProc,//自保超时时间设置						LogicGetZibaoActionEnableFlagProc,			LogicGetZibaoActionEnableFlagProc,			LogicGetZibaoActionEnableFlagProc,			LogicGetZibaoActionEnableFlagProc,			LogicGetZibaoActionEnableFlagProc,			LogicGetZibaoActionEnableFlagProc,			LogicGetZibaoActionEnableFlagProc,			LogicGetZibaoActionEnableFlagProc,			LogicGetZibaoActionEnableFlagProc,			LogicGetZibaoActionEnableFlagProc,			LogicGetZibaoActionEnableFlagProc,			LogicGetZibaoActionEnableFlagProc,			LogicGetZibaoActionEnableFlagProc,			LogicGetZibaoActionEnableFlagProc,			LogicGetZibaoActionEnableFlagProc,			LogicGetZibaoActionEnableFlagProc,			LogicGetZibaoActionEnableFlagProc,			LogicGetZibaoActionEnableFlagProc,			LogicGetZibaoActionEnableFlagProc,			LogicGetZibaoActionEnableFlagProc,			LogicGetZibaoActionEnableFlagProc,			LogicGetZibaoActionEnableFlagProc,			LogicGetZibaoActionEnableFlagProc,			LogicGetZibaoActionEnableFlagProc,			LogicGetZibaoActionEnableFlagProc,			LogicGetZibaoActionEnableFlagProc,			LogicGetZibaoActionEnableFlagProc,			LogicGetZibaoActionEnableFlagProc,			LogicGetZibaoActionEnableFlagProc,			LogicGetZibaoActionEnableFlagProc,		#endif				#if (ZIBAO_CTRL_METHOD_TYPE	== ZIBAO_PARAM_CTRL_METHOD)//自保动作时间回读			LogicGetZibaoActionIngTimeProc,			LogicGetZibaoActionIngTimeProc,			LogicGetZibaoActionIngTimeProc,			LogicGetZibaoActionIngTimeProc,						LogicGetZibaoActionIngTimeProc,			LogicGetZibaoActionIngTimeProc,			LogicGetZibaoActionIngTimeProc,			LogicGetZibaoActionIngTimeProc,			LogicGetZibaoActionIngTimeProc,			LogicGetZibaoActionIngTimeProc,			LogicGetZibaoActionIngTimeProc,			LogicGetZibaoActionIngTimeProc,						LogicGetZibaoActionIngTimeProc,			LogicGetZibaoActionIngTimeProc,			LogicGetZibaoActionIngTimeProc,			LogicGetZibaoActionIngTimeProc,			LogicGetZibaoActionIngTimeProc,			LogicGetZibaoActionIngTimeProc,			LogicGetZibaoActionIngTimeProc,			LogicGetZibaoActionIngTimeProc,						LogicGetZibaoActionIngTimeProc,			LogicGetZibaoActionIngTimeProc,			LogicGetZibaoActionIngTimeProc,			LogicGetZibaoActionIngTimeProc,			LogicGetZibaoActionIngTimeProc,			LogicGetZibaoActionIngTimeProc,			LogicGetZibaoActionIngTimeProc,			LogicGetZibaoActionIngTimeProc,						LogicGetZibaoActionIngTimeProc,			LogicGetZibaoActionIngTimeProc,		#endif			#endif	//	LogicGetKeyFilmName,		//选择键盘膜	2020.01.15 parry//	LogicSetKeyFilmName,		LogicGetFastColiearateEnableProc,	LogicSetFastColiearateEnableProc,	//	LogicGetKeySetActionName,		//设定按键动作	2020.01.15 parry//	LogicGetKeySetActionName,//	LogicGetKeySetActionName,//	LogicGetKeySetActionName,//	LogicGetKeySetActionName,//	LogicGetKeySetActionName,//	//	LogicGetKeySetActionName,//	LogicGetKeySetActionName,//	LogicGetKeySetActionName,//	LogicGetKeySetActionName,//	LogicGetKeySetActionName,//	LogicGetKeySetActionName,//	//	LogicGetKeySetActionName,//	LogicGetKeySetActionName,//	LogicGetKeySetActionName,//	LogicGetKeySetActionName,//	LogicGetKeySetActionName,//	LogicGetKeySetActionName,//	//	LogicGetKeySetActionName,//	LogicGetKeySetActionName,//	LogicGetKeySetActionName,//	LogicGetKeySetActionName,//	LogicGetKeySetActionName,//	LogicGetKeySetActionName,//	LogicSetKeySetActionName,		//设定按键动作	2020.01.15 parry//	LogicSetKeySetActionName,//	LogicSetKeySetActionName,//	LogicSetKeySetActionName,//	LogicSetKeySetActionName,//	LogicSetKeySetActionName,//	LogicSetKeySetActionName,//	LogicSetKeySetActionName,//	LogicSetKeySetActionName,//	LogicSetKeySetActionName,//	LogicSetKeySetActionName,//	LogicSetKeySetActionName,//	LogicSetKeySetActionName,//	LogicSetKeySetActionName,//	LogicSetKeySetActionName,//	LogicSetKeySetActionName,//	LogicSetKeySetActionName,//	LogicSetKeySetActionName,//	LogicSetKeySetActionName,//	LogicSetKeySetActionName,//	LogicSetKeySetActionName,//	LogicSetKeySetActionName,//	LogicSetKeySetActionName,//	LogicSetKeySetActionName,//	//	LogicGetKeySetActionName,//	LogicGetKeySetActionName,//	LogicGetKeySetActionName,//	LogicGetKeySetActionName,//	//	//	LogicSetKeySetActionName,//	LogicSetKeySetActionName,//	LogicSetKeySetActionName,//	LogicSetKeySetActionName,	LogicSetWLVersionProc,	LogicGetWLVersionProc,	LogicGetBatteryVoltage1Proc,	LogicGetBatteryVoltage2Proc,	LogicSetCtrlModeProc,	LogicGetCtrlModeProc,    LogicGetWlTestParamProc,    LogicWlTestParamProc,};/**运行信息相关的接口函数声明**//**设置***/static u32 LogicSetColibrateScTypeProc(void *pData);static u32 LogicSetScNumbDirectProc(void *pData);static u32 LogicSetColibrateScNumbProc(void *pData);static u32 LogicSetCtrlScNumbProc(void *pData);static u32 LogicSetRfidFrameTypeProc(void *pData);static u32 LogicSetScActionNameProc(void *pData);static u32 LogicSetGrpDirectionProc(void *pData);static u32 LogicSetGrpAckActionNameProc(void *pData);static u32 LogicSetGrpNearScNumbProc(void *pData);static u32 LogicSetGrpRemoteScNumbProc(void *pData);static u32 LogicSetRunStatusProc(void * pData);static u32 LogicSetButtonDownProc(void *pData);static u32 LogicSetButtonDownAckProc(void * pData);static u32 LogicSetButtonStatusProc(void * pData);static u32 LogicSetButtonLongDownProc(void * pData);static u32 LogicSetButtonUpProc(void * pData);static u32 LogicSetScActionTypeProc(void * pData);static u32 LogicSetScGejiaNumberProc(void * pData);static u32 LogicSetActionInfoCrc(void *pData);		//zzw#if (QUICK_KEY_CTRL_ENABLE_FLAG != 0)		static u32 LogicSetScQuickTypeProc(void *pData);	#endifstatic u32 LogicSetBatteryStatusProc(void *pData);static u32 LogicSetBatteryCoulomStatusProc(void *pData);static u32 LogicSetBatteryCoulomDataProc(void *pData);static u32 LogicSetRfidSignStatusProc(void *pData);#if (KEY_AUTO_PRESS_PROC_FLAG != DISABLED)	static u32 LogicSetAutoPressEnableFlagPorc(void *pData);#endif	/**获取***/static u32 LogicGetColibrateScTypeProc(void *pData);static u32 LogicGetScNumbDirectProc(void *pData);static u32 LogicGetColibrateScNumbProc(void *pData);static u32 LogicGetCtrlScNumbProc(void *pData);static u32 LogicGetRfidFrameTypeProc(void *pData);static u32 LogicGetScActionNameProc(void *pData);static u32 LogicGetGrpDirectionProc(void *pData);static u32 LogicGetGrpAckActionNameProc(void *pData);static u32 LogicGetGrpNearScNumbProc(void *pData);static u32 LogicGetGrpRemoteScNumbProc(void *pData);static u32 LogicGetRunStatusProc(void *pData);static u32 LogicGetButtonDownProc(void *pData);static u32 LogicGetButtonDownAckProc(void * pData);static u32 LogicGetButtonStatusProc(void * pData);static u32 LogicGetButtonLongDownProc(void * pData);static u32 LogicGetButtonUpProc(void * pData);static u32 LogicGetScActionTypeProc(void * pData);static u32 LogicGetScGejiaNumberProc(void * pData);#if (QUICK_KEY_CTRL_ENABLE_FLAG != 0)		static u32 LogicGetScQuickTypeProc(void *pData);#endifstatic u32 LogicGetBatteryStatusProc(void *pData);static u32 LogicGetBatteryCoulomStatusProc(void *pData);static u32 LogicGetBatteryCoulomDataProc(void *pData);static u32 LogicGetRfidSignStatusProc(void *pData);static u32 LogicSetColibrateSuccessScNumbProc(void *pData);static u32 LogicGetColibrateSuccessScNumbProc(void *pData);static u32 LogicGetActionInfoCrc(void *pData);	//zzwstatic u32 LogicActionInfoSynchroReq(void *pData);	//zzwstatic u32 LogicStatusActionInfoReqProc(void);		//zzwstatic u32 LogicSetHeartProc(void * pData);static u32 LogicSetNearCtrlReq(void * pData);		//邻架控制请求static u32 LogicWlTestSendProc(void* pData);       //发送无线测试//LOGIC API 接口函数指针数组u32 (*LogicRunInfApiProcFuncs[LOGIC_RUN_MSG_MAX])(void *pData) ={	/**运行信息相关的函数**/	LogicSetColibrateScTypeProc,	LogicSetScNumbDirectProc,	LogicSetColibrateScNumbProc,	LogicSetCtrlScNumbProc,	LogicSetRfidFrameTypeProc,	LogicSetScActionNameProc,	LogicSetGrpDirectionProc,	LogicSetGrpAckActionNameProc,	LogicSetGrpNearScNumbProc,	LogicSetGrpRemoteScNumbProc,		LogicSetRunStatusProc,	LogicSetButtonDownProc,	LogicSetButtonDownAckProc,	LogicSetButtonStatusProc,	LogicSetButtonLongDownProc,	LogicSetButtonUpProc,	LogicSetScActionTypeProc,	LogicSetScGejiaNumberProc,	#if (QUICK_KEY_CTRL_ENABLE_FLAG != 0)		LogicSetScQuickTypeProc,	#endif		LogicSetBatteryStatusProc,	LogicSetBatteryCoulomStatusProc,	LogicSetBatteryCoulomDataProc,	LogicSetRfidSignStatusProc,		#if (KEY_AUTO_PRESS_PROC_FLAG != DISABLED)		LogicSetAutoPressEnableFlagPorc,	#endif	/**获取**/	LogicGetColibrateScTypeProc,	LogicGetScNumbDirectProc,	LogicGetColibrateScNumbProc,	LogicGetCtrlScNumbProc,	LogicGetRfidFrameTypeProc,		LogicGetScActionNameProc,	LogicGetGrpDirectionProc,	LogicGetGrpAckActionNameProc,	LogicGetGrpNearScNumbProc,	LogicGetGrpRemoteScNumbProc,		LogicGetRunStatusProc,	LogicGetButtonDownProc,	LogicGetButtonDownAckProc,	LogicGetButtonStatusProc,	LogicGetButtonLongDownProc,	LogicGetButtonUpProc,	LogicGetScActionTypeProc,	LogicGetScGejiaNumberProc,		#if (QUICK_KEY_CTRL_ENABLE_FLAG != 0)		LogicGetScQuickTypeProc,	#endif		LogicGetBatteryStatusProc,	LogicGetBatteryCoulomStatusProc,	LogicGetBatteryCoulomDataProc,	LogicGetRfidSignStatusProc,		LogicSetColibrateSuccessScNumbProc,	LogicGetColibrateSuccessScNumbProc,	LogicSetActionInfoCrc,	LogicGetActionInfoCrc,	LogicActionInfoSynchroReq,	LogicSetHeartProc,	LogicSetNearCtrlReq,    LogicWlTestSendProc,        //无线测试发送};/****状态处理函数声明***/static u32 LogicStatusIdleProc(void);static u32 LogicStatusIrColibStartProc(void);static u32 LogicStatusIrColibSuccessdProc(void);static u32 LogicStatusIrColibFailProc(void);static u32 LogicStatusRfidColibStartProc(void);static u32 LogicStatusRfidColibSuccessdProc(void);static u32 LogicStatusRfidColibFailProc(void);static u32 LogicStatusScSelfCtrlProc(void);#if (ZIBAO_CTRL_ENABLE_FLAG	!= DISABLED)	static u32 LogicStatusScZibaoCtrlProc(void);#endif	#if (QUICK_KEY_CTRL_ENABLE_FLAG != 0)	static u32 LogicStatusScQuickCtrlProc(void);#endif#if (SET_YKQ_PRGPT_USE_FLAG != 0)	static u32 LogicStatusIrSearchYkqStartCtrlProc(void);	static u32 LogicStatusIrSearchYkqIngCtrlProc(void);#endifstatic u32 LogicStatusRfidUnColibrateProc(void);static u32 LogicStatusShutupProc(void);static u32 LogicStatusInintProc(void);#if (ONLINE_UPDATE_SELF_PRG_PT_FLAG	!= DISABLED)	static u32 LogicStatusRfidTransPrg0Proc(void);	static u32 LogicStatusRfidTransPrgProc(void);	static u32 LogicStatusRfidRecvPrgProc(void);	static u32 LogicStatusRfidTransWLPrgProc(void);	static u32 LogicStatusUsartTransWLPrgProc(void);	static u32 LogicStatusRfidCXBRecvPrgProc(void);	static u32 LogicStatusRfidCXBRecvWLPrgProc(void);	static u32 LogicStatusRfidRecvWLPrgProc(void);	static u32 LogicStatusUnconnectWLProc(void);	#endif/****LOGIC 状态函数指针数组****/u32 (*LogicStatusProcFuncs[LOGIC_STATUS_MAX])(void) ={	LogicStatusIdleProc,			LogicStatusIrColibStartProc,		NULL,	LogicStatusIrColibSuccessdProc,	LogicStatusIrColibFailProc,	LogicStatusRfidColibStartProc,	NULL,	LogicStatusRfidColibSuccessdProc,	LogicStatusRfidColibFailProc,	NULL,	LogicStatusScSelfCtrlProc,	NULL,	NULL,	#if (ZIBAO_CTRL_ENABLE_FLAG	!= DISABLED)		LogicStatusScZibaoCtrlProc,	#endif	#if (QUICK_KEY_CTRL_ENABLE_FLAG != 0)		LogicStatusScQuickCtrlProc,	#endif	#if (SET_YKQ_PRGPT_USE_FLAG != 0)		LogicStatusIrSearchYkqStartCtrlProc,		LogicStatusIrSearchYkqIngCtrlProc,	#endif		LogicStatusRfidUnColibrateProc,	LogicStatusShutupProc,		LogicStatusInintProc,	#if (ONLINE_UPDATE_SELF_PRG_PT_FLAG	!= DISABLED)		LogicStatusRfidTransPrg0Proc,         //传输主控程序前的校验		LogicStatusRfidTransPrgProc,          //传输主控程序		LogicStatusRfidRecvPrgProc,           //接收主控程序		LogicStatusRfidTransWLPrgProc,        //传输无线程序（全面）		LogicStatusUsartTransWLPrgProc,       //传输无线程序（本地）		LogicStatusRfidCXBRecvPrgProc,        //程序棒接收程序		LogicStatusRfidCXBRecvWLPrgProc,      //程序棒接收无线程序		LogicStatusRfidRecvWLPrgProc,         //接收无线程序		#endif//	LogicStatusUnconnectWLProc,             //无线断开逻辑处理};/*********************************************************************************************函数名称：crc16_ccitt**函数作用：计算数组的CRC校验**函数参数：无**注意事项：无*******************************************************************************************//* CRC16 implementation acording to CCITT standards */static const u16 crc16tab[256]= {0x0000,0x1021,0x2042,0x3063,0x4084,0x50a5,0x60c6,0x70e7,0x8108,0x9129,0xa14a,0xb16b,0xc18c,0xd1ad,0xe1ce,0xf1ef,0x1231,0x0210,0x3273,0x2252,0x52b5,0x4294,0x72f7,0x62d6,0x9339,0x8318,0xb37b,0xa35a,0xd3bd,0xc39c,0xf3ff,0xe3de,0x2462,0x3443,0x0420,0x1401,0x64e6,0x74c7,0x44a4,0x5485,0xa56a,0xb54b,0x8528,0x9509,0xe5ee,0xf5cf,0xc5ac,0xd58d,0x3653,0x2672,0x1611,0x0630,0x76d7,0x66f6,0x5695,0x46b4,0xb75b,0xa77a,0x9719,0x8738,0xf7df,0xe7fe,0xd79d,0xc7bc,0x48c4,0x58e5,0x6886,0x78a7,0x0840,0x1861,0x2802,0x3823,0xc9cc,0xd9ed,0xe98e,0xf9af,0x8948,0x9969,0xa90a,0xb92b,0x5af5,0x4ad4,0x7ab7,0x6a96,0x1a71,0x0a50,0x3a33,0x2a12,0xdbfd,0xcbdc,0xfbbf,0xeb9e,0x9b79,0x8b58,0xbb3b,0xab1a,0x6ca6,0x7c87,0x4ce4,0x5cc5,0x2c22,0x3c03,0x0c60,0x1c41,0xedae,0xfd8f,0xcdec,0xddcd,0xad2a,0xbd0b,0x8d68,0x9d49,0x7e97,0x6eb6,0x5ed5,0x4ef4,0x3e13,0x2e32,0x1e51,0x0e70,0xff9f,0xefbe,0xdfdd,0xcffc,0xbf1b,0xaf3a,0x9f59,0x8f78,0x9188,0x81a9,0xb1ca,0xa1eb,0xd10c,0xc12d,0xf14e,0xe16f,0x1080,0x00a1,0x30c2,0x20e3,0x5004,0x4025,0x7046,0x6067,0x83b9,0x9398,0xa3fb,0xb3da,0xc33d,0xd31c,0xe37f,0xf35e,0x02b1,0x1290,0x22f3,0x32d2,0x4235,0x5214,0x6277,0x7256,0xb5ea,0xa5cb,0x95a8,0x8589,0xf56e,0xe54f,0xd52c,0xc50d,0x34e2,0x24c3,0x14a0,0x0481,0x7466,0x6447,0x5424,0x4405,0xa7db,0xb7fa,0x8799,0x97b8,0xe75f,0xf77e,0xc71d,0xd73c,0x26d3,0x36f2,0x0691,0x16b0,0x6657,0x7676,0x4615,0x5634,0xd94c,0xc96d,0xf90e,0xe92f,0x99c8,0x89e9,0xb98a,0xa9ab,0x5844,0x4865,0x7806,0x6827,0x18c0,0x08e1,0x3882,0x28a3,0xcb7d,0xdb5c,0xeb3f,0xfb1e,0x8bf9,0x9bd8,0xabbb,0xbb9a,0x4a75,0x5a54,0x6a37,0x7a16,0x0af1,0x1ad0,0x2ab3,0x3a92,0xfd2e,0xed0f,0xdd6c,0xcd4d,0xbdaa,0xad8b,0x9de8,0x8dc9,0x7c26,0x6c07,0x5c64,0x4c45,0x3ca2,0x2c83,0x1ce0,0x0cc1,0xef1f,0xff3e,0xcf5d,0xdf7c,0xaf9b,0xbfba,0x8fd9,0x9ff8,0x6e17,0x7e36,0x4e55,0x5e74,0x2e93,0x3eb2,0x0ed1,0x1ef0};void crc16_ccitt(const u8 *buf, u32 len ,u16 *check_old){	u32 counter;	u16 crc = *check_old;	for( counter = 0; counter < len; counter++)		crc = (crc<<8) ^ crc16tab[((crc>>8) ^ *(u8 *)buf++)&0x00FF];	*check_old = crc;}/*********************************************************************************************函数名称：LogicSetGrpOffLed**函数作用：逻辑层遥控器成组模式下不点亮的键的灯值**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/void LogicSetGrpOffLed(u16 u16KeyFilm)		//解决成组时有效键无效键同时按下闪烁异常的问题	2020.04.27 parry{	switch(u16KeyFilm)	{		case 0x00:	//综放膜非成组动作键			KEY_SC_GRP_OFF_LED = KEY_LED_2|KEY_LED_3|KEY_LED_4|KEY_LED_12;			KEY_SC_GRP_SHIFT_OFF_LED = KEY_LED_3|KEY_LED_4|KEY_LED_5|KEY_LED_6|KEY_LED_7|KEY_LED_8|KEY_LED_9|KEY_LED_10|KEY_LED_11;			break;		case 0x01:	//综采膜非成组动作键			KEY_SC_GRP_OFF_LED = KEY_LED_2|KEY_LED_5|KEY_LED_6|KEY_LED_11;			KEY_SC_GRP_SHIFT_OFF_LED = KEY_LED_5|KEY_LED_6|KEY_LED_7|KEY_LED_8|KEY_LED_9|KEY_LED_10|KEY_LED_11|KEY_LED_12;			break;		default:	//自定义键盘膜			KEY_SC_GRP_OFF_LED = KEY_LED_1|KEY_LED_2|KEY_LED_3|KEY_LED_4|KEY_LED_5|KEY_LED_6|KEY_LED_7|KEY_LED_8|KEY_LED_9|KEY_LED_10|KEY_LED_11|KEY_LED_12;			KEY_SC_GRP_SHIFT_OFF_LED = KEY_LED_1|KEY_LED_2|KEY_LED_3|KEY_LED_4|KEY_LED_5|KEY_LED_6|KEY_LED_7|KEY_LED_8|KEY_LED_9|KEY_LED_10|KEY_LED_11|KEY_LED_12;			break;	}}/*********************************************************************************************函数名称：LogicParamSaveProc**函数作用：逻辑层参数保存处理**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/void LogicParamSaveProc(void){	u16 u16Temp = 0x00;	u32 *p = (u32 *)&(s_stLogicParamSystem.u32YKQPrgSec);	//	if(g_u32ID == B_type)//		crc16_ccitt((u8 *)&s_stLogicParamSystem, sizeof(LOGIC_PARAM_TYPE)-0x02, &u16Temp);//	else		crc16_ccitt((u8 *)&s_stLogicParamSystem, sizeof(LOGIC_PARAM_TYPE)-0x02-WL_VERSION, &u16Temp);	s_stLogicParamSystem.u16Crc = u16Temp;	//信息存储	LOGIC_PARAM_WRITE_BUF(LOGIC_PARAM_STORAGE_BASEADDR,(u8 *)p,sizeof(LOGIC_PARAM_TYPE));}/*********************************************************************************************函数名称：LogicParamInint**函数作用：逻辑层参数初始化**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/u8 LogicParamInint(void){	u16 u16Temp = 0x00;	u32 *p = (u32 *)&(s_stLogicParamSystem.u32YKQPrgSec);		LOGIC_PARAM_READ_BUF(LOGIC_PARAM_STORAGE_BASEADDR,(u8 *)p,sizeof(LOGIC_PARAM_TYPE));	u16Temp = 0x00;	crc16_ccitt((u8 *)&s_stLogicParamSystem, sizeof(LOGIC_PARAM_TYPE)-0x02-WL_VERSION, &u16Temp);	if((s_stLogicParamSystem.u32YKQPrgSec == YK_PRG_SEC_NUMBER) && (u16Temp == s_stLogicParamSystem.u16Crc))	{//		u16KeyFilmNameRam = s_stLogicParamSystem.u16KeyFilmName;//		LogicSetGrpOffLed(u16KeyFilmNameRam);//		memmove(&u16KeySetActionNameRam, &s_stLogicParamSystem.u16KeySetActionName, LOGIC_KEYSET_ACTIONNUMB_MAX * 2);		//设定按键动作	2020.01.15 parry			for(u16Temp = 0;u16Temp<sizeof(s_stLogicParamSystem.u8WLVersion);u16Temp++)		{			s_stLogicParamSystem.u8WLVersion[u16Temp] = '*';		}		return 0x01;	}		else//需要恢复默认参数，并将默认参数进行存储。	{		if(g_u32ID == B_type)			memmove(&s_stLogicParamSystem, &s_stLogicParamDefault, sizeof(LOGIC_PARAM_TYPE));		else			memmove(&s_stLogicParamSystem, &s_stLogicParamDefault_D, sizeof(LOGIC_PARAM_TYPE));		LogicParamSaveProc();//		u16KeyFilmNameRam = s_stLogicParamSystem.u16KeyFilmName;//		LogicSetGrpOffLed(u16KeyFilmNameRam);//		memmove(&u16KeySetActionNameRam, &s_stLogicParamSystem.u16KeySetActionName, LOGIC_KEYSET_ACTIONNUMB_MAX * 2);		//设定按键动作	2020.01.15 parry		for(u16Temp = 0;u16Temp<sizeof(s_stLogicParamSystem.u8WLVersion);u16Temp++)		{			s_stLogicParamSystem.u8WLVersion[u16Temp] = '*';		}		return 0x00;	}}/*********************************************************************************************函数名称：LogicInint**函数作用：逻辑层初始化**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/u32 LogicInint(void){	LogicParamInint();		memset(&s_stLogicRunInf,0x00,sizeof(LOGIC_RUNINF_TYPE));	s_stLogicRunInf.stBatteryStatus = BATTERY_WORK_NORMAL;	s_stLogicRunInf.stBatteryCoulomStatus = BATTERY_COULOMETRY_100_PERCENT;	s_stLogicRunInf.u16BatteryCoulomData = 100;	s_stLogicRunInf.u16RfidSignStatus = RFID_SIGNAL_TOO_SMALL;	s_stLogicRunInf.stLogicRunStatus = LOGIC_STATUS_ININT;	s_u32LogicSampleTimer = 0x00;	s_u8YkqIdBackup = s_stLogicParamSystem.u8YKQNumber;	u32ShutDownTimer= 0x00;		g_stLogicSem= OSSemCreate(0);	//创建信号量		return 0x01;}/*********************************************************************************************函数名称：LogicGetPrgSecProc**函数作用：逻辑层参数读写消息处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/static u32 LogicGetPrgSecProc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData){	*(u32 *)pData = s_stLogicParamSystem.u32YKQPrgSec;		return 0x01;}/*********************************************************************************************函数名称：LogicGetYkqNumbProc**函数作用：逻辑层参数读写消息处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/static u32 LogicGetYkqNumbProc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData){	*(u8 *)pData = s_stLogicParamSystem.u8YKQNumber;		return 0x01;}/*********************************************************************************************函数名称：LogicGetYkqNumbProc**函数作用：逻辑层参数读写消息处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************///zzwstatic u32 LogicSetCtrlModeProc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData){	s_stLogicRunInf.CtrlMode = *(u8 *)pData;		return 0x01;}/*********************************************************************************************函数名称：LogicGetYkqNumbProc**函数作用：逻辑层参数读写消息处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************///zzwstatic u32 LogicGetCtrlModeProc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData){	*(u8 *)pData = s_stLogicRunInf.CtrlMode;		return 0x01;}/*********************************************************************************************函数名称：LogicGetRfidSelfNumbProc**函数作用：逻辑层参数读写消息处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/static u32 LogicGetRfidSelfNumbProc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData){	*(u8 *)pData = s_stLogicParamSystem.u8RfidSelfNumb;		return 0x01;}/*********************************************************************************************函数名称：LogicGetIrSendTimeoutProc**函数作用：逻辑层参数读写消息处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/static u32 LogicGetIrSendTimeoutProc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData){	*(u16 *)pData = s_stLogicParamSystem.u16IrSendTimeout;		return 0x01;}/*********************************************************************************************函数名称：LogicGetIrSendTimesProc**函数作用：逻辑层参数读写消息处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/static u32 LogicGetIrSendTimesProc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData){	*(u16 *)pData = s_stLogicParamSystem.u16IrSendTimes;		return 0x01;}/*********************************************************************************************函数名称：LogicGetRfidSendTimeoutProc**函数作用：逻辑层参数读写消息处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/static u32 LogicGetRfidSendTimeoutProc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData){	*(u16 *)pData = s_stLogicParamSystem.u16RfidSendTimeout;		return 0x01;}/*********************************************************************************************函数名称：LogicGetRfidSendTimesProc**函数作用：逻辑层参数读写消息处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/static u32 LogicGetRfidSendTimesProc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData){	*(u16 *)pData = s_stLogicParamSystem.u16RfidSendTimes;		return 0x01;}/*********************************************************************************************函数名称：LogicGetOledScrLightProc**函数作用：逻辑层参数读写消息处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/static u32 LogicGetOledScrLightProc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData){	*(u16 *)pData = s_stLogicParamSystem.u16OledScrLight;		return 0x01;}/*********************************************************************************************函数名称：LogicGetOledProtectBrightnessProc**函数作用：逻辑层参数读写消息处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/static u32 LogicGetOledProtectBrightnessProc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData){	*(u16 *)pData = s_stLogicParamSystem.u16OledProtectBrightness;		return 0x01;}/*********************************************************************************************函数名称：LogicgGetColibarateTimeoutProc**函数作用：逻辑层参数读写消息处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/static u32 LogicgGetColibarateTimeoutProc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData){	*(u32 *)pData = s_stLogicParamSystem.u32ColibareteTimeOut;		return 0x01;	}/*********************************************************************************************函数名称：LogicGetInterCtrlTimerProc**函数作用：逻辑层参数读写消息处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/static u32 LogicGetInterCtrlTimerProc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData){	*(u32 *)pData = s_stLogicParamSystem.u32InterfaceControlTimer;		return 0x01;}/*********************************************************************************************函数名称：LogicGetOledProtectedTimerProc**函数作用：逻辑层参数读写消息处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/static u32 LogicGetOledProtectedTimerProc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData){	*(u32 *)pData = s_stLogicParamSystem.u32OledScrProtectedTimer;		return 0x01;}/*********************************************************************************************函数名称：LogicGetOledProtectedTimerProc**函数作用：逻辑层参数读写消息处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/static u32 LogicGetOledShutdownTimerProc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData){	*(u32 *)pData = s_stLogicParamSystem.u32OledShutdownTimer;		return 0x01;	}	/*********************************************************************************************函数名称：LogicGetNoteShowTimerProc**函数作用：逻辑层参数读写消息处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/static u32 LogicGetNoteShowTimerProc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData){	*(u32 *)pData = s_stLogicParamSystem.u32NoteShowTimer;		return 0x01;}/*********************************************************************************************函数名称：LogicGetScCtrlDislayTimerProc**函数作用：逻辑层参数读写消息处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/static u32 LogicGetScCtrlDislayTimerProc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData){	*(u16 *)pData = s_stLogicParamSystem.u16ScCtrlDisplayTime;		return 0x01;}/*********************************************************************************************函数名称：LogicGetYkqIdBackupProc**函数作用：逻辑层参数读写消息处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/static u32 LogicGetYkqIdBackupProc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData){	*(u8 *)pData = s_u8YkqIdBackup;		return 0x01;	}/*********************************************************************************************函数名称：LogicGetShutDownFlagProc**函数作用：逻辑层参数读写消息处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/static u32 LogicGetShutDownFlagProc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData){	u32 u32Temp = 0x00; 	LOGIC_PARAM_READ_BUF(LOGIC_PARAM_STORAGE_TURNON_ADDRESS,(u8 *)pData,0x04);	if((*(u32 *)pData) !=  0x00)	{		u32Temp = 0x00;		LOGIC_PARAM_WRITE_BUF(LOGIC_PARAM_STORAGE_TURNON_ADDRESS,(u8 *)&u32Temp,0x04);	}	return 0x01;}/*********************************************************************************************函数名称：LogicGetBatteryAcrBackupProc**函数作用：逻辑层参数读写消息处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/static u32 LogicGetBatteryAcrBackupProc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData){	LOGIC_PARAM_READ_BUF(LOGIC_PARAM_STORAGE_ACR_ADDRESS,(u8 *)pData,0x04);		return 0x01;}/*********************************************************************************************函数名称：LogicGetBatteryColDataBackupProc**函数作用：逻辑层参数读写消息处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/static u32 LogicGetBatteryColDataBackupProc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData){	LOGIC_PARAM_READ_BUF(LOGIC_PARAM_STORAGE_COLDATA_ADDRESS,(u8 *)pData,0x04);		return 0x01;}/*********************************************************************************************函数名称：LogicGetBatterVoltageBackupProc**函数作用：逻辑层参数读写消息处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/static u32 LogicGetBatterVoltageBackupProc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData){	LOGIC_PARAM_READ_BUF(LOGIC_PARAM_STORAGE_VOLTAGE_ADDRESS,(u8 *)pData,0x04);		return 0x01;}/*********************************************************************************************函数名称：LogicGetBatterInchargeTimerProc**函数作用：逻辑层参数读写消息处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/static u32 LogicGetBatterInchargeTimerProc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData){	LOGIC_PARAM_READ_BUF(LOGIC_PARAM_STORAGE_INCHARGE_TIMER,(u8 *)pData,0x04);		return 0x01;	}/*********************************************************************************************函数名称：LogicGetQuick1EnableFalg**函数作用：逻辑层参数读写消息处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/#if (QUICK_KEY_CTRL_ENABLE_FLAG	!= DISABLED)	#if (QUICK_KEY_1_ENABLE_FLAG != DISABLED)		static u32 LogicGetQuick1EnableFalg(LOGIC_PARAM_MSG_TYPE sMsg,void *pData)		{			u32 u32ReturnFlag = 0x01;						*(u16 *)pData = s_stLogicParamSystem.u16Quick1EnableFlag;			return u32ReturnFlag;					}	#endif#endif/*********************************************************************************************函数名称：LogicGetQuick1ActionNumb**函数作用：逻辑层参数读写消息处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/#if (QUICK_KEY_CTRL_ENABLE_FLAG	!= DISABLED)	#if (QUICK_KEY_1_ENABLE_FLAG != DISABLED)		static u32 LogicGetQuick1ActionNumb(LOGIC_PARAM_MSG_TYPE sMsg,void *pData)		{			u32 u32ReturnFlag = 0x01;			*(u16 *)pData = s_stLogicParamSystem.u16Quick1ActionNumb ;			return u32ReturnFlag;				}	#endif#endif/*********************************************************************************************函数名称：LogicGetQuick1AlaramTime**函数作用：逻辑层参数读写消息处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/#if (QUICK_KEY_CTRL_ENABLE_FLAG	!= DISABLED)	#if (QUICK_KEY_1_ENABLE_FLAG != DISABLED)		static u32 LogicGetQuick1AlaramTime(LOGIC_PARAM_MSG_TYPE sMsg,void *pData)		{			u32 u32ReturnFlag = 0x01;			 *(u16 *)pData = s_stLogicParamSystem.u16Quick1AlaramTimer;			return u32ReturnFlag;				}	#endif#endif/*********************************************************************************************函数名称：LogicGetQuick1ActionName**函数作用：逻辑层参数读写消息处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/#if (QUICK_KEY_CTRL_ENABLE_FLAG	!= DISABLED)	#if (QUICK_KEY_1_ENABLE_FLAG != DISABLED)		static u32 LogicGetQuick1ActionName(LOGIC_PARAM_MSG_TYPE sMsg,void *pData)		{			u32 u32ReturnFlag = 0x01;			*(u16 *)pData = s_stLogicParamSystem.u16Quick1ActionName[sMsg-LOGIC_GET_QUICK1_ACTIONNAME_1];			return u32ReturnFlag;					}	#endif#endif		///*******************************************************************************************//**函数名称：LogicGetKeyFilmName//**函数作用：逻辑层参数读写消息处理函数//**函数参数：无//**函数输出：无//**注意事项：无//*******************************************************************************************///static u32 LogicGetKeyFilmName(LOGIC_PARAM_MSG_TYPE sMsg,void *pData)		//选择键盘膜	2020.01.15 parry//{//	u32 u32ReturnFlag = 0x01;//	*(u16 *)pData = s_stLogicParamSystem.u16KeyFilmName;//	return u32ReturnFlag;			//}///*******************************************************************************************//**函数名称：LogicGetKeySetActionName//**函数作用：逻辑层参数读写消息处理函数//**函数参数：无//**函数输出：无//**注意事项：无//*******************************************************************************************///static u32 LogicGetKeySetActionName(LOGIC_PARAM_MSG_TYPE sMsg,void *pData)		//设定按键动作	2020.01.15 parry	//{//	u32 u32ReturnFlag = 0x01;//	*(u16 *)pData = s_stLogicParamSystem.u16KeySetActionName[sMsg-LOGIC_GET_KEYN_1_ACTIONNAME];//	return u32ReturnFlag;			//}/*********************************************************************************************函数名称：LogicGetQuick1ActionTime**函数作用：逻辑层参数读写消息处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/#if (QUICK_KEY_CTRL_ENABLE_FLAG	!= DISABLED)	#if (QUICK_KEY_1_ENABLE_FLAG != DISABLED)		static u32 LogicGetQuick1ActionTime(LOGIC_PARAM_MSG_TYPE sMsg,void *pData)		{			u32 u32ReturnFlag = 0x01;			*(u16 *)pData = s_stLogicParamSystem.u16Quick1ActionStart[sMsg-LOGIC_GET_QUICK1_ACTIONTIME_1];			return u32ReturnFlag;						}	#endif#endif/*********************************************************************************************函数名称：LogicGetQuick1ActionInterval**函数作用：逻辑层参数读写消息处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/#if (QUICK_KEY_CTRL_ENABLE_FLAG	!= DISABLED)	#if (QUICK_KEY_1_ENABLE_FLAG != DISABLED)		static u32 LogicGetQuick1ActionInterval(LOGIC_PARAM_MSG_TYPE sMsg,void *pData)		{			u32 u32ReturnFlag = 0x01;			*(u16 *)pData = s_stLogicParamSystem.u16Quick1ActionIng[sMsg-LOGIC_GET_QUICK1_ACTIONINTERVAL_1] ;			return u32ReturnFlag;		}	#endif#endif/*********************************************************************************************函数名称：LogicGetQuick2EnableFalg**函数作用：逻辑层参数读写消息处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/#if (QUICK_KEY_CTRL_ENABLE_FLAG	!= DISABLED)	#if (QUICK_KEY_2_ENABLE_FLAG != DISABLED)		static u32 LogicGetQuick2EnableFalg(LOGIC_PARAM_MSG_TYPE sMsg,void *pData)		{			u32 u32ReturnFlag = 0x01;						*(u16 *)pData = s_stLogicParamSystem.u16Quick2EnableFlag;			return u32ReturnFlag;					}	#endif#endif/*********************************************************************************************函数名称：LogicGetQuick2ActionNumb**函数作用：逻辑层参数读写消息处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/#if (QUICK_KEY_CTRL_ENABLE_FLAG	!= DISABLED)	#if (QUICK_KEY_2_ENABLE_FLAG != DISABLED)		static u32 LogicGetQuick2ActionNumb(LOGIC_PARAM_MSG_TYPE sMsg,void *pData)		{			u32 u32ReturnFlag = 0x01;			*(u16 *)pData = s_stLogicParamSystem.u16Quick2ActionNumb;			return u32ReturnFlag;				}	#endif#endif/*********************************************************************************************函数名称：LogicGetQuick2AlaramTime**函数作用：逻辑层参数读写消息处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/#if (QUICK_KEY_CTRL_ENABLE_FLAG	!= DISABLED)	#if (QUICK_KEY_2_ENABLE_FLAG != DISABLED)		static u32 LogicGetQuick2AlaramTime(LOGIC_PARAM_MSG_TYPE sMsg,void *pData)		{			u32 u32ReturnFlag = 0x01;			*(u16 *)pData = s_stLogicParamSystem.u16Quick2AlaramTimer;			return u32ReturnFlag;				}	#endif#endif/*********************************************************************************************函数名称：LogicGetQuick2ActionName**函数作用：逻辑层参数读写消息处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/#if (QUICK_KEY_CTRL_ENABLE_FLAG	!= DISABLED)	#if (QUICK_KEY_2_ENABLE_FLAG != DISABLED)		static u32 LogicGetQuick2ActionName(LOGIC_PARAM_MSG_TYPE sMsg,void *pData)		{			u32 u32ReturnFlag = 0x01;			*(u16 *)pData = s_stLogicParamSystem.u16Quick2ActionName[sMsg-LOGIC_GET_QUICK2_ACTIONNAME_1];							return u32ReturnFlag;					}	#endif#endif/*********************************************************************************************函数名称：LogicGetQuick2ActionTime**函数作用：逻辑层参数读写消息处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/#if (QUICK_KEY_CTRL_ENABLE_FLAG	!= DISABLED)	#if (QUICK_KEY_2_ENABLE_FLAG != DISABLED)		static u32 LogicGetQuick2ActionTime(LOGIC_PARAM_MSG_TYPE sMsg,void *pData)		{			u32 u32ReturnFlag = 0x01;			*(u16 *)pData = s_stLogicParamSystem.u16Quick2ActionStart[sMsg-LOGIC_GET_QUICK2_ACTIONTIME_1] ;			return u32ReturnFlag;						}	#endif#endif/*********************************************************************************************函数名称：LogicGetQuick2ActionInterval**函数作用：逻辑层参数读写消息处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/#if (QUICK_KEY_CTRL_ENABLE_FLAG	!= DISABLED)	#if (QUICK_KEY_2_ENABLE_FLAG != DISABLED)		static u32 LogicGetQuick2ActionInterval(LOGIC_PARAM_MSG_TYPE sMsg,void *pData)		{			u32 u32ReturnFlag = 0x01;			*(u16 *)pData = s_stLogicParamSystem.u16Quick2ActionIng[sMsg-LOGIC_GET_QUICK2_ACTIONINTERVAL_1];			return u32ReturnFlag;		}	#endif#endif/*********************************************************************************************函数名称：LogicGetQuickActionInvaild**函数作用：逻辑层参数读写消息处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/#if (QUICK_KEY_CTRL_ENABLE_FLAG	!= DISABLED)	static u32 LogicGetQuickActionInvaild(LOGIC_PARAM_MSG_TYPE sMsg,void *pData)	{		u16 u16I;		u32 u32ReturnFlag = 0x00;				if(sMsg == LOGIC_GET_QUICK1_ACTION_VAILD)		{			if(s_stLogicParamSystem.u16Quick1EnableFlag != ENABLED)			{				u32ReturnFlag = 0x00;			}			else if(s_stLogicParamSystem.u16Quick1ActionNumb == 0x00)			{				u32ReturnFlag = 0xEE;			}			else			{				u32ReturnFlag = 0xCC;				for(u16I = 0x00; u16I < s_stLogicParamSystem.u16Quick1ActionNumb; u16I++)				{					if(s_stLogicParamSystem.u16Quick1ActionName[u16I] !=  0x00)					{						u32ReturnFlag = 0x01;						break;					}				}																if(u32ReturnFlag == 0x01)				{					u32ReturnFlag = 0xDD;					for(u16I = 0x00; u16I < s_stLogicParamSystem.u16Quick1ActionNumb; u16I++)					{						if(s_stLogicParamSystem.u16Quick1ActionStart[u16I] !=  0x00)						{							u32ReturnFlag = 0x01;							break;						}					}						}			}						}		else if(sMsg == LOGIC_GET_QUICK2_ACTION_VAILD)		{			if(s_stLogicParamSystem.u16Quick2EnableFlag != ENABLED)			{				u32ReturnFlag = 0x00;			}			else if(s_stLogicParamSystem.u16Quick2ActionNumb == 0x00)			{				u32ReturnFlag = 0xEE;			}			else			{				u32ReturnFlag = 0xCC;				for(u16I = 0x00; u16I < s_stLogicParamSystem.u16Quick2ActionNumb; u16I++)				{					if(s_stLogicParamSystem.u16Quick2ActionName[u16I] !=  0x00)					{						u32ReturnFlag = 0x01;						break;					}				}																if(u32ReturnFlag == 0x01)				{					u32ReturnFlag = 0xDD;					for(u16I = 0x00; u16I < s_stLogicParamSystem.u16Quick2ActionNumb; u16I++)					{						if(s_stLogicParamSystem.u16Quick2ActionStart[u16I] !=  0x00)						{							u32ReturnFlag = 0x01;							break;						}					}						}			}		}			else		{			;		}		return u32ReturnFlag;	}#endif/*********************************************************************************************函数名称：LogicGetYkqAppStationProc**函数作用：逻辑层参数读写消息处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/static u32 LogicGetYkqAppStationProc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData){	*(u16 *)pData = YKQ_TARGET_USE_LOCATION_DEFINE-0x01;	return 0x00;}/*********************************************************************************************函数名称：LogicResumeDefaultParamProc**函数作用：逻辑层参数读写消息处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/static u32 LogicResumeDefaultParamProc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData){	u16 u16I = 0x00;//	u16KeyFilmNameRam = s_stLogicParamSystem.u16KeyFilmName;	//恢复默认值时不能改变键盘膜参数和动作参数	2020.01.15 parry//	memmove(&u16KeySetActionNameRam, &s_stLogicParamSystem.u16KeySetActionName, LOGIC_KEYSET_ACTIONNUMB_MAX * 2);			//恢复默认值时不能改变设定按键动作	2020.01.15 parry	if(g_u32ID == B_type)		memmove(&s_stLogicParamSystem, &s_stLogicParamDefault, sizeof(LOGIC_PARAM_TYPE));	else		memmove(&s_stLogicParamSystem, &s_stLogicParamDefault_D, sizeof(LOGIC_PARAM_TYPE));//	s_stLogicParamSystem.u16KeyFilmName = u16KeyFilmNameRam ;	//	memmove(&s_stLogicParamSystem.u16KeySetActionName, &u16KeySetActionNameRam, LOGIC_KEYSET_ACTIONNUMB_MAX * 2);				OledContrastAdj(s_stLogicParamSystem.u16OledScrLight);	//亮度参数		LogicParamSaveProc();		/**获取RFID的默认地址**/	u16I = LOGIC_SC_NUMB_MAX - s_stLogicParamSystem.u8YKQNumber;	/**设置RFID的默认地址**/	LogicParamApi(LOGIC_SET_RFID_NUMBER, &u16I);	for(u16I = 0;u16I<sizeof(s_stLogicParamSystem.u8WLVersion);u16I++)	{		s_stLogicParamSystem.u8WLVersion[u16I] = '*';	}		return 0x00;}/*********************************************************************************************函数名称：LogicResumeDefaultParamProc**函数作用：逻辑层参数读写消息处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/static u32 LogicIRSendParamProc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData){		if( *(u32 *)pData == DISABLED)	{		IRSEND = 0x00;		s_stLogicParamSystem.u16irsendstate = *(u16 *)pData;		LogicParamSaveProc();			}	else if( *(u32 *)pData == ENABLED)	{		IRSEND = 0x01;		s_stLogicParamSystem.u16irsendstate = *(u16 *)pData;		LogicParamSaveProc();			}// 	while(1)// 	{// 		IrLOCSendInsertTxBuf(0x0001,0x56);// 		OSTimeDly(10/TICK_TIME);// 	}		return 0x00;}static u32 LogicGETIRSendParamProc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData){	u32 u32ReturnFlag = 0x01;		*(u16 *)pData = s_stLogicParamSystem.u16irsendstate;	return u32ReturnFlag;		}	/*********************************************************************************************函数名称：LogicResumeDefaultParamProc**函数作用：逻辑层参数读写消息处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/static u32 LogicWlTestParamProc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData){	if( *(u32 *)pData == DISABLED)	{		s_stLogicParamSystem.WlSendTestEnable = *(u8 *)pData;		LogicParamSaveProc();			}	else if( *(u32 *)pData == ENABLED)	{		s_stLogicParamSystem.WlSendTestEnable = *(u8 *)pData;		LogicParamSaveProc();			}		return 0x00;}static u32 LogicGetWlTestParamProc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData){	u32 u32ReturnFlag = 0x01;		*(u8 *)pData = s_stLogicParamSystem.WlSendTestEnable;	return u32ReturnFlag;		}/*********************************************************************************************函数名称：LogicGetColibrateYkqIdProc**函数作用：逻辑层运行信息消息处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/#if (SET_YKQ_PRGPT_USE_FLAG != 0)	static u32 LogicGetColibrateYkqIdProc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData)	{		*(u16 *)pData = s_stLogicParamSystem.u16ColibrateYkqId;		return 0x01;	}#endif/*********************************************************************************************函数名称：LogicGetColibrateYkqTypeProc**函数作用：逻辑层运行信息消息处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/#if (SET_YKQ_PRGPT_USE_FLAG != 0)	static u32 LogicGetColibrateYkqTypeProc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData)	{		*(u16 *)pData = s_stLogicParamSystem.u16ColibrateYkqType;		return 0x01;	}#endif/*********************************************************************************************函数名称：LogicGetColibrateYkqStationProc**函数作用：逻辑层运行信息消息处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/#if (SET_YKQ_PRGPT_USE_FLAG != 0)	static u32 LogicGetColibrateYkqStationProc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData)	{		*(u16 *)pData = s_stLogicParamSystem.u16ColibrateYkqAppStation;		return 0x01;	}#endif/*********************************************************************************************函数名称：LogicGetColibrateYkqVersionProc**函数作用：逻辑层运行信息消息处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/#if (SET_YKQ_PRGPT_USE_FLAG != 0)	static u32 LogicGetColibrateYkqVersionProc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData)	{		memcpy(pData,&(s_stLogicParamSystem.u8ColibrateYkqVersion),0x09);		return 0x01;			}#endif/*********************************************************************************************函数名称：LogicGetZibaoEnabledFlagProc**函数作用：逻辑层运行信息消息处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/#if (ZIBAO_CTRL_ENABLE_FLAG != DISABLED)	static u32 LogicGetZibaoEnabledFlagProc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData)	{		*(u16 *)pData = s_stLogicParamSystem.u16ZibaoEnableFlag;				return 0x01;	}#endif/*********************************************************************************************函数名称：LogicGetZibaoActionMaxProc**函数作用：逻辑层运行信息消息处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/#if (ZIBAO_CTRL_ENABLE_FLAG != DISABLED)	static u32 LogicGetZibaoActionMaxProc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData)	{		*(u16 *)pData = s_stLogicParamSystem.u16ZibaoActionMax;		return 0x01;			}#endif//jhy/*********************************************************************************************函数名称：LogicGetZibaoActionMaxProc**函数作用：逻辑层运行信息消息处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/	static u32 LogicSetFastColiearateEnableProc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData)	{		s_stLogicParamSystem.u16FastColiearateEnable  = *(u16 *)pData;		LogicParamSaveProc();				return 0x01;	}/*********************************************************************************************函数名称：LogicGetZibaoActionMaxProc**函数作用：逻辑层运行信息消息处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/	static u32 LogicGetFastColiearateEnableProc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData)	{		*(u16 *)pData = s_stLogicParamSystem.u16FastColiearateEnable;		return 0x01;			}/*********************************************************************************************函数名称：LogicGetZibaoTimeOutProc**函数作用：逻辑层运行信息消息处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/#if (ZIBAO_CTRL_ENABLE_FLAG != DISABLED)	#if (ZIBAO_CTRL_METHOD_TYPE == ZIBAO_PARAM_CTRL_METHOD)	static u32 LogicGetZibaoTimeOutProc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData)	{		*(u32 *)pData  = s_stLogicParamSystem.u32ZibaoTimeout;		return 0x01;				}	#endif#endif/*********************************************************************************************函数名称：LogicGetZibaoActionEnableFlagProc**函数作用：逻辑层运行信息消息处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/#if (ZIBAO_CTRL_ENABLE_FLAG != DISABLED)	#if (ZIBAO_CTRL_METHOD_TYPE == ZIBAO_PARAM_CTRL_METHOD)		static u32 LogicGetZibaoActionEnableFlagProc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData)		{			if((sMsg >= LOGIC_GET_SHENGZHU_ENABLE_FLAG)\				&&(sMsg <= LOGIC_GET_QIANLIANGXIABAI_ENABLE_FLAG))			{				*(u8 *)pData = s_stLogicParamSystem.u8ZibaoActionEnabledFlag[sMsg-LOGIC_GET_SHENGZHU_ENABLE_FLAG];			}			return 0x01;		}	#endif#endif/*********************************************************************************************函数名称：LogicGetZibaoActionIngTimeProc**函数作用：逻辑层运行信息消息处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/#if (ZIBAO_CTRL_ENABLE_FLAG != DISABLED)	#if (ZIBAO_CTRL_METHOD_TYPE == ZIBAO_PARAM_CTRL_METHOD)		static u32 LogicGetZibaoActionIngTimeProc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData)		{			if((sMsg >= LOGIC_GET_SHENGZHU_DOING_TIME)\				&&(sMsg <= LOGIC_GET_QIANLIANGXIABAI_DOING_TIME))			{				*(u32 *)pData = s_stLogicParamSystem.u32ZibaoActionDoingTime[sMsg-LOGIC_GET_SHENGZHU_DOING_TIME];			}			return 0x01;		}	#endif#endif/*********************************************************************************************函数名称：LogicSetPrgSecProc**函数作用：逻辑层参数读写消息处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/static u32 LogicSetPrgSecProc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData){	s_stLogicParamSystem.u32YKQPrgSec = *(u32 *)pData ;	LogicParamSaveProc();	return 0x01;}/*********************************************************************************************函数名称：LogicSetYkqNumbProc**函数作用：逻辑层参数读写消息处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/static u32 LogicSetYkqNumbProc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData){	s_stLogicParamSystem.u8YKQNumber = *(u8 *)pData ;		if((*(u8 *)pData > YKQ_NUMBER_MAX) ||(*(u8 *)pData < YKQ_NUMBER_MIN) )		return 0x00;//超范围	else		{		/**设置RFID的默认地址**/		s_stLogicParamSystem.u8RfidSelfNumb = LOGIC_SC_NUMB_MAX - *(u8 *)pData;		SetLocalAddress(s_stLogicParamSystem.u8RfidSelfNumb);		LogicParamSaveProc();			//jhy		if(g_u32ID != B_type)			SendSetupToWl(RFID_ININT_SYNC1);		return 0x01;	}}/*********************************************************************************************函数名称：LogicSetRfidSelfNumbProc**函数作用：逻辑层参数读写消息处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/static u32 LogicSetRfidSelfNumbProc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData){	s_stLogicParamSystem.u8RfidSelfNumb = *(u8 *)pData;	SetLocalAddress(*(u8 *)pData);	LogicParamSaveProc();	return 0x01;}/*********************************************************************************************函数名称：LogicSetIrSendTimeoutProc**函数作用：逻辑层参数读写消息处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/static u32 LogicSetIrSendTimeoutProc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData){	s_stLogicParamSystem.u16IrSendTimeout = *(u16 *)pData;	LogicParamSaveProc();	return 0x01;}/*********************************************************************************************函数名称：LogicSetIrSendTimesProc**函数作用：逻辑层参数读写消息处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/static u32 LogicSetIrSendTimesProc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData){	s_stLogicParamSystem.u16IrSendTimes = *(u16 *)pData;	LogicParamSaveProc();	return 0x01;}/*********************************************************************************************函数名称：LogicSetRfidSendTimeoutProc**函数作用：逻辑层参数读写消息处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/static u32 LogicSetRfidSendTimeoutProc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData){	s_stLogicParamSystem.u16RfidSendTimeout = *(u16 *)pData ;	LogicParamSaveProc();	return 0x01;}/*********************************************************************************************函数名称：LogicSetRfidSendTimesProc**函数作用：逻辑层参数读写消息处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/static u32 LogicSetRfidSendTimesProc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData){	s_stLogicParamSystem.u16RfidSendTimes = *(u16 *)pData;	LogicParamSaveProc();	return 0x01;}/*********************************************************************************************函数名称：LogicSetOledScrLightProc**函数作用：逻辑层参数读写消息处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/static u32 LogicSetOledScrLightProc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData){	s_stLogicParamSystem.u16OledScrLight = *(u16 *)pData;	OledContrastAdj((*(u16 *)pData));	//亮度参数		LogicParamSaveProc();		return 0x01;}/*********************************************************************************************函数名称：LogicSetOledProtectBrightnessProc**函数作用：逻辑层参数读写消息处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/static u32 LogicSetOledProtectBrightnessProc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData){	s_stLogicParamSystem.u16OledProtectBrightness = *(u16 *)pData;	LogicParamSaveProc();	return 0x01;}/*********************************************************************************************函数名称：LogicSetColibarateTimeoutProc**函数作用：逻辑层参数读写消息处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/static u32 LogicSetColibarateTimeoutProc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData){	s_stLogicParamSystem.u32ColibareteTimeOut = *(u32 *)pData;	LogicParamSaveProc();	return 0x01;	}/*********************************************************************************************函数名称：LogicSetInterCtrlTimerProc**函数作用：逻辑层参数读写消息处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/static u32 LogicSetInterCtrlTimerProc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData){	s_stLogicParamSystem.u32InterfaceControlTimer = *(u32 *)pData;	LogicParamSaveProc();	return 0x01;}/*********************************************************************************************函数名称：LogicSetOledProtectedTimerProc**函数作用：逻辑层参数读写消息处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/static u32 LogicSetOledProtectedTimerProc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData){	s_stLogicParamSystem.u32OledScrProtectedTimer = *(u32 *)pData;	LogicParamSaveProc();	return 0x01;}/*********************************************************************************************函数名称：LogicSetOledProtectedTimerProc**函数作用：逻辑层参数读写消息处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/static u32 LogicSetOledShutdownTimerProc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData){	s_stLogicParamSystem.u32OledShutdownTimer = *(u32 *)pData;	LogicParamSaveProc();	return 0x01;	}/*********************************************************************************************函数名称：LogicSetNoteShowTimerProc**函数作用：逻辑层参数读写消息处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/static u32 LogicSetNoteShowTimerProc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData){	s_stLogicParamSystem.u32NoteShowTimer = *(u32 *)pData;	LogicParamSaveProc();	return 0x01;}/*********************************************************************************************函数名称：LogicSetScCtrlDislayTimerProc**函数作用：逻辑层参数读写消息处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/static u32 LogicSetScCtrlDislayTimerProc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData){	s_stLogicParamSystem.u16ScCtrlDisplayTime = *(u16 *)pData;	//LogicParamSaveProc(void)();//此参数无需保存	return 0x01;}/*********************************************************************************************函数名称：LogicSetYkqIdBackupProc**函数作用：逻辑层参数读写消息处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/static u32 LogicSetYkqIdBackupProc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData){	s_u8YkqIdBackup = *(u8 *)pData;		return 0x01;	}/*********************************************************************************************函数名称：LogicSetShutDownFlagProc**函数作用：逻辑层参数读写消息处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/static u32 LogicSetShutDownFlagProc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData){	//信息存储	LOGIC_PARAM_WRITE_BUF(LOGIC_PARAM_STORAGE_TURNON_ADDRESS,(u8 *)pData,0x04);	return 0x01;}/*********************************************************************************************函数名称：LogicSetShutDownFlagProc**函数作用：逻辑层参数读写消息处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/static u32 LogicSetBatteryAcrBackupProc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData){	if(((*(u32 *)pData) <= BATTERY_CURRENT_MAX)||((*(u32 *)pData) == 0xFFFFFFFF))	{		//信息存储		LOGIC_PARAM_WRITE_BUF(LOGIC_PARAM_STORAGE_ACR_ADDRESS,(u8 *)pData,0x04);		return 0x01;	}	else		return 0x00;}/*********************************************************************************************函数名称：LogicSetShutDownFlagProc**函数作用：逻辑层参数读写消息处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/static u32 LogicSetBatteryColDataBackupProc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData){	if(((*(u32 *)pData) <= BATTERY_VOLTAGE_FULL_PERCENT)||((*(u32 *)pData) == 0xFFFFFFFF))	{		//信息存储		LOGIC_PARAM_WRITE_BUF(LOGIC_PARAM_STORAGE_COLDATA_ADDRESS,(u8 *)pData,0x04);		return 0x01;	}	else		return 0x00;}/*********************************************************************************************函数名称：LogicSetBatterVoltageBackupProc**函数作用：逻辑层参数读写消息处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/static u32 LogicSetBatterVoltageBackupProc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData){	if(((*(u32 *)pData) <= BATTERY_VOLTAGE_MAX)||((*(u32 *)pData) == 0xFFFFFFFF))	{		//信息存储		LOGIC_PARAM_WRITE_BUF(LOGIC_PARAM_STORAGE_VOLTAGE_ADDRESS,(u8 *)pData,0x04);		return 0x01;	}	else		return 0x00;}/*********************************************************************************************函数名称：LogicSetBatterInchargeTimerProc**函数作用：逻辑层参数读写消息处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/static u32 LogicSetBatterInchargeTimerProc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData){	//信息存储	LOGIC_PARAM_WRITE_BUF(LOGIC_PARAM_STORAGE_INCHARGE_TIMER,(u8 *)pData,0x04);	return 0x01;	}/*********************************************************************************************函数名称：LogicSetQuick1EnableFalg**函数作用：逻辑层参数读写消息处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/#if (QUICK_KEY_CTRL_ENABLE_FLAG	!= DISABLED)	#if (QUICK_KEY_1_ENABLE_FLAG != DISABLED)		static u32 LogicSetQuick1EnableFalg(LOGIC_PARAM_MSG_TYPE sMsg,void *pData)		{			u32 u32ReturnFlag = 0x01;						if((*(u16 *)pData)  == ENABLED)			{				s_stLogicParamSystem.u16Quick1EnableFlag = *(u16 *)pData;				LogicParamSaveProc();					}			else if((*(u16 *)pData) == DISABLED)			{				s_stLogicParamSystem.u16Quick1EnableFlag = *(u16 *)pData;				LogicParamSaveProc();						}			else			{				u32ReturnFlag = 0x00;			}			return u32ReturnFlag;					}	#endif#endif/*********************************************************************************************函数名称：LogicSetQuick1ActionNumb**函数作用：逻辑层参数读写消息处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/#if (QUICK_KEY_CTRL_ENABLE_FLAG	!= DISABLED)	#if (QUICK_KEY_1_ENABLE_FLAG != DISABLED)		static u32 LogicSetQuick1ActionNumb(LOGIC_PARAM_MSG_TYPE sMsg,void *pData)		{			u32 u32ReturnFlag = 0x01;			if((*(u16 *)pData) <= LOGIC_QUICK_ACTIONNUMB_MAX)			{				s_stLogicParamSystem.u16Quick1ActionNumb = *(u16 *)pData;				LogicParamSaveProc();					}			else			{				u32ReturnFlag = 0x00;			}			return u32ReturnFlag;				}	#endif#endif/*********************************************************************************************函数名称：LogicSetQuick1AlaramTime**函数作用：逻辑层参数读写消息处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/#if (QUICK_KEY_CTRL_ENABLE_FLAG	!= DISABLED)	#if (QUICK_KEY_1_ENABLE_FLAG != DISABLED)		static u32 LogicSetQuick1AlaramTime(LOGIC_PARAM_MSG_TYPE sMsg,void *pData)		{			u32 u32ReturnFlag = 0x01;			s_stLogicParamSystem.u16Quick1AlaramTimer = *(u16 *)pData;			LogicParamSaveProc();					return u32ReturnFlag;				}	#endif#endif/*********************************************************************************************函数名称：LogicSetQuick1ActionName**函数作用：逻辑层参数读写消息处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/#if (QUICK_KEY_CTRL_ENABLE_FLAG	!= DISABLED)	#if (QUICK_KEY_1_ENABLE_FLAG != DISABLED)		static u32 LogicSetQuick1ActionName(LOGIC_PARAM_MSG_TYPE sMsg,void *pData)		{			u32 u32ReturnFlag = 0x01;			if((*(u16 *)pData) <= sizeof(u8LogicSupportAction))			{				s_stLogicParamSystem.u16Quick1ActionName[sMsg-LOGIC_SET_QUICK1_ACTIONNAME_1]= *(u16 *)pData;				LogicParamSaveProc();					}			else			{				u32ReturnFlag = 0x00;			}			return u32ReturnFlag;					}	#endif#endif		///*******************************************************************************************//**函数名称：LogicSetKeyFilmName//**函数作用：逻辑层参数读写消息处理函数//**函数参数：无//**函数输出：无//**注意事项：无//*******************************************************************************************///static u32 LogicSetKeyFilmName(LOGIC_PARAM_MSG_TYPE sMsg,void *pData)		//设定键盘膜	2020.01.15 parry//{//	u32 u32ReturnFlag = 0x01;//	s_stLogicParamSystem.u16KeyFilmName = *(u16 *)pData;//	u16KeyFilmNameRam =  *(u16 *)pData;			//设定键盘膜时同时修改RAM	2020.01.15 parry//	if(*(u16 *)pData < 2)		//设定自定义键盘膜时，各键动作定义不变，还保留当前设定	2020.05.07	parry//	{//		LogicSetGrpOffLed(u16KeyFilmNameRam);//		if(g_u32ID == B_type)//		{//			memmove(&s_stLogicParamSystem.u16KeySetActionName, &s_stInterfaceKeyFILMTable[*(u16 *)pData].u16KeyFilmActionSN, LOGIC_KEYSET_ACTIONNUMB_MAX * 2);			//			memmove(&u16KeySetActionNameRam, &s_stLogicParamSystem.u16KeySetActionName, LOGIC_KEYSET_ACTIONNUMB_MAX * 2);			//设定键盘膜时同时修改RAM	2020.01.15 parry//		}//		else//		{//			memmove(&s_stLogicParamSystem.u16KeySetActionName, &s_stInterfaceKeyFILMTable_D[*(u16 *)pData].u16KeyFilmActionSN, LOGIC_KEYSET_ACTIONNUMB_MAX * 2);			//			memmove(&u16KeySetActionNameRam, &s_stLogicParamSystem.u16KeySetActionName, LOGIC_KEYSET_ACTIONNUMB_MAX * 2);			//设定键盘膜时同时修改RAM	2020.01.15 parry	//		}//	}//	LogicParamSaveProc();		//	return u32ReturnFlag;		//}/*********************************************************************************************函数名称：LogicSetKEYSETActionName**函数作用：逻辑层参数读写消息处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************///static u32 LogicSetKeySetActionName(LOGIC_PARAM_MSG_TYPE sMsg,void *pData)	//设定按键动作	2020.01.15 parry//{//	u32 u32ReturnFlag = 0x01;//	u8	u8I;//	if((*(u16 *)pData) <= sizeof(u8LogicSupportAction))//	{//		if((*(u16 *)pData) != 0x00)		//按键动作设置为“无”时，可以重复定义//		{//			if(u16KeyFilmNameRam != 0x02) //非自定义键盘膜时，前18个动作不可编程，最后6个键可编程，可编程的键不可重复定义//			{//				for(u8I = 18;u8I < LOGIC_KEYSET_ACTIONNUMB_MAX;u8I++)//				{//					if(*(u16 *)pData == u16KeySetActionNameRam[u8I]) //					{//						u32ReturnFlag = 0x00;//						return u32ReturnFlag;			//					}//				}//			}//			else	//自定义键盘膜时，所有24个动作可编程，可编程的键不可重复定义//			{//				for(u8I = 0;u8I < LOGIC_KEYSET_ACTIONNUMB_MAX;u8I++)//				{//					if(*(u16 *)pData == u16KeySetActionNameRam[u8I]) //					{//						u32ReturnFlag = 0x00;//						return u32ReturnFlag;			//					}//				}//			}//		}//		s_stLogicParamSystem.u16KeySetActionName[sMsg-LOGIC_SET_KEYN_1_ACTIONNAME]= *(u16 *)pData;//		memmove(&u16KeySetActionNameRam, &s_stLogicParamSystem.u16KeySetActionName, LOGIC_KEYSET_ACTIONNUMB_MAX * 2);			//设定动作时同时修改RAM	2020.01.15 parry//		//	}//	else//	{//		u32ReturnFlag = 0x00;//	}//	return u32ReturnFlag;			//}		/*********************************************************************************************函数名称：LogicSetQuick1ActionTime**函数作用：逻辑层参数读写消息处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/#if (QUICK_KEY_CTRL_ENABLE_FLAG	!= DISABLED)	#if (QUICK_KEY_1_ENABLE_FLAG != DISABLED)		static u32 LogicSetQuick1ActionTime(LOGIC_PARAM_MSG_TYPE sMsg,void *pData)		{			u32 u32ReturnFlag = 0x01;			s_stLogicParamSystem.u16Quick1ActionStart[sMsg-LOGIC_SET_QUICK1_ACTIONTIME_1]= *(u16 *)pData;			LogicParamSaveProc();					return u32ReturnFlag;						}	#endif#endif/*********************************************************************************************函数名称：LogicSetQuick1ActionInterval**函数作用：逻辑层参数读写消息处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/#if (QUICK_KEY_CTRL_ENABLE_FLAG	!= DISABLED)	#if (QUICK_KEY_1_ENABLE_FLAG != DISABLED)		static u32 LogicSetQuick1ActionInterval(LOGIC_PARAM_MSG_TYPE sMsg,void *pData)		{			u32 u32ReturnFlag = 0x01;			s_stLogicParamSystem.u16Quick1ActionIng[sMsg-LOGIC_SET_QUICK1_ACTIONINTERVAL_1]= *(u16 *)pData;			LogicParamSaveProc();					return u32ReturnFlag;		}	#endif#endif/*********************************************************************************************函数名称：LogicSetQuick2EnableFalg**函数作用：逻辑层参数读写消息处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/#if (QUICK_KEY_CTRL_ENABLE_FLAG	!= DISABLED)	#if (QUICK_KEY_2_ENABLE_FLAG != DISABLED)		static u32 LogicSetQuick2EnableFalg(LOGIC_PARAM_MSG_TYPE sMsg,void *pData)		{			u32 u32ReturnFlag = 0x01;						if((*(u16 *)pData)  == ENABLED)			{				s_stLogicParamSystem.u16Quick2EnableFlag = *(u16 *)pData;				LogicParamSaveProc();					}			else if((*(u16 *)pData) == DISABLED)			{				s_stLogicParamSystem.u16Quick2EnableFlag = *(u16 *)pData;				LogicParamSaveProc();						}			else			{				u32ReturnFlag = 0x00;			}			return u32ReturnFlag;					}	#endif#endif/*********************************************************************************************函数名称：LogicSetQuick2ActionNumb**函数作用：逻辑层参数读写消息处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/#if (QUICK_KEY_CTRL_ENABLE_FLAG	!= DISABLED)	#if (QUICK_KEY_2_ENABLE_FLAG != DISABLED)		static u32 LogicSetQuick2ActionNumb(LOGIC_PARAM_MSG_TYPE sMsg,void *pData)		{			u32 u32ReturnFlag = 0x01;			if((*(u16 *)pData) <= LOGIC_QUICK_ACTIONNUMB_MAX)			{				s_stLogicParamSystem.u16Quick2ActionNumb = *(u16 *)pData;				LogicParamSaveProc();					}			else			{				u32ReturnFlag = 0x00;			}			return u32ReturnFlag;				}	#endif#endif/*********************************************************************************************函数名称：LogicSetQuick2AlaramTime**函数作用：逻辑层参数读写消息处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/#if (QUICK_KEY_CTRL_ENABLE_FLAG	!= DISABLED)	#if (QUICK_KEY_2_ENABLE_FLAG != DISABLED)		static u32 LogicSetQuick2AlaramTime(LOGIC_PARAM_MSG_TYPE sMsg,void *pData)		{			u32 u32ReturnFlag = 0x01;			s_stLogicParamSystem.u16Quick2AlaramTimer = *(u16 *)pData;			LogicParamSaveProc();					return u32ReturnFlag;				}	#endif#endif/*********************************************************************************************函数名称：LogicSetQuick2ActionName**函数作用：逻辑层参数读写消息处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/#if (QUICK_KEY_CTRL_ENABLE_FLAG	!= DISABLED)	#if (QUICK_KEY_2_ENABLE_FLAG != DISABLED)		static u32 LogicSetQuick2ActionName(LOGIC_PARAM_MSG_TYPE sMsg,void *pData)		{			u32 u32ReturnFlag = 0x01;			if((*(u16 *)pData) <= sizeof(u8LogicSupportAction))			{				s_stLogicParamSystem.u16Quick2ActionName[sMsg-LOGIC_SET_QUICK1_ACTIONNAME_1]= *(u16 *)pData;				LogicParamSaveProc();					}			else			{				u32ReturnFlag = 0x00;			}			return u32ReturnFlag;					}	#endif#endif/*********************************************************************************************函数名称：LogicSetQuick2ActionTime**函数作用：逻辑层参数读写消息处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/#if (QUICK_KEY_CTRL_ENABLE_FLAG	!= DISABLED)	#if (QUICK_KEY_2_ENABLE_FLAG != DISABLED)		static u32 LogicSetQuick2ActionTime(LOGIC_PARAM_MSG_TYPE sMsg,void *pData)		{			u32 u32ReturnFlag = 0x01;			s_stLogicParamSystem.u16Quick2ActionStart[sMsg-LOGIC_SET_QUICK1_ACTIONTIME_1]= *(u16 *)pData;			LogicParamSaveProc();					return u32ReturnFlag;						}	#endif#endif/*********************************************************************************************函数名称：LogicSetQuick2ActionInterval**函数作用：逻辑层参数读写消息处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/#if (QUICK_KEY_CTRL_ENABLE_FLAG	!= DISABLED)	#if (QUICK_KEY_2_ENABLE_FLAG != DISABLED)		static u32 LogicSetQuick2ActionInterval(LOGIC_PARAM_MSG_TYPE sMsg,void *pData)		{			u32 u32ReturnFlag = 0x01;			s_stLogicParamSystem.u16Quick2ActionIng[sMsg-LOGIC_SET_QUICK1_ACTIONINTERVAL_1]= *(u16 *)pData;			LogicParamSaveProc();					return u32ReturnFlag;		}	#endif#endif/*********************************************************************************************函数名称：LogicSetColibrateYkqIdProc**函数作用：逻辑层运行信息消息处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/#if (SET_YKQ_PRGPT_USE_FLAG != 0)	static u32 LogicSetColibrateYkqIdProc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData)	{		s_stLogicParamSystem.u16ColibrateYkqId = *(u16 *)pData ;		return 0x01;	}#endif/*********************************************************************************************函数名称：LogicSetColibrateYkqTypeProc**函数作用：逻辑层运行信息消息处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/#if (SET_YKQ_PRGPT_USE_FLAG != 0)	static u32 LogicSetColibrateYkqTypeProc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData)	{		s_stLogicParamSystem.u16ColibrateYkqType = *(u16 *)pData ;		return 0x01;	}#endif/*********************************************************************************************函数名称：LogicSetColibrateYkqStationProc**函数作用：逻辑层运行信息消息处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/#if (SET_YKQ_PRGPT_USE_FLAG != 0)	static u32 LogicSetColibrateYkqStationProc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData)	{		s_stLogicParamSystem.u16ColibrateYkqAppStation = *(u16 *)pData ;		return 0x01;	}#endif/*********************************************************************************************函数名称：LogicSetColibrateYkqVersionProc**函数作用：逻辑层运行信息消息处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/#if (SET_YKQ_PRGPT_USE_FLAG != 0)	static u32 LogicSetColibrateYkqVersionProc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData)	{		memcpy(&(s_stLogicParamSystem.u8ColibrateYkqVersion),pData,0x09);		return 0x01;			}#endif/*********************************************************************************************函数名称：LogicSetZibaoEnabledFlagProc**函数作用：逻辑层运行信息消息处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/#if (ZIBAO_CTRL_ENABLE_FLAG != DISABLED)	static u32 LogicSetZibaoEnabledFlagProc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData)	{		if((*(u16 *)pData == ENABLED) || (*(u16 *)pData == DISABLED))		{			s_stLogicParamSystem.u16ZibaoEnableFlag = *(u16 *)pData ;			LogicParamSaveProc();			return 0x01;				}		else		{			return 0x00;				}	}#endif/*********************************************************************************************函数名称：LogicSetZibaoActionMaxProc**函数作用：逻辑层运行信息消息处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/#if (ZIBAO_CTRL_ENABLE_FLAG != DISABLED)	static u32 LogicSetZibaoActionMaxProc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData)	{		s_stLogicParamSystem.u16ZibaoActionMax = *(u16 *)pData ;		LogicParamSaveProc();		return 0x01;			}#endif/*********************************************************************************************函数名称：LogicSetZibaoTimeOutProc**函数作用：逻辑层运行信息消息处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/#if (ZIBAO_CTRL_ENABLE_FLAG != DISABLED)	#if (ZIBAO_CTRL_METHOD_TYPE == ZIBAO_PARAM_CTRL_METHOD)	static u32 LogicSetZibaoTimeOutProc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData)	{		s_stLogicParamSystem.u32ZibaoTimeout = *(u32 *)pData ;		LogicParamSaveProc();				return 0x01;				}	#endif#endif/*********************************************************************************************函数名称：LogicSetZibaoActionEnableFlagProc**函数作用：逻辑层运行信息消息处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/#if (ZIBAO_CTRL_ENABLE_FLAG != DISABLED)	#if (ZIBAO_CTRL_METHOD_TYPE == ZIBAO_PARAM_CTRL_METHOD)	static u32 LogicSetZibaoActionEnableFlagProc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData)	{		if((sMsg >= LOGIC_SET_SHENGZHU_ENABLE_FLAG)\			&&(sMsg <= LOGIC_SET_QIANLIANGXIABAI_ENABLE_FLAG))		{			s_stLogicParamSystem.u8ZibaoActionEnabledFlag[sMsg-LOGIC_SET_SHENGZHU_ENABLE_FLAG] = *(u8 *) pData;			LogicParamSaveProc();		}		return 0x01;	}	#endif#endif/*********************************************************************************************函数名称：LogicSetZibaoActionIngTimeProc**函数作用：逻辑层运行信息消息处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/#if (ZIBAO_CTRL_ENABLE_FLAG != DISABLED)	#if (ZIBAO_CTRL_METHOD_TYPE == ZIBAO_PARAM_CTRL_METHOD)	static u32 LogicSetZibaoActionIngTimeProc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData)	{		if((sMsg >= LOGIC_SET_SHENGZHU_DOING_TIME)\			&&(sMsg <= LOGIC_SET_QIANLIANGXIABAI_DOING_TIME))		{			s_stLogicParamSystem.u32ZibaoActionDoingTime[sMsg-LOGIC_SET_SHENGZHU_DOING_TIME]= *(u32 *)pData;			LogicParamSaveProc();		}		return 0x01;	}	#endif#endif/*********************************************************************************************函数名称：LogicUpdataYkqPrgProc**函数作用：逻辑层运行信息消息处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/#if (ONLINE_UPDATE_SELF_PRG_PT_FLAG	!= DISABLED)	static u32 LogicUpdateYkqPrgProc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData)	{		u32 u32Y;		YKQUpdateStatus = *(u32 *)pData;		if(g_u32ID != B_type)			WirelessChipPwrOn();		u32Y = LOGIC_STAUTS_RFID_TRANS_PRG0;		LogicRunInfApi(LOGIC_SET_RUN_STATUS,&u32Y);		return 0x01;	}#endif/*********************************************************************************************函数名称：LogicStatusRfidTransPrg0Proc**函数作用：逻辑层运行信息消息处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/	static u32 LogicStatusRfidTransPrg0Proc(){		u32 u32Temp = 0x01;		u16 u16CrcTemp = 0x00;			u32 u32Temp2 = 0x00;		#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */			OS_CPU_SR  cpu_sr = 0;		#endif				#ifdef IWDG_ENABLED			IWDG_Feed();		#endif				/**先判断程序的正确性**/		s_u32DownProgramType	= THE_DEV_TYPE;			/**判断外扩FLASH中是否有程序**/		if(IapGetPrgStorageAddr(s_u32DownProgramType, &s_u32DownProgAddr) != 0x01)//读取外扩中的基地址		u32Temp = 0x00;				/**计算版本信息的CRC***/		u16CrcTemp = 0x00;		u16CrcTemp = IapExFlashCrc(s_u32DownProgAddr,PROG_VER_CRCL_OFFSET_ADDRESS);		IapReadBuf((u8 *)&u32Temp2,s_u32DownProgAddr+PROG_VER_CRCL_OFFSET_ADDRESS,0x04);		u32Temp = (u32)u16CrcTemp;		if(u32Temp != u32Temp2)			u32Temp = 0x00;		/**读取下载完成标志**/		if((s_u32DownProgramType == THE_DEV_TYPE))		{			IapReadBuf((u8 *)&u32Temp,APP_DOWNLOAD_OFFSET_ADDRESS,0x04);//下载完成标志			if(u32Temp != RROG_DOWNLOAD_FLAG)//无下载完成标志			{				u32Temp = 0x00;			}		}				//读取文件长度		if(IapGetPrgSize(s_u32DownProgramType, &u32Temp2) != 0x01)//读取外扩中的文件最大长度			u32Temp = 0x00;				IapReadBuf((u8 *)&s_u32DownProgLength,s_u32DownProgAddr+PROG_LENGTH_OFFSET_ADDRESS,0x04);//实际长度		if((s_u32DownProgLength > u32Temp2)||(s_u32DownProgLength == 0xFFFFFFFF) || (s_u32DownProgLength == 0x00))//长度不正确		{			u32Temp = 0x00;		}		LcdClear();						/**此处增加提示讯息**/		if(u32Temp == 0x00)		{			LcdClear();					ShowStr(0, "无程序", 2,40); 			OSTaskSuspend(INTERFACE_TASK_PRIO);				OSTimeDly(2000/TICK_TIME);			OSTaskResume(INTERFACE_TASK_PRIO);						u32Temp = LOGIC_STATUS_IDLE;			LogicRunInfApi(LOGIC_SET_RUN_STATUS,&u32Temp);			InterfaceInsertNote(INTERFACE_NOTE_SYSTEM_IDLE);				InterfaceSetCtrlMode(INTERFACE_MODE_IDLE);			InterfaceSetUpdateMainMethod(INTERFACE_SHOW_MAIN_ALL);			OSSemPost(g_stSemInterface);			return 0x00;		}				//计算程序的CRC，此处增加LCD屏状态显示，防止等待时间过长		LcdClear();										ShowStr(0, "更新遥控器程序", 1,8); 														 		ShowStr(0, "检测文件,稍候", 3, 12);		#ifdef IWDG_ENABLED			IWDG_Feed();		#endif		u16CrcTemp = 0x00;		u16CrcTemp = IapExFlashCrc(s_u32DownProgAddr+PROG_CODE_OFFSET_ADDRESS,s_u32DownProgLength);		IapReadBuf((u8 *)&u32Temp2,s_u32DownProgAddr+PROG_CRCL_OFFSET_ADDRESS,0x04);//CRC		u32Temp = (u32)u16CrcTemp;		if(u32Temp != u32Temp2)		{			LcdClear();					ShowStr(0, "无程序", 2,40); 			OSTaskSuspend(INTERFACE_TASK_PRIO);				OSTimeDly(2000/TICK_TIME);			OSTaskResume(INTERFACE_TASK_PRIO);						u32Temp = LOGIC_STATUS_IDLE;			LogicRunInfApi(LOGIC_SET_RUN_STATUS,&u32Temp);			InterfaceInsertNote(INTERFACE_NOTE_SYSTEM_IDLE);				InterfaceSetCtrlMode(INTERFACE_MODE_IDLE);			InterfaceSetUpdateMainMethod(INTERFACE_SHOW_MAIN_ALL);			OSSemPost(g_stSemInterface);					return 0x00;		}		/**无论传输的何种设备的程序，以擦除相关区域的最大时间进行估计***/		if ((s_u32DownProgramType== SS_DEV_TYPE)|| (s_u32DownProgramType == SC_DEV_TYPE))//支架控制器硬件，计算区域大小			s_u32SendInterval = THE_DYK_DEV_STORAGE_SIZEMAX;		else	//其他设备，按照最大值HUB程序的大小进行计算			s_u32SendInterval = THE_DEV_PRG_STORAGE_SIZE;		if(s_u32SendInterval%THE_DEV_PRG_BULK_SIZE)		{			s_u32SendInterval /= THE_DEV_PRG_BULK_SIZE;						s_u32SendInterval += 0x01;		}		else			s_u32SendInterval /= THE_DEV_PRG_BULK_SIZE;				s_u32SendInterval *= FLASH_BULK_ERASER_TIME;		/*计算总共需要多少时间*/		IapReadBuf((u8 *)&u32Temp, s_u32DownProgAddr|PROG_LENGTH_OFFSET_ADDRESS, 0x04);//代码长度		/*计算总共需要多少时间*///		InterfaceSetDownloadRemainTimer(((u32Temp/100) * TRANS_RECV_PRG_HUNDRED_BYTES_TIME*TRANS_PROG_TIMES)+s_u32SendInterval);//bug显示收发时间不一致		InterfaceSetDownloadRemainTimer(((u32Temp/100) * TRANS_RECV_PRG_HUNDRED_BYTES_TIME*TRANS_PROG_TIMES));				/**进行更新自身或本地***/			if( YKQUpdateStatus == YKQ_UPDATE_PRG_SELF)		{			u32Temp = YKQ_SHUTDOWN_NO_SLEEP;			LogicParamApi(LOGIC_SET_SHUTDOWM_FLAG,&u32Temp);						#ifdef IWDG_ENABLED				IWDG_Feed();			#endif						OSTaskSuspend(INTERFACE_TASK_PRIO);			StateLed(0x00,ADJUST_CODE_ING_LED|ADJUST_CODE_SUCCEED_LED|KEY_SHIFT_LED);			KeyLedOnOff(0x00,KEY_LED_ALL);						LcdAreaClear(OLED_DISPLAY_NORMAL,6,0,7,127);			ShowStr(OLED_DISPLAY_NORMAL,"即将重启",6, 32);			OSTimeDly(2000/TICK_TIME);						#ifdef IWDG_ENABLED				IWDG_Feed();			#endif							if(g_u32ID != B_type)			{				OSTaskSuspend(USART_TASK_PRIO);			}			OSTaskSuspend(IRMNG_TASK_PRIO);			OSTaskSuspend(RFIDMNG_TASK_PRIO);									OSTaskSuspend(SCAN_KEY_TASK_PRIO);			OSTaskSuspend(BATTERYMNG_TASK_PRIO);			#if (YKQ_HARDWARE_BEEP_EXIST_DEFINE != DISABLED)				OSTaskSuspend(BUZZERMNG_TASK_PRIO);			#endif						#if (BSP_PRG_STORAGE_FLASH_FLAG	==	BSP_PRG_STORAGE_INFLASH_USE)				__disable_fault_irq();				FLASH_SetLatency(THE_DEV_FLASH_Latency);//120 MHz< HCLK <= 168 MHz				FLASH_Unlock();						#endif						IapEraserSector(MY_DEV_TYPE_ADDRESS);			IapReadBuf((u8 *)&u32Temp,THE_DEV_PRG_STORAGE_BASEADDR+PROG_WRITE_BASE_ADDRESS,0x04);			IapWriteBuf((u8 *)&u32Temp, APP_WRITE_BASEADDRESS, 0x04);			IapWriteBuf((u8 *)&u32Temp, APP_WRITE_BASEADDRESS, 0x04);						IapReadBuf((u8 *)&u32Temp,THE_DEV_PRG_STORAGE_BASEADDR+PROG_DEVTYPE_OFFSET_ADDRESS,0x04);			IapWriteBuf((u8 *)&u32Temp, MY_DEV_TYPE_ADDRESS, 0x04);			IapWriteBuf((u8 *)&u32Temp, MY_DEV_TYPE_ADDRESS, 0x04);						u32Temp = RROG_DOWNLOAD_FLAG;			IapWriteBuf((u8 *)&u32Temp, APP_DOWNLOAD_OFFSET_ADDRESS, 0x04);			IapWriteBuf((u8 *)&u32Temp, APP_DOWNLOAD_OFFSET_ADDRESS, 0x04);						u32Temp = RROG_UPDATE_FLAG;			IapWriteBuf((u8 *)&u32Temp, APP_UPDATE_OFFSET_ADDRESS, 0x04);				IapWriteBuf((u8 *)&u32Temp, APP_UPDATE_OFFSET_ADDRESS, 0x04);						//写入版本信息			u32Temp = (Version[8]-0x30)|(((Version[6]-0x30)+(Version[5]-0x30)*10)<<8)|((Version[3]-0x30)<<16)|((Version[1]-0x30)<<24);				IapWriteBuf((u8 *)&u32Temp, APP_VERSION_ADDRESS, 0x04);				IapWriteBuf((u8 *)&u32Temp, APP_VERSION_ADDRESS, 0x04);			#if (BSP_PRG_STORAGE_FLASH_FLAG	==	BSP_PRG_STORAGE_INFLASH_USE)				FLASH_Lock();				__enable_fault_irq();						#endif							#ifdef IWDG_ENABLED				IWDG_Feed();			#endif			//进行程序的跳转,跳至BOOTLOADER			IapJumpToBoot(IN_FLASH_BOOTLOADER_ADDR);		}		else if(YKQUpdateStatus == YKQ_UPDATE_PRG_ALL)		{			u32Temp = LOGIC_STATUS_RFID_TRANS_PRG;			LogicRunInfApi(LOGIC_SET_RUN_STATUS,&u32Temp);			InterfaceInsertNote(INTERFACE_NOTE_PLEASE_DONOT_MOVE);			InterfaceSetCtrlMode(INTERFACE_MODE_TRANS_PRG);			InterfaceSetUpdateMainMethod(INTERFACE_SHOW_MAIN_ALL);			OSSemPost(g_stSemInterface);			StateLed(0x00,KEY_SHIFT_LED|ADJUST_CODE_SUCCEED_LED|ADJUST_CODE_ING_LED);			KeyLedOnOff(0x00,KEY_LED_MAX);						OSTaskDel(RFIDMNG_TASK_PRIO);			if(g_u32ID != B_type)				OSTaskSuspend(USART_TASK_PRIO);						OSTaskSuspend(IRMNG_TASK_PRIO);				s_u32DestDevID = 0x00;//广播帧			s_u32SendInterval = 0x00;			s_u32DownProgSendPacketNumb	= 0x00;								/**无线更新处理任务**/											//重新初始化RFID和post信号量地址		if(g_u32ID == B_type)		{			OS_ENTER_CRITICAL();				RFID_Init(RFID_PRG_ININT_SYNC0,RFID_PRG_ININT_SYNC1);			RfidMngSetRecvCallBack();			OS_EXIT_CRITICAL();		}		else		{			SendSetupToWl(RFID_PRG_ININT_SYNC1);		}			/**无线更新程序处理任务**/			#if (ONLINE_UPDATE_SELF_PRG_PT_FLAG	!= DISABLED)				RfidUpdateMngInint();				OSTaskCreate(RfidMng_Update_Task, (void *)0, &RfidMng_task_stk[RFIDMNG_UPDATE_TASK_STK_SIZE - 1], RFIDMNG_UPDATE_TASK_PRIO); 			#endif						}		else			;		return 0x01;}/*********************************************************************************** 函数名称: LogicUpdateWLPrgProc** 功能描述：RFID无线发送程序信息** 函数输入：无** 函数输出：1:成功发送，2:停止键按下** 注意事项：**********************************************************************************/static u32 LogicUpdateWLPrgProc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData){		u32 u32Y;	YKQUpdateStatus = *(u32 *)pData;	if(g_u32ID != B_type)		WirelessChipPwrOn();	u32Y = LOGIC_STATUS_RFID_RECV_WL_PRG;	LogicRunInfApi(LOGIC_SET_RUN_STATUS,&u32Y);		return 0x01;}	/*********************************************************************************** 函数名称: RfidUpdateSendPrgData** 功能描述：RFID无线发送程序信息** 函数输入：无** 函数输出：1:成功发送，2:停止键按下** 注意事项：**********************************************************************************/u32 RfidUpdateSendPrg(u8 u8DevID,u32 u32FrameType,u32 u32PacketNumb,u8 *data,u32 u32DataLength){	RFID_UPDATE_FRAME_TYPE s_stRfidSendPacket;	u32 u32ReturnFlag = 0x01;	u32 u32SendLength = 0x00;	u32 u32DelayTime = 0x00;		#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */		OS_CPU_SR  cpu_sr = 0;	#endif		OS_ENTER_CRITICAL();	s_stRfidSendPacket.u32ID.ID.FrameType = u32FrameType;// 	s_stRfidSendPacket.u32ID.ID.SDL = (0x20&0xFF);	s_stRfidSendPacket.u32ID.ID.Reservd = 0x00;			s_stRfidSendPacket.u8DT[0x00] = 0x01;	s_stRfidSendPacket.u8DT[0x01] =  u32PacketNumb&0x00FF ;	s_stRfidSendPacket.u8DT[0x02] =  (u32PacketNumb&0xFF00)>>8;	if(u32DataLength > (sizeof(s_stRfidSendPacket.u8DT)-0x03))		u32DataLength = (sizeof(s_stRfidSendPacket.u8DT)-0x03);	memmove(&(s_stRfidSendPacket.u8DT[0x03]),data,u32DataLength);		s_stRfidSendPacket.u8DLC = u32DataLength+0x03;	/**发送数据**/	u32SendLength = s_stRfidSendPacket.u8DLC+0x04+0x01;	/**每一数据均要延时一定的时间，且发送两次*/	OS_EXIT_CRITICAL();			u32DelayTime = 7;	while(u32DelayTime)	{		OSTimeDly(100/10);		u32DelayTime--;	}		if(g_u32ID != B_type)	{		memset(u8tmp_Logic,0x00,u32SendLength+1);		u8tmp_Logic[0] = u8DevID;		memcpy(&u8tmp_Logic[1],(u8 *)&(s_stRfidSendPacket.u32ID),u32SendLength);				InsUsartTrsQueue(u8tmp_Logic,u32SendLength+1,WIRELESSDATA,NOACK,1);	}	else	{		RFID_SendData(u8DevID,(u8 *)&(s_stRfidSendPacket.u32ID),&u32SendLength);	}//	u32DelayTime = 7;//	while(u32DelayTime)//	{//		OSTimeDly(100/10);//		u32DelayTime--;//	}		return u32ReturnFlag;		}/*********************************************************************************************函数名称：LogicUpdataYkqPrgProc**函数作用：逻辑层运行信息消息处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/static u32 LogicUpdateCxbWLPrgProc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData){		u32 u32Y;	if(g_u32ID != B_type)			WirelessChipPwrOn();	YKQUpdateStatus = *(u32 *)pData;//	LogicParamApi(LOGIC_SET_UPDATE_STATUS,&pData);	u32Y = LOGIC_STATUS_RFID_CXB_RECV_WL_PRG;	LogicRunInfApi(LOGIC_SET_RUN_STATUS,&u32Y);		return 0x01;	}/*********************************************************************************************函数名称：LogicUpdataYkqPrgProc**函数作用：逻辑层运行信息消息处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/	u32 LogicUpdateCxbPrgProc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData){	u32 u32Y;	YKQUpdateStatus = *(u32 *)pData;		if(g_u32ID != B_type)		WirelessChipPwrOn();	u32Y = LOGIC_STATUS_RFID_CXB_RECV_PRG;	LogicRunInfApi(LOGIC_SET_RUN_STATUS,&u32Y);		return 1;}/*********************************************************************************************函数名称：LogicUpdataYkqPrgProc**函数作用：配置文件同步请求**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************///zzw	u32 LogicActionInfoSynchroProc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData){	u32 u32Y;	YKQUpdateStatus = *(u32 *)pData;		if(g_u32ID != B_type)		WirelessChipPwrOn();	u32Y = LOGIC_STATUS_RFID_CXB_RECV_PRG;	LogicRunInfApi(LOGIC_SET_RUN_STATUS,&u32Y);		return 1;}		/**以下为对应运行信息的设置和读取***//*********************************************************************************************函数名称：LogicSetColibrateScTypeProc**函数作用：逻辑层运行信息消息处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/static u32 LogicSetColibrateScTypeProc(void *pData){	s_stLogicRunInf.u16ColibarateType = *(u16 *)pData ; 		return 0x01;}/*********************************************************************************************函数名称：LogicSetScNumbDirectProc**函数作用：逻辑层运行信息消息处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/static u32 LogicSetScNumbDirectProc(void *pData){	s_stLogicRunInf.u16ScNumbAddDirc = *(u16 *)pData;		return 0x01;}/*********************************************************************************************函数名称：LogicSetColibrateScNumbProc**函数作用：逻辑层运行信息消息处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/static u32 LogicSetColibrateScNumbProc(void *pData){	s_stLogicRunInf.u16ScNumbColibarated = *(u16 *)pData ;		return 0x01;}//zzw/*********************************************************************************************函数名称：LogicSetActionInfoCrc**函数作用：设置配置文件crc一致或不一致**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/static u32 LogicSetActionInfoCrc(void *pData){	s_stLogicRunInf.u8ActionInfoCrcIdentical = *(u16 *)pData ;		return 0x01;}//zzw/*********************************************************************************************函数名称：LogicSetActionInfoCrc**函数作用：设置配置文件crc一致或不一致**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/static u32 LogicGetActionInfoCrc(void *pData){	*(u16 *)pData =  s_stLogicRunInf.u8ActionInfoCrcIdentical ;		return 0x01;}static u32 LogicActionInfoSynchroReq(void *pData){	LogicStatusActionInfoReqProc();	return 1;}/*********************************************************************************************函数名称：LogicSetCtrlScNumbProc**函数作用：逻辑层运行信息消息处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/static u32 LogicSetCtrlScNumbProc(void *pData){	u32 u32K;#if 0	//zzw	if(s_stLogicRunInf.stLogicRunStatus == LOGIC_STATUS_RFID_SC_NEIGHBORL)	{		if(s_stLogicRunInf.u16ScNumbAddDirc == SC_DIRCT_LEFT)			{			if(((u32)s_stLogicRunInf.u32ScActionName  == RFID_STATUS_NEIGHBOR_LEFT)&&(s_stLogicRunInf.sRfidFrameType == RFID_FRAME_STATUS))			{				if(s_stLogicRunInf.u16ScNumbColibarated-s_stLogicRunInf.u16ScNeigborControled == 1)//jhy					s_stLogicRunInf.u16ScNeigborControled+=2;				else				{					s_stLogicRunInf.u16ScNeigborControled++;				}				if(s_stLogicRunInf.u16ScNeigborControled == LOGIC_SC_NUMB_MAX)					s_stLogicRunInf.u16ScNeigborControled = LOGIC_SC_NUMB_MAX-0x01;			}			else if(((u32)s_stLogicRunInf.u32ScActionName  == RFID_STATUS_NEIGHBOR_RIGHT)&&(s_stLogicRunInf.sRfidFrameType == RFID_FRAME_STATUS))			{				if(s_stLogicRunInf.u16ScNeigborControled > 2)//jhy				{					if(s_stLogicRunInf.u16ScNeigborControled - s_stLogicRunInf.u16ScNumbColibarated == 1)						s_stLogicRunInf.u16ScNeigborControled-=2;					else						s_stLogicRunInf.u16ScNeigborControled--;				}				else if(s_stLogicRunInf.u16ScNeigborControled > 1)					s_stLogicRunInf.u16ScNeigborControled--;			}			else				;		}		else		{			if(((u32)s_stLogicRunInf.u32ScActionName  == RFID_STATUS_NEIGHBOR_LEFT)&&(s_stLogicRunInf.sRfidFrameType == RFID_FRAME_STATUS))			{				if(s_stLogicRunInf.u16ScNeigborControled > 2)//jhy				{					if(s_stLogicRunInf.u16ScNeigborControled - s_stLogicRunInf.u16ScNumbColibarated == 1)						s_stLogicRunInf.u16ScNeigborControled-=2;					else						s_stLogicRunInf.u16ScNeigborControled--;				}				else if(s_stLogicRunInf.u16ScNeigborControled > 1)					s_stLogicRunInf.u16ScNeigborControled--;			}			else if(((u32)s_stLogicRunInf.u32ScActionName  == RFID_STATUS_NEIGHBOR_RIGHT)&&(s_stLogicRunInf.sRfidFrameType == RFID_FRAME_STATUS))			{				if(s_stLogicRunInf.u16ScNumbColibarated-s_stLogicRunInf.u16ScNeigborControled == 1)//jhy					s_stLogicRunInf.u16ScNeigborControled+=2;				else				{					s_stLogicRunInf.u16ScNeigborControled++;				}				if(s_stLogicRunInf.u16ScNeigborControled == LOGIC_SC_NUMB_MAX)					s_stLogicRunInf.u16ScNeigborControled = LOGIC_SC_NUMB_MAX-0x01;							}			else				;					}	}	else#endif//		//隔架架数最大为5，在这儿增加限制，增加邻架控制帧，因此去掉限制//		LogicRunInfApi(LOGIC_GET_CONLIBRATE_SC_NUMB,&u32K);//		u32K = u32K & 0xff;//		if(u32K > *(u16 *)pData)//			u32K = u32K -  *(u16 *)pData;//		else//			u32K = *(u16 *)pData - u32K;//		if(u32K <= NEIGBOR_CONTR_MAX)		s_stLogicRunInf.u16ScNeigborControled = *(u8 *)pData ;		return 0x01;}/*********************************************************************************************函数名称：LogicSetRfidFrameTypeProc**函数作用：逻辑层运行信息消息处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/static u32 LogicSetRfidFrameTypeProc(void *pData){	s_stLogicRunInf.sRfidFrameType =  *(RFID_FRAME_TYPE *)pData ;		return 0x01;}/*********************************************************************************************函数名称：LogicSetScActionNameProc**函数作用：逻辑层运行信息消息处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/static u32 LogicSetScActionNameProc(void *pData){	s_stLogicRunInf.u32ScActionName = *(u32 *)pData ;		return 0x01;}/*********************************************************************************************函数名称：LogicSetGrpDirectionProc**函数作用：逻辑层运行信息消息处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/static u32 LogicSetGrpDirectionProc(void *pData){	s_stLogicRunInf.stGrpActionDirection = *(SC_GRP_DIRECTION_TYPE *)pData ;		return 0x01;}/*********************************************************************************************函数名称：LogicSetGrpAckActionNameProc**函数作用：逻辑层运行信息消息处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/static u32 LogicSetGrpAckActionNameProc(void *pData){	s_stLogicRunInf.stGrpActionAckName = *(RFID_GRP_ACTION_TYPE *)pData ;		return 0x01;	}/*********************************************************************************************函数名称：LogicSetGrpNearScNumbProc**函数作用：逻辑层运行信息消息处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/static u32 LogicSetGrpNearScNumbProc(void *pData){	s_stLogicRunInf.u16GrpNearScNumb = *(u16  *)pData ;		return 0x01;	}/*********************************************************************************************函数名称：LogicSetGrpRemoteScNumbProc**函数作用：逻辑层运行信息消息处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/static u32 LogicSetGrpRemoteScNumbProc(void *pData){	s_stLogicRunInf.u16GrpRemoteScNumb = *(u16  *)pData ;		return 0x01;	}/*********************************************************************************************函数名称：LogicSetRunStatusProc**函数作用：逻辑层运行信息消息处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/static u32 LogicSetRunStatusProc(void *pData){	s_stLogicRunInf.stLogicRunStatus = *(LOGIC_RUN_STATUS_TYPE *)pData ;		return 0x01;}/*********************************************************************************************函数名称：LogicSetButtonDownProc**函数作用：逻辑层运行信息消息处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/static u32 LogicSetButtonDownProc(void *pData){	s_stLogicRunInf.CommandActionValue = *(COMMAND_ACTION *)pData;	//将需要发送的数据填入RFID数组	RfidMngSendDataKeyDown(s_stLogicRunInf.CommandActionValue.ActionType.type,\					s_stLogicRunInf.CommandActionValue.ActionID,\					s_stLogicRunInf.CommandActionValue.OrderActionOrResult);	return 0x01;}/*********************************************************************************************函数名称：LogicSetButtonDownAckProc**函数作用：逻辑层运行信息消息处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/static u32 LogicSetButtonDownAckProc(void * pData){	s_stLogicRunInf.CommandActionAckValue = *(COMMAND_ACTION *)pData ;		return 0x01;}/*********************************************************************************************函数名称：LogicSetButtonStatusProc**函数作用：逻辑层运行信息消息处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/static u32 LogicSetButtonStatusProc(void * pData){	s_stLogicRunInf.stButtonStatus = *(SC_BUTTON_TYPE *)pData ;		return 0x01;}/*********************************************************************************************函数名称：LogicSetButtonLongDownProc**函数作用：逻辑层运行信息消息处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/static u32 LogicSetButtonLongDownProc(void * pData){	s_stLogicRunInf.u32ButtonLongValue = *(SC_BUTTON_TYPE *)pData ;	RfidMngSendDataKeyLongDown((RFID_FRAME_TYPE)(((*(u64 *)pData)&0xC000000000000000)>>62),*(u64 *)pData);	return 0x01;}/*********************************************************************************************函数名称：LogicSetButtonUpProc**函数作用：逻辑层运行信息消息处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/static u32 LogicSetButtonUpProc(void * pData){	s_stLogicRunInf.u64ButtonUpValue = *(SC_BUTTON_TYPE *)pData ;	RfidMngSendDataKeyUp((RFID_FRAME_TYPE)(((*(u64 *)pData)&0xC000000000000000)>>62),*(u64 *)pData);	return 0x01;}/*********************************************************************************************函数名称：LogicSetCtrlScNumbProc**函数作用：逻辑层消息处理列表**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/static u32 LogicSetScActionTypeProc(void * pData){	s_stLogicRunInf.u32ScActionType = *(u32 *)pData ;	return 0x01;}/*********************************************************************************************函数名称：LogicSetCtrlScNumbProc**函数作用：逻辑层消息处理列表**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/static u32 LogicSetScGejiaNumberProc(void * pData){	s_stLogicRunInf.u32ScGejiaNumber = *(u32 *)pData ;	return 0x01;}/*********************************************************************************************函数名称：LogicSetScQuickTypeProc**函数作用：逻辑层运行信息消息处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/#if (QUICK_KEY_CTRL_ENABLE_FLAG != 0)	static u32 LogicSetScQuickTypeProc(void *pData)	{		u32 u32ReturnFlag = 0x00;		u32 u32I = 0x00;		u16 u16TimeStart = 0xFFFF;		u32 u32J = 0x00,u32Temp = 0x00;		u32 u32TempAddr = 0x00;		INTERFACE_ACTION_TYPE sActionThirdName[INTERFACE_KEY_TOGETHER_MAX] = {INTERFACE_ACTION_NONE,INTERFACE_ACTION_NONE};				if( *(u32 *)pData != SC_ACTION_QUICK_MAX)			s_stLogicRunInf.u32ScQuickActionType = *(INTERFACE_ACTION_TYPE *)pData ;		else			u32ReturnFlag = 0x00;				if(s_stLogicRunInf.u32ScQuickActionType == SC_ACTION_QUICK_STOP)		{			s_stLogicRunInf.u32ScQuickActionTimer = 0x00;			u32ReturnFlag =  0x01;		}		else if(s_stLogicRunInf.u32ScQuickActionType == SC_ACTION_QUICK_1)		{			s_stLogicRunInf.u32ScQuickActionTimer  = 0x00;			if(s_stLogicParamSystem.u16Quick1EnableFlag == ENABLED)			{				for(u32I = 0x00;u32I < s_stLogicParamSystem.u16Quick1ActionNumb; u32I++)				{					if(sActionThirdName[0x01])						break;									if((s_stLogicParamSystem.u16Quick1ActionName[u32I] != 0x00) && (s_stLogicParamSystem.u16Quick1ActionIng[u32I] != 0x00))					{						if(InterfaceGetActionNameNumb(u8LogicSupportAction[s_stLogicParamSystem.u16Quick1ActionName[u32I]],&u32Temp))						{							if(u16TimeStart == s_stLogicParamSystem.u16Quick1ActionStart[u32I])							{								u16TimeStart = s_stLogicParamSystem.u16Quick1ActionStart[u32I];								if(u32TempAddr < INTERFACE_KEY_TOGETHER_MAX)								{									*((INTERFACE_ACTION_TYPE*)pData+u32TempAddr) = (INTERFACE_ACTION_TYPE)u32Temp;									u32TempAddr++;								}								else								{									if(sActionThirdName[0x00] == INTERFACE_ACTION_NONE)										sActionThirdName[0x00] = (INTERFACE_ACTION_TYPE)u32Temp;									else										sActionThirdName[0x01] = (INTERFACE_ACTION_TYPE)u32Temp;								}								u32ReturnFlag = (u32)(INTERFACE_NOTE_ACTION_ING);								u32J = u32I;							}							else if(u16TimeStart > s_stLogicParamSystem.u16Quick1ActionStart[u32I])									{								u16TimeStart = s_stLogicParamSystem.u16Quick1ActionStart[u32I];								u32TempAddr = 0x00;								*(((INTERFACE_ACTION_TYPE *)pData)+u32TempAddr) = (INTERFACE_ACTION_TYPE)u32Temp;								u32TempAddr++;								sActionThirdName[0x00] = INTERFACE_ACTION_NONE;								sActionThirdName[0x01] = INTERFACE_ACTION_NONE;								u32ReturnFlag = (u32)(INTERFACE_NOTE_ACTION_ING);								u32J = u32I;															}								else								;						}					}				}						if((s_stLogicParamSystem.u16Quick1ActionStart[u32J] != 0x00) && (u16TimeStart != 0xFFFF))				{					u32ReturnFlag = (u32)(INTERFACE_NOTE_ACTION_ALARAM);				}				else if(u16TimeStart== 0xFFFF)				{					u32ReturnFlag = 0x00;				}				else					;			}			else			{				u32ReturnFlag = 0x00;			}			}		else if(s_stLogicRunInf.u32ScQuickActionType == SC_ACTION_QUICK_2)		{			s_stLogicRunInf.u32ScQuickActionTimer  = 0x00;			if(s_stLogicParamSystem.u16Quick2EnableFlag == ENABLED)			{				for(u32I = 0x00;u32I < s_stLogicParamSystem.u16Quick2ActionNumb; u32I++)				{					if(sActionThirdName[0x01])						break;									if((s_stLogicParamSystem.u16Quick2ActionName[u32I] != 0x00) && (s_stLogicParamSystem.u16Quick1ActionIng[u32I] != 0x00))					{						if(InterfaceGetActionNameNumb(u8LogicSupportAction[s_stLogicParamSystem.u16Quick1ActionName[u32I]],&u32Temp))						{							if(u16TimeStart == s_stLogicParamSystem.u16Quick1ActionStart[u32I])							{								u16TimeStart = s_stLogicParamSystem.u16Quick1ActionStart[u32I];								if(u32TempAddr < INTERFACE_KEY_TOGETHER_MAX)								{									*(((INTERFACE_ACTION_TYPE *)pData)+u32TempAddr) = (INTERFACE_ACTION_TYPE)u32Temp;									u32TempAddr++;								}								else								{									if(sActionThirdName[0x00] == INTERFACE_ACTION_NONE)										sActionThirdName[0x00] = (INTERFACE_ACTION_TYPE)u32Temp;									else										sActionThirdName[0x01] = (INTERFACE_ACTION_TYPE)u32Temp;								}								u32ReturnFlag = (u32)(INTERFACE_NOTE_ACTION_ING);								u32J = u32I;							}							else if(u16TimeStart > s_stLogicParamSystem.u16Quick1ActionStart[u32I])									{								u16TimeStart = s_stLogicParamSystem.u16Quick1ActionStart[u32I];								u32TempAddr = 0x00;								*(((INTERFACE_ACTION_TYPE *)pData)+u32TempAddr) = (INTERFACE_ACTION_TYPE)u32Temp;								u32TempAddr++;								sActionThirdName[0x00] = INTERFACE_ACTION_NONE;								sActionThirdName[0x01] = INTERFACE_ACTION_NONE;								u32ReturnFlag = (u32)(INTERFACE_NOTE_ACTION_ING);								u32J = u32I;															}							else								;						}					}				}						if((s_stLogicParamSystem.u16Quick2ActionStart[u32J] != 0x00) && (u16TimeStart != 0xFFFF))				{					u32ReturnFlag = (u32)(INTERFACE_NOTE_ACTION_ALARAM);					*(u32 *)pData = 0x00;				}				else if(u16TimeStart == 0xFFFF)				{					u32ReturnFlag = 0x00;					*(u32 *)pData = 0x00;				}					else					;			}		}		else			;		/**过滤掉其中一样的数据**/		if(*((INTERFACE_ACTION_TYPE *)pData) == *(((INTERFACE_ACTION_TYPE *)pData)+0x01))			*(((INTERFACE_ACTION_TYPE *)pData)+0x01) = INTERFACE_ACTION_NONE;		if(*((INTERFACE_ACTION_TYPE*)pData) == sActionThirdName[0x00])			sActionThirdName[0x00] = INTERFACE_ACTION_NONE;		if(*((INTERFACE_ACTION_TYPE*)pData) == sActionThirdName[0x01])			sActionThirdName[0x01] = INTERFACE_ACTION_NONE;		if( *(((INTERFACE_ACTION_TYPE *)pData)+0x01) == sActionThirdName[0x00] )			sActionThirdName[0x00] = INTERFACE_ACTION_NONE;		if( *(((INTERFACE_ACTION_TYPE *)pData)+0x01) == sActionThirdName[0x01] )			sActionThirdName[0x01] = INTERFACE_ACTION_NONE;		if(sActionThirdName[0x00] == sActionThirdName[0x01] )			sActionThirdName[0x01] = INTERFACE_ACTION_NONE;				/**对前后柱进行合并**/		if(*((INTERFACE_ACTION_TYPE *)pData) == INTERFACE_ACTION_JIANG_QIANZHU)			{			if(*(((INTERFACE_ACTION_TYPE *)pData)+0x01) == INTERFACE_ACTION_JIANG_HOUZHU)			{				*((INTERFACE_ACTION_TYPE *)pData) = INTERFACE_ACTION_JIANG_ZHU;				*(((INTERFACE_ACTION_TYPE *)pData)+0x01) = INTERFACE_ACTION_NONE;			}				if(sActionThirdName[0x00] == INTERFACE_ACTION_JIANG_HOUZHU)			{				*((INTERFACE_ACTION_TYPE *)pData) = INTERFACE_ACTION_JIANG_ZHU;				sActionThirdName[0x00] = INTERFACE_ACTION_NONE;			}				if(sActionThirdName[0x01] == INTERFACE_ACTION_JIANG_HOUZHU)			{				*((INTERFACE_ACTION_TYPE *)pData) = INTERFACE_ACTION_JIANG_ZHU;				sActionThirdName[0x01] = INTERFACE_ACTION_NONE;			}						}		if(*((INTERFACE_ACTION_TYPE *)pData) == INTERFACE_ACTION_JIANG_HOUZHU)			{			if(*(((INTERFACE_ACTION_TYPE *)pData)+0x01) == INTERFACE_ACTION_JIANG_QIANZHU)			{				*((INTERFACE_ACTION_TYPE *)pData) = INTERFACE_ACTION_JIANG_ZHU;				*(((INTERFACE_ACTION_TYPE *)pData)+0x01) = INTERFACE_ACTION_NONE;			}				if(sActionThirdName[0x00] == INTERFACE_ACTION_JIANG_QIANZHU)			{				*((INTERFACE_ACTION_TYPE *)pData) = INTERFACE_ACTION_JIANG_ZHU;				sActionThirdName[0x00] = INTERFACE_ACTION_NONE;			}				if(sActionThirdName[0x01] == INTERFACE_ACTION_JIANG_QIANZHU)			{				*((INTERFACE_ACTION_TYPE *)pData) = INTERFACE_ACTION_JIANG_ZHU;				sActionThirdName[0x01] = INTERFACE_ACTION_NONE;			}						}		if(*((INTERFACE_ACTION_TYPE *)pData) == INTERFACE_ACTION_JIANG_QIANZHU)			{			if(*(((INTERFACE_ACTION_TYPE *)pData)+0x01) == INTERFACE_ACTION_JIANG_HOUZHU)			{				*((INTERFACE_ACTION_TYPE *)pData) = INTERFACE_ACTION_JIANG_ZHU;				*(((INTERFACE_ACTION_TYPE *)pData)+0x01) = INTERFACE_ACTION_NONE;			}				if(sActionThirdName[0x00] == INTERFACE_ACTION_JIANG_HOUZHU)			{				*((INTERFACE_ACTION_TYPE *)pData) = INTERFACE_ACTION_JIANG_ZHU;				sActionThirdName[0x00] = INTERFACE_ACTION_NONE;			}				if(sActionThirdName[0x01] == INTERFACE_ACTION_JIANG_HOUZHU)			{				*((INTERFACE_ACTION_TYPE *)pData) = INTERFACE_ACTION_JIANG_ZHU;				sActionThirdName[0x01] = INTERFACE_ACTION_NONE;			}						}		if(*(((INTERFACE_ACTION_TYPE *)pData)+0x01) == INTERFACE_ACTION_JIANG_HOUZHU)			{			if(sActionThirdName[0x00] == INTERFACE_ACTION_JIANG_QIANZHU)			{				*((INTERFACE_ACTION_TYPE *)pData) = INTERFACE_ACTION_JIANG_ZHU;				sActionThirdName[0x00] = INTERFACE_ACTION_NONE;			}				if(sActionThirdName[0x01] == INTERFACE_ACTION_JIANG_QIANZHU)			{				*((INTERFACE_ACTION_TYPE *)pData) = INTERFACE_ACTION_JIANG_ZHU;				sActionThirdName[0x01] = INTERFACE_ACTION_NONE;			}						}		if(*(((INTERFACE_ACTION_TYPE *)pData)+0x01) == INTERFACE_ACTION_JIANG_QIANZHU)			{			if(sActionThirdName[0x00] == INTERFACE_ACTION_JIANG_HOUZHU)			{				*((INTERFACE_ACTION_TYPE *)pData) = INTERFACE_ACTION_JIANG_ZHU;				sActionThirdName[0x00] = INTERFACE_ACTION_NONE;			}				if(sActionThirdName[0x01] == INTERFACE_ACTION_JIANG_HOUZHU)			{				*((INTERFACE_ACTION_TYPE *)pData) = INTERFACE_ACTION_JIANG_ZHU;				sActionThirdName[0x01] = INTERFACE_ACTION_NONE;			}						}		if(sActionThirdName[0x00] == INTERFACE_ACTION_JIANG_HOUZHU)			{			if(sActionThirdName[0x01] == INTERFACE_ACTION_JIANG_QIANZHU)			{				*((INTERFACE_ACTION_TYPE *)pData) = INTERFACE_ACTION_JIANG_ZHU;				sActionThirdName[0x01] = INTERFACE_ACTION_NONE;			}						}		if(sActionThirdName[0x00] == INTERFACE_ACTION_JIANG_QIANZHU)			{			if(sActionThirdName[0x01] == INTERFACE_ACTION_JIANG_HOUZHU)			{				*((INTERFACE_ACTION_TYPE *)pData) = INTERFACE_ACTION_JIANG_ZHU;				sActionThirdName[0x01] = INTERFACE_ACTION_NONE;			}						}				/**对超过四种的情况进行判断**/		if((*(((INTERFACE_ACTION_TYPE *)pData)+0x01) != INTERFACE_ACTION_NONE)|| (sActionThirdName[0x00] != INTERFACE_ACTION_NONE)||(sActionThirdName[0x01] != INTERFACE_ACTION_NONE))		{					if(*(INTERFACE_ACTION_TYPE *)(pData) == (INTERFACE_ACTION_JIANG_ZHU))			{				if(*(((INTERFACE_ACTION_TYPE *)pData)+0x01) == INTERFACE_ACTION_JIANG_QIANZHU )					*(((INTERFACE_ACTION_TYPE *)pData)+0x01) = INTERFACE_ACTION_NONE;				if(*(((INTERFACE_ACTION_TYPE *)pData)+0x01) == INTERFACE_ACTION_JIANG_HOUZHU )					*(((INTERFACE_ACTION_TYPE *)pData)+0x01) = INTERFACE_ACTION_NONE;									if(sActionThirdName[0x00]== INTERFACE_ACTION_JIANG_QIANZHU )					sActionThirdName[0x00] = INTERFACE_ACTION_NONE;				if(sActionThirdName[0x00] == INTERFACE_ACTION_JIANG_HOUZHU )					sActionThirdName[0x00] = INTERFACE_ACTION_NONE;					if(sActionThirdName[0x01] == INTERFACE_ACTION_JIANG_QIANZHU )					sActionThirdName[0x01] = INTERFACE_ACTION_NONE;				if(sActionThirdName[0x01] == INTERFACE_ACTION_JIANG_HOUZHU )					sActionThirdName[0x01] = INTERFACE_ACTION_NONE;								}			if(*(((INTERFACE_ACTION_TYPE *)pData)+0x01) == INTERFACE_ACTION_JIANG_ZHU)			{				if(*((INTERFACE_ACTION_TYPE *)pData) == INTERFACE_ACTION_JIANG_QIANZHU )					*((INTERFACE_ACTION_TYPE *)pData) = INTERFACE_ACTION_NONE;				if(*((INTERFACE_ACTION_TYPE *)pData) == INTERFACE_ACTION_JIANG_HOUZHU )					*((INTERFACE_ACTION_TYPE *)pData) = INTERFACE_ACTION_NONE;									if(sActionThirdName[0x00] == INTERFACE_ACTION_JIANG_QIANZHU )					sActionThirdName[0x00] = INTERFACE_ACTION_NONE;				if(sActionThirdName[0x00] == INTERFACE_ACTION_JIANG_HOUZHU )					sActionThirdName[0x00] = INTERFACE_ACTION_NONE;					if(sActionThirdName[0x01] == INTERFACE_ACTION_JIANG_QIANZHU )					sActionThirdName[0x01] = INTERFACE_ACTION_NONE;				if(sActionThirdName[0x01] == INTERFACE_ACTION_JIANG_HOUZHU )					sActionThirdName[0x01] = INTERFACE_ACTION_NONE;							}				if(sActionThirdName[0x00] == INTERFACE_ACTION_JIANG_ZHU)			{				if(*((INTERFACE_ACTION_TYPE *)pData) == INTERFACE_ACTION_JIANG_QIANZHU )					*((INTERFACE_ACTION_TYPE *)pData) = INTERFACE_ACTION_NONE;				if(*((INTERFACE_ACTION_TYPE *)pData) == INTERFACE_ACTION_JIANG_HOUZHU )					*((INTERFACE_ACTION_TYPE *)pData)= INTERFACE_ACTION_NONE;									if(*(((INTERFACE_ACTION_TYPE *)pData)+0x01) == INTERFACE_ACTION_JIANG_QIANZHU )					*(((INTERFACE_ACTION_TYPE *)pData)+0x01) = INTERFACE_ACTION_NONE;				if(*(((INTERFACE_ACTION_TYPE *)pData)+0x01) == INTERFACE_ACTION_JIANG_HOUZHU )					*(((INTERFACE_ACTION_TYPE *)pData)+0x01) = INTERFACE_ACTION_NONE;				if(sActionThirdName[0x01] == INTERFACE_ACTION_JIANG_QIANZHU )					sActionThirdName[0x01] = INTERFACE_ACTION_NONE;				if(sActionThirdName[0x01] == INTERFACE_ACTION_JIANG_HOUZHU )					sActionThirdName[0x01] = INTERFACE_ACTION_NONE;								}						if(sActionThirdName[0x01] == INTERFACE_ACTION_JIANG_ZHU)			{				if(*((INTERFACE_ACTION_TYPE *)pData) == INTERFACE_ACTION_JIANG_QIANZHU )					*((INTERFACE_ACTION_TYPE *)pData) = INTERFACE_ACTION_NONE;				if(*((INTERFACE_ACTION_TYPE *)pData) == INTERFACE_ACTION_JIANG_HOUZHU )					*((INTERFACE_ACTION_TYPE *)pData)= INTERFACE_ACTION_NONE;									if(*(((INTERFACE_ACTION_TYPE *)pData)+0x01) == INTERFACE_ACTION_JIANG_QIANZHU )					*(((INTERFACE_ACTION_TYPE *)pData)+0x01) = INTERFACE_ACTION_NONE;				if(*(((INTERFACE_ACTION_TYPE *)pData)+0x01) == INTERFACE_ACTION_JIANG_HOUZHU )					*(((INTERFACE_ACTION_TYPE *)pData)+0x01) = INTERFACE_ACTION_NONE;				if(sActionThirdName[0x00] == INTERFACE_ACTION_JIANG_QIANZHU )					sActionThirdName[0x00] = INTERFACE_ACTION_NONE;				if(sActionThirdName[0x00] == INTERFACE_ACTION_JIANG_HOUZHU )					sActionThirdName[0x00] = INTERFACE_ACTION_NONE;								}					}		if(sActionThirdName[0x00] ==INTERFACE_ACTION_NONE)		{			sActionThirdName[0x00] = sActionThirdName[0x01];		}		if(*(((INTERFACE_ACTION_TYPE *)pData)+0x01) == INTERFACE_ACTION_NONE)		{			 *(((INTERFACE_ACTION_TYPE *)pData)+0x01) = sActionThirdName[0x00];			sActionThirdName[0x00] = sActionThirdName[0x01];		}			if(*((INTERFACE_ACTION_TYPE *)pData) == INTERFACE_ACTION_NONE)		{			*((INTERFACE_ACTION_TYPE *)pData) = *(((INTERFACE_ACTION_TYPE *)pData)+0x01) ;			*(((INTERFACE_ACTION_TYPE *)pData)+0x01) = sActionThirdName[0x00];			sActionThirdName[0x00] = sActionThirdName[0x01];		}				return u32ReturnFlag;	}#endif/*********************************************************************************************函数名称：LogicSetBatteryStatusProc**函数作用：逻辑层运行信息消息处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/static u32 LogicSetBatteryStatusProc(void *pData){	s_stLogicRunInf.stBatteryStatus = *(BATTERY_STATUS_TYPE *)pData ;		return 0x01;}/*********************************************************************************************函数名称：LogicSetBatteryCoulomStatusProc**函数作用：逻辑层运行信息消息处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/static u32 LogicSetBatteryCoulomStatusProc(void *pData){	s_stLogicRunInf.stBatteryCoulomStatus = *(BATTERY_COULOMETRY_TYPE *)pData ;		return 0x01;}/*********************************************************************************************函数名称：LogicSetBatteryCoulomDataProc**函数作用：逻辑层运行信息消息处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/static u32 LogicSetBatteryCoulomDataProc(void *pData){	s_stLogicRunInf.u16BatteryCoulomData = *(u16 *)pData ;	return 0x01;}/*********************************************************************************************函数名称：LogicSetRfidSignStatusProc**函数作用：逻辑层运行信息消息处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/static u32 LogicSetRfidSignStatusProc(void *pData){	s_stLogicRunInf.u16RfidSignStatus = *(u16 *)pData ;	return 0x01;}/*********************************************************************************************函数名称：LogicSetRfidSignStatusProc**函数作用：逻辑层运行信息消息处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/static u32 LogicSetWLVersionProc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData){	memcpy(s_stLogicParamSystem.u8WLVersion,pData ,sizeof(s_stLogicParamSystem.u8WLVersion));	return 0x01;}static u32 LogicGetWLVersionProc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData){	memcpy(pData ,s_stLogicParamSystem.u8WLVersion,sizeof(s_stLogicParamSystem.u8WLVersion));	return 0x01;}static u32 LogicGetBatteryVoltage1Proc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData){	*(u16 *)pData = BatteryGetVoltageTempProc_B();	return 0x01;}static u32 LogicGetBatteryVoltage2Proc(LOGIC_PARAM_MSG_TYPE sMsg,void *pData){	*(u16 *)pData = BatteryGetVoltageTempProc_D();	return 0x01;}/*********************************************************************************************函数名称：LogicSetAutoPressEnableFlagPorc**函数作用：逻辑层运行信息消息处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/#if (KEY_AUTO_PRESS_PROC_FLAG != DISABLED)	static u32 LogicSetAutoPressEnableFlagPorc(void *pData)	{		if((*(u32 *)pData == ENABLED)||(*(u32 *)pData == DISABLED))		{			RfidMngSendAutoPressEnabledDisabledFlag(*(u32 *)pData);		}		else		{			;		}				return 0x01;				}#endif/**以下为获取参数****//*********************************************************************************************函数名称：LogicGetColibrateScTypeProc**函数作用：逻辑层运行信息消息处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/static u32 LogicGetColibrateScTypeProc(void *pData){	*(u16 *)pData = s_stLogicRunInf.u16ColibarateType; 		return 0x01;}/*********************************************************************************************函数名称：LogicGetScNumbDirectProc**函数作用：逻辑层运行信息消息处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/static u32 LogicGetScNumbDirectProc(void *pData){	*(u16 *)pData = s_stLogicRunInf.u16ScNumbAddDirc;	return 0x01;}/*********************************************************************************************函数名称：LogicGetColibrateScNumbProc**函数作用：逻辑层运行信息消息处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/static u32 LogicGetColibrateScNumbProc(void *pData){	*(u16 *)pData = s_stLogicRunInf.u16ScNumbColibarated;		return 0x01;}/*********************************************************************************************函数名称：LogicGetColibrateSuccessScNumbProc**函数作用：逻辑层运行信息消息处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/static u32 LogicGetColibrateSuccessScNumbProc(void *pData){	*(u16 *)pData = s_stLogicRunInf.u16ScNumbColibaratedSuccess;		return 0x01;}/*********************************************************************************************函数名称：LogicSetColibrateSuccessScNumbProc**函数作用：逻辑层运行信息消息处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/static u32 LogicSetColibrateSuccessScNumbProc(void *pData){	s_stLogicRunInf.u16ScNumbColibaratedSuccess = *(u16 *)pData;		return 0x01;}/*********************************************************************************************函数名称：LogicGetCtrlScNumbProc**函数作用：逻辑层运行信息消息处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/static u32 LogicGetCtrlScNumbProc(void *pData){	*(u16 *)pData = s_stLogicRunInf.u16ScNeigborControled;		return 0x01;}/*********************************************************************************************函数名称：LogicGetRfidFrameTypeProc**函数作用：逻辑层运行信息消息处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/static u32 LogicGetRfidFrameTypeProc(void *pData){	 *(RFID_FRAME_TYPE *)pData = s_stLogicRunInf.sRfidFrameType;		return 0x01;}/*********************************************************************************************函数名称：LogicGetScActionNameProc**函数作用：逻辑层运行信息消息处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/static u32 LogicGetScActionNameProc(void *pData){	*(u32 *)pData = s_stLogicRunInf.u32ScActionName ;		return 0x01;}/*********************************************************************************************函数名称：LogicGetGrpDirectionProc**函数作用：逻辑层运行信息消息处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/static u32 LogicGetGrpDirectionProc(void *pData){	*(SC_GRP_DIRECTION_TYPE *)pData = s_stLogicRunInf.stGrpActionDirection ;		return 0x01;}/*********************************************************************************************函数名称：LogicGetGrpAckActionNameProc**函数作用：逻辑层运行信息消息处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/static u32 LogicGetGrpAckActionNameProc(void * pData) {	*(RFID_GRP_ACTION_TYPE *)pData = s_stLogicRunInf.stGrpActionAckName;		return 0x01;	}/*********************************************************************************************函数名称：LogicGetGrpNearScNumbProc**函数作用：逻辑层运行信息消息处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/static u32 LogicGetGrpNearScNumbProc(void *pData){	*(u16  *)pData = s_stLogicRunInf.u16GrpNearScNumb;		return 0x01;	}/*********************************************************************************************函数名称：LogicGetGrpRemoteScNumbProc**函数作用：逻辑层运行信息消息处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/static u32 LogicGetGrpRemoteScNumbProc(void *pData){	*(u16  *)pData = s_stLogicRunInf.u16GrpRemoteScNumb ;		return 0x01;	}/*********************************************************************************************函数名称：LogicGetRunStatusProc**函数作用：逻辑层运行信息消息处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/static u32 LogicGetRunStatusProc(void *pData){	*(u16 *)pData = s_stLogicRunInf.stLogicRunStatus ;		return 0x01;}/*********************************************************************************************函数名称：LogicGetButtonDownProc**函数作用：逻辑层运行信息消息处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/static u32 LogicGetButtonDownProc(void *pData){	*(COMMAND_ACTION *)pData = s_stLogicRunInf.CommandActionValue;		return 0x01;}/*********************************************************************************************函数名称：LogicGetButtonDownAckProc**函数作用：逻辑层运行信息消息处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/static u32 LogicGetButtonDownAckProc(void * pData){	*(COMMAND_ACTION *)pData = s_stLogicRunInf.CommandActionAckValue;		return 0x01;}/*********************************************************************************************函数名称：LogicSetButtonLongDownProc**函数作用：逻辑层运行信息消息处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/static u32 LogicSetHeartProc(void * pData){	SIGNAL_ACTION_HEART temp;	temp = *(SIGNAL_ACTION_HEART *)pData ;	RfidMngSendHeart(temp.ActionValue,temp.ActionType,temp.SendMode);		return 0x01;}/*********************************************************************************************函数名称：LogicSetNearCtrlReq**函数作用：邻架控制请求**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/static u32 LogicSetNearCtrlReq(void * pData){	RfidMngNearCtrlReq(*(u8*) pData);		return 0x01;}/*********************************************************************************************函数名称：LogicGetButtonStatusProc**函数作用：逻辑层运行信息消息处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/static u32 LogicGetButtonStatusProc(void * pData){	*(SC_BUTTON_TYPE *)pData = s_stLogicRunInf.stButtonStatus;		return 0x01;}/*********************************************************************************************函数名称：LogicGetButtonLongDownProc**函数作用：逻辑层运行信息消息处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/static u32 LogicGetButtonLongDownProc(void * pData){	*(u32 *)pData = s_stLogicRunInf.u32ButtonLongValue ;		return 0x01;}/*********************************************************************************************函数名称：LogicGetButtonUpProc**函数作用：逻辑层运行信息消息处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/static u32 LogicGetButtonUpProc(void * pData){	*(u64 *)pData = s_stLogicRunInf.u64ButtonUpValue;		return 0x01;}/*********************************************************************************************函数名称：LogicSetCtrlScNumbProc**函数作用：逻辑层消息处理列表**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/static u32 LogicGetScActionTypeProc(void * pData){	*(u32 *)pData = s_stLogicRunInf.u32ScActionType;	return 0x01;}/*********************************************************************************************函数名称：LogicSetCtrlScNumbProc**函数作用：逻辑层消息处理列表**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/static u32 LogicGetScGejiaNumberProc(void * pData){	*(u32 *)pData = s_stLogicRunInf.u32ScGejiaNumber ;	return 0x01;}/*********************************************************************************************函数名称：LogicSetCtrlScNumbProc**函数作用：逻辑层消息处理列表**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/#if (QUICK_KEY_CTRL_ENABLE_FLAG != 0)		static u32 LogicGetScQuickTypeProc(void *pData)		{				*(u32 *)pData = s_stLogicRunInf.u32ScQuickActionType ;				return 0x01;		}#endif/*********************************************************************************************函数名称：LogicGetBatteryStatusProc**函数作用：逻辑层运行信息消息处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/static u32 LogicGetBatteryStatusProc(void *pData){	*(BATTERY_STATUS_TYPE *)pData = s_stLogicRunInf.stBatteryStatus ;		return 0x01;}/*********************************************************************************************函数名称：LogicGetBatteryCoulomStatusProc**函数作用：逻辑层运行信息消息处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/static u32 LogicGetBatteryCoulomStatusProc(void *pData){	*(BATTERY_COULOMETRY_TYPE *)pData = s_stLogicRunInf.stBatteryCoulomStatus ;		return 0x01;}/*********************************************************************************************函数名称：LogicGetBatteryCoulomDataProc**函数作用：逻辑层运行信息消息处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/static u32 LogicGetBatteryCoulomDataProc(void *pData){	*(u16 *)pData  = s_stLogicRunInf.u16BatteryCoulomData ;	return 0x01;}/*********************************************************************************************函数名称：LogicGetRfidSignStatusProc**函数作用：逻辑层运行信息消息处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/static u32 LogicGetRfidSignStatusProc(void *pData){	*(u16 *)pData = s_stLogicRunInf.u16RfidSignStatus ;	return 0x01;}/******************************以下为状态处理函数*******************************//*********************************************************************************************函数名称：LogicStatusIdleProc**函数作用：逻辑层空闲状态处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/static u32 LogicStatusIdleProc(void){	return 0x01;}/*********************************************************************************************函数名称：LogicStatusIrColibStartProc**函数作用：逻辑层红外对码启动状态处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/static u32 LogicStatusIrColibStartProc(void){	u16 u16Status;	u16Status = LOGIC_STATUS_IR_COLIBARAE_ING;	LogicRunInfApi(LOGIC_SET_RUN_STATUS,&u16Status);		IrSendCalibrateCodeInterface(s_stLogicParamSystem.u8YKQNumber);	OSTimeDly(LOGIC_TASK_TIME_SET/TICK_TIME);		return 1;}/*********************************************************************************************函数名称：LogicStatusIrColibSuccessdProc**函数作用：逻辑层红外对码成功状态处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/static u32 LogicStatusIrColibSuccessdProc(void){	u16 u16Status;	StateLed(ADJUST_CODE_ING_LED,0x00);		u16Status = LOGIC_STATUS_RFID_COLIBARAE_ING;		LogicRunInfApi(LOGIC_SET_RUN_STATUS,&u16Status);	//发送RFID数据	RfidMngSendDataColibarate();		return 0x01;}/*********************************************************************************************函数名称：LogicStatusIrColibFailProc**函数作用：逻辑层红外对码失败状态处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/static u32 LogicStatusIrColibFailProc(void){	//IrSendCalibrateCodeInterface(s_stLogicParamSystem.u8YKQNumber);		return 0x01;	}/*********************************************************************************************函数名称：LogicStatusRfidColibStartProc**函数作用：逻辑层无线对码启动状态处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/static u32 LogicStatusRfidColibStartProc(void){	u16 u16Status;	u16Status = LOGIC_STATUS_RFID_COLIBARAE_ING;	LogicRunInfApi(LOGIC_SET_RUN_STATUS,&u16Status);	//IrSendCalibrateCodeInterface(s_stLogicParamSystem.u8RfidSelfNumb);		return 0x01;	}/*********************************************************************************************函数名称：LogicStatusRfidColibSuccessdProc**函数作用：逻辑层无线对码成功状态处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/static u32 LogicStatusRfidColibSuccessdProc(void){	//IrSendCalibrateCodeInterface(s_stLogicParamSystem.u8YKQNumber);	return 0x01;	}/*********************************************************************************************函数名称：LogicStatusInintProc**函数作用：逻辑层初始状态处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/static u32 LogicStatusInintProc(void){	u16 u16Status;	if(GPIO_ReadInputDataBit(KEY_R5WKUP2_PORT,KEY_R5WKUP2_PIN) == Bit_RESET)	{		u16Status = LOGIC_STATUS_IDLE;				LogicRunInfApi(LOGIC_SET_RUN_STATUS,&u16Status);			}	return 0x01;}/*********************************************************************************************函数名称：LogicStatusRfidColibFailProc**函数作用：逻辑层无线对码失败状态处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/static u32 LogicStatusRfidColibFailProc(void){	//IrSendCalibrateCodeInterface(s_stLogicParamSystem.u8YKQNumber);		return 0x01;	}/*********************************************************************************************函数名称：LogicStatusSelfQuickCtrlProc**函数作用：逻辑层本架控制状态处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/static u32 LogicStatusScSelfCtrlProc(void){	#if (ZIBAO_CTRL_ENABLE_FLAG	!= DISABLED)		s_u32ZibaoCtrlTimer = 0x00;		StateLed(ADJUST_CODE_SUCCEED_LED, 0x00);			#if (ZIBAO_CTRL_METHOD_TYPE	==	ZIBAO_PARAM_CTRL_METHOD)			s_u32ZibaoAcionKeyBackup = 0x00;		#endif			#endif		return 0x01;		}/*********************************************************************************************函数名称：LogicStatusScZibaoCtrlProc**函数作用：逻辑层本架自保状态处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/#if (ZIBAO_CTRL_ENABLE_FLAG	!= DISABLED)	extern	u32 InterfaceGetKeyRfidDataShowName(INTERFACE_CONTROL_MODE_TYPE stMode,u32 u32ShiftKeyStatus,u32 u32KeyValue,INTERFACE_ACTION_TYPE *pInterAction,RFID_FRAME_TYPE *pRfidFType);	static u32 LogicStatusScZibaoCtrlProc(void)	{		#if (ZIBAO_CTRL_METHOD_TYPE	==	ZIBAO_PARAM_CTRL_METHOD)			u32 u32ZibaoActionNow = 0x00;			u32 u32I = 0x00;			u32 u32J = 0x00;			u32 u32RfidData = 0x00;			u32 u32RfidType = 0x00;			INTERFACE_ACTION_TYPE interAction[INTERFACE_KEY_TOGETHER_MAX] ;			INTERFACE_ACTION_TYPE temp[INTERFACE_KEY_TOGETHER_MAX] ;			u16 u16SendTimes;			u16 u16DelayTime;			u8 err = 0x00;		#endif				s_u32ZibaoCtrlTimer += LOGIC_TASK_TIME_SET;		if((s_u32ZibaoCtrlTimer%100) == 0x00)		{				LedToggle(ADJUST_CODE_SUCCEED_LED);		}		#if (ZIBAO_CTRL_METHOD_TYPE	==	ZIBAO_PARAM_CTRL_METHOD)			if((s_u32ZibaoCtrlTimer%100) != 0x00)				return 0x01;			if(InterfaceGetZibaoActionKey(&u32ZibaoActionNow))			{				if(u32ZibaoActionNow != s_u32ZibaoAcionKeyBackup)				{					if(u32ZibaoActionNow == 0x00)					{						for(u32I=0x00;u32I < LOGIC_ZIBAO_ACTIONNUMB_MAX;u32I++)						{							s_u32ZibaoActionIngTime[u32I] = 0x00;						}					}					else					{						for(u32I=0x00;u32I < LOGIC_ZIBAO_ACTIONNUMB_MAX;u32I++)						{							if(((s_u32ZibaoAcionKeyBackup&(1<<u32I))>>u32I ) !=((u32ZibaoActionNow&(1<<u32I))>>u32I) )							{								u32RfidData = (s_u32ZibaoAcionKeyBackup&(1<<u32I));																u32RfidData = InterfaceGetKeyRfidDataShowName(InterfaceGetCtrlMode(),DISABLED,(u32RfidData !=0)?u32RfidData:(u32ZibaoActionNow&(1<<u32I)),&(temp[0x00]),(RFID_FRAME_TYPE *)&u32RfidType);								u32RfidData &= 0x3FFFFFFF;								if(u32RfidData != 0x00)								{									for(u32J=0x00;u32J< LOGIC_ZIBAO_ACTIONNUMB_MAX;u32J++)																	{										if(((u32RfidData&(1<<u32J))>>u32J)!= 0x00)										{											s_u32ZibaoActionIngTime[u32J] = 0x00;											break;											}									}								}															}						}					}										}			}						s_u32ZibaoAcionKeyBackup = u32ZibaoActionNow;				/**对正在执行的动作进行累加**/			if(s_u32ZibaoAcionKeyBackup == 0x00)				return 0x01;			else			{				InterfaceSetCtrlMode(INTERFACE_MODE_SC_ZIBAO_CONTROL);							}						for(u32I=0x00;u32I < LOGIC_ZIBAO_ACTIONNUMB_MAX;u32I++)			{				if(((s_u32ZibaoAcionKeyBackup&(1<<u32I))>>u32I ) !=0x00)				{					u32RfidData = (s_u32ZibaoAcionKeyBackup&(1<<u32I));					u32RfidData = InterfaceGetKeyRfidDataShowName(InterfaceGetCtrlMode(),DISABLED,(u32RfidData !=0)?u32RfidData:(u32ZibaoActionNow&(1<<u32I)),&(temp[0x00]),(RFID_FRAME_TYPE *)&u32RfidType);					u32RfidData &= 0x3FFFFFFF;					if(u32RfidData != 0x00)						{						for(u32J=0x00;u32J< LOGIC_ZIBAO_ACTIONNUMB_MAX;u32J++)														{							if(((u32RfidData&(1<<u32J))>>u32J)!= 0x00)							{								s_u32ZibaoActionIngTime[u32J] += 100;									LogicParamApi((LOGIC_PARAM_MSG_TYPE)(LOGIC_GET_SHENGZHU_DOING_TIME+u32J), &u32ZibaoActionNow);								if(s_u32ZibaoActionIngTime[u32J] >= (u32ZibaoActionNow*83))//当前动作应该停止								{									s_u32ZibaoAcionKeyBackup &= ~(1<<u32I);									s_u32ZibaoActionIngTime[u32J] = 0x00;								}							}						}										}				}							}			/**判断是否需要停止某些动作**/			InterfaceGetZibaoActionKey(&u32ZibaoActionNow);			if(s_u32ZibaoAcionKeyBackup != u32ZibaoActionNow)			{				InterfaceGetActionName(interAction);				u32RfidType = 0x00;				u32RfidData = InterfaceGetKeyRfidDataShowName(InterfaceGetCtrlMode(),DISABLED,(s_u32ZibaoAcionKeyBackup == 0x00)?u32ZibaoActionNow:s_u32ZibaoAcionKeyBackup,&(temp[0x00]),(RFID_FRAME_TYPE *)&u32RfidType);				for(err = 0x00;err < INTERFACE_KEY_TOGETHER_MAX;err++)				{					if(interAction[err] == INTERFACE_ACTION_NONE)						break;					else					{						for(u16DelayTime=0x00;u16DelayTime < INTERFACE_KEY_TOGETHER_MAX;u16DelayTime++)						{							if(temp[u16DelayTime] == interAction[err])								break;						}						if(u16DelayTime == INTERFACE_KEY_TOGETHER_MAX)						{							for(u16DelayTime=err;u16DelayTime < (INTERFACE_KEY_TOGETHER_MAX-0x01);u16DelayTime++)							{								interAction[u16DelayTime] = interAction[u16DelayTime+0x01];								if(interAction[u16DelayTime+0x01] == INTERFACE_ACTION_NONE)									break;							}												}					}				}					InterfaceSetActionName(interAction);							}						if((s_u32ZibaoAcionKeyBackup != u32ZibaoActionNow)&&(u32ZibaoActionNow != 0x00)&&(s_u32ZibaoAcionKeyBackup == 0x00))			{				#if (YKQ_HARDWARE_BEEP_EXIST_DEFINE != DISABLED)					BuzzerOn(BEEP_ACTION);				#endif				/**键值显示**/				LogicRunInfApi(LOGIC_SET_RFID_FRAME_TYPE, &u32RfidType);//发送的数据				LogicRunInfApi(LOGIC_SET_SC_ACTION_NAME, &u32RfidData);//发送的数据				u32I = SC_BUTTON_ACK_NONE;				LogicRunInfApi(LOGIC_SET_BUTTON_ACCEPT_STATUS,&u32I);//将应答设为无效					u32I = RFID_ACTION_NONE;				LogicRunInfApi(LOGIC_SET_BUTTON_ACK_VALUE,&u32I);//将应答动作字设为无效							u32I = (u32)(u32RfidData|(u32RfidType<<30));				LogicRunInfApi( LOGIC_SET_BUTTON_UP,&u32I); 				u32I = LOGIC_STATUS_RFID_SC_ZIBAO_CONTROL;				LogicRunInfApi(LOGIC_SET_RUN_STATUS,&u32I);								for(err = 0x00; err < INTERFACE_KEY_TOGETHER_MAX;err++)					temp[err] = INTERFACE_ACTION_NONE;//默认屏幕显示				InterfaceSetActionName(temp);					InterfaceSetCtrlMode(INTERFACE_MODE_SC_ZIBAO_CONTROL);				InterfaceInsertNote(INTERFACE_NOTE_ZIBAO_ACTION_STOP);				InterfaceSetUpdateMainMethod(INTERFACE_SHOW_SC_ZIBAO_CONTROL|INTERFACE_SHOW_MAIN_NOTE);//显示主屏所有信息				OSSemPost(g_stSemInterface);				u32I = 0x00;				InterfaceSetZibaoActionKey(&u32I);				InterfaceSetZibaoRfidBackup(&u32I);				InterfaceSetZibaoKeyLedStatus(KEY_INVALID,KEY_DOWN);			}			else if((s_u32ZibaoAcionKeyBackup != u32ZibaoActionNow)&&(u32ZibaoActionNow != 0x00))			{				#if (YKQ_HARDWARE_BEEP_EXIST_DEFINE != DISABLED)					BuzzerOn(BEEP_ACTION);				#endif				/**键值显示**/				LogicRunInfApi(LOGIC_SET_RFID_FRAME_TYPE, &u32RfidType);//发送的数据				LogicRunInfApi(LOGIC_SET_SC_ACTION_NAME, &u32RfidData);//发送的数据				g_stLogicSem->OSEventCnt = 0;				u32I = SC_BUTTON_ACK_NONE;				LogicRunInfApi(LOGIC_SET_BUTTON_ACCEPT_STATUS,&u32I);//将应答设为无效					u32I = RFID_ACTION_NONE;				LogicRunInfApi(LOGIC_SET_BUTTON_ACK_VALUE,&u32I);//将应答动作字设为无效							u32I = (u32)(u32RfidData|(u32RfidType<<30));				LogicRunInfApi(LOGIC_SET_BUTTON_VALUE,&u32I);								LogicParamApi(LOGIC_GET_RFID_SENDTIMES, &u16SendTimes);				LogicParamApi(LOGIC_GET_RFID_TINMEOUT, &u16DelayTime);					u32I = (u32)(u16DelayTime*u16SendTimes);					u32I += 30;						OSSemPend(g_stLogicSem,u32I/TICK_TIME,&err);						if(err == OS_ERR_TIMEOUT)//无应答				{					InterfaceInsertNote(INTERFACE_NOTE_NO_ACK);					InterfaceSetCtrlMode(INTERFACE_MODE_SC_ZIBAO_CONTROL);						for(u32I = 0x00; u32I < INTERFACE_KEY_TOGETHER_MAX;u32I++)						temp[u32I] = INTERFACE_ACTION_NONE;//默认屏幕显示					InterfaceSetActionName(temp);						InterfaceSetUpdateMainMethod(INTERFACE_SHOW_MAIN_NOTE|INTERFACE_SHOW_SC_ZIBAO_CONTROL);//显示主屏所有信息					OSSemPost(g_stSemInterface);					u32I = 0x00;					InterfaceSetZibaoActionKey(&u32I);					InterfaceSetZibaoRfidBackup(&u32I);					InterfaceSetZibaoKeyLedStatus(KEY_INVALID,KEY_DOWN);				}				else if(err == OS_ERR_NONE)//有应答				{					/**关于设置的一些特殊模式切换的处理*/					u32J = 0x00;					LogicRunInfApi(LOGIC_GET_BUTTON_ACCEPT_STATUS, &u32J);					LogicRunInfApi(LOGIC_GET_BUTTON_VALUE,&u32I);					LogicRunInfApi(LOGIC_GET_BUTTON_ACK_VALUE,&u32ZibaoActionNow);					if((u32J == SC_BUTTON_ACK_ACCEPT) && (u32ZibaoActionNow == u32RfidData))					{						InterfaceInsertNote(INTERFACE_NOTE_ZIBAO_ACTION_STOP);						InterfaceSetUpdateMainMethod(INTERFACE_SHOW_MAIN_NOTE|INTERFACE_SHOW_SC_ZIBAO_CONTROL);//显示主屏所有信息						InterfaceSetCtrlMode(INTERFACE_MODE_SC_ZIBAO_CONTROL);						LogicRunInfApi(LOGIC_SET_BUTTON_LONG_VALUE,&u32RfidData);											OSSemPost(g_stSemInterface);						InterfaceSetZibaoActionKey(&s_u32ZibaoAcionKeyBackup);						InterfaceSetZibaoRfidBackup(&u32RfidData);							InterfaceSetZibaoKeyLedStatus(s_u32ZibaoAcionKeyBackup,KEY_DOWN);						}					else if(u32J == SC_BUTTON_ACK_REJECT)					{						InterfaceInsertNote(INTERFACE_NOTE_BUTTON_REJECT);						InterfaceSetCtrlMode(INTERFACE_MODE_SC_ZIBAO_CONTROL);						u32I = LOGIC_STATUS_RFID_SC_ZIBAO_CONTROL;						LogicRunInfApi(LOGIC_SET_RUN_STATUS,&u32I);						for(u32I = 0x00; u32I < INTERFACE_KEY_TOGETHER_MAX;u32I++)							temp[u32I] = INTERFACE_ACTION_NONE;//默认屏幕显示						InterfaceSetActionName(temp);						InterfaceSetUpdateMainMethod(INTERFACE_SHOW_MAIN_NOTE|INTERFACE_SHOW_SC_ZIBAO_CONTROL);//显示主屏所有信息						OSSemPost(g_stSemInterface);						u32I = 0x00;						InterfaceSetZibaoActionKey(&u32I);						InterfaceSetZibaoRfidBackup(&u32I);							InterfaceSetZibaoKeyLedStatus(KEY_INVALID,KEY_DOWN);					}					else					{						InterfaceInsertNote(INTERFACE_NOTE_NO_ACK);						InterfaceSetCtrlMode(INTERFACE_MODE_SC_ZIBAO_CONTROL);							u32I = LOGIC_STATUS_RFID_SC_ZIBAO_CONTROL;						LogicRunInfApi(LOGIC_SET_RUN_STATUS,&u32I);						for(u32I = 0x00; u32I < INTERFACE_KEY_TOGETHER_MAX;u32I++)							temp[u32I] = INTERFACE_ACTION_NONE;//默认屏幕显示						InterfaceSetActionName(temp);						InterfaceSetUpdateMainMethod(INTERFACE_SHOW_MAIN_NOTE|INTERFACE_SHOW_SC_ZIBAO_CONTROL);//显示主屏所有信息											OSSemPost(g_stSemInterface);						u32I = 0x00;						InterfaceSetZibaoActionKey(&u32I);						InterfaceSetZibaoRfidBackup(&u32I);							InterfaceSetZibaoKeyLedStatus(KEY_INVALID,KEY_DOWN);											}				}				else						;							}		#endif					return 0x01;				}#endif/*********************************************************************************************函数名称：LogicStatusSelfQuickCtrlProc**函数作用：逻辑层无线解除对码状态处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/#if (QUICK_KEY_CTRL_ENABLE_FLAG != 0)	static u32 LogicStatusScQuickCtrlProc(void)	{		u32 u32ReturnFlag = 0x00,u32I = 0x00,u32J = 0x00;		INTERFACE_ACTION_TYPE s_stActionNameFlag[LOGIC_QUICK_ACTIONNUMB_MAX] = {INTERFACE_ACTION_NONE,INTERFACE_ACTION_NONE,INTERFACE_ACTION_NONE,INTERFACE_ACTION_NONE,INTERFACE_ACTION_NONE,INTERFACE_ACTION_NONE,INTERFACE_ACTION_NONE,INTERFACE_ACTION_NONE,INTERFACE_ACTION_NONE,INTERFACE_ACTION_NONE};		u32 u32ActionNameWriteptr = 0x00;		u16 u16QuickEnableFlag = ENABLED;		u16 u16QuickActionNumb;			//u16 u16QuickAlaramTimer;			INT8U err;		u16 u16QuickActionName[LOGIC_QUICK_ACTIONNUMB_MAX];		u16 u16QuickActionStart[LOGIC_QUICK_ACTIONNUMB_MAX];//以0.1秒进行参数存储		u16 u16QuickActionIng[LOGIC_QUICK_ACTIONNUMB_MAX];//以0.1秒进行参数存储				static u16 u16QuickActionDoingStatus[LOGIC_QUICK_ACTIONNUMB_MAX]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};//0:未开始；1：正在执行；2：已经结束						static u32 u32RfidDataType = 0x00;		static u32 u32RfidFrameData = 0x00;		static u32 u32RfidFrameDataBackup = 0x00;		if(s_stLogicRunInf.u32ScQuickActionType == SC_ACTION_QUICK_STOP)//立即停止动作，必要时发送按键抬起需		{			if(u32RfidFrameData)			{				u32RfidFrameData = 0x00;			}		}		else if(s_stLogicRunInf.u32ScQuickActionType == SC_ACTION_QUICK_1)		{			u16QuickEnableFlag = s_stLogicParamSystem.u16Quick1EnableFlag;			u16QuickActionNumb = s_stLogicParamSystem.u16Quick1ActionNumb;			//u16QuickAlaramTimer = s_stLogicParamSystem.u16Quick1AlaramTimer;			memmove(u16QuickActionName,&(s_stLogicParamSystem.u16Quick1ActionName),sizeof(u16QuickActionName));			memmove(u16QuickActionStart,&(s_stLogicParamSystem.u16Quick1ActionStart),sizeof(u16QuickActionStart));			memmove(u16QuickActionIng,&(s_stLogicParamSystem.u16Quick1ActionIng),sizeof(u16QuickActionIng));			}		else if(s_stLogicRunInf.u32ScQuickActionType == SC_ACTION_QUICK_2)		{			u16QuickEnableFlag = s_stLogicParamSystem.u16Quick2EnableFlag;			u16QuickActionNumb = s_stLogicParamSystem.u16Quick2ActionNumb;			//u16QuickAlaramTimer = s_stLogicParamSystem.u16Quick2AlaramTimer;			memmove(u16QuickActionName,&(s_stLogicParamSystem.u16Quick2ActionName),sizeof(u16QuickActionName));			memmove(u16QuickActionStart,&(s_stLogicParamSystem.u16Quick2ActionStart),sizeof(u16QuickActionStart));			memmove(u16QuickActionIng,&(s_stLogicParamSystem.u16Quick2ActionIng),sizeof(u16QuickActionIng));			}		else			;				if(u16QuickEnableFlag != ENABLED)			return 0x00;		/**寻找需要进行的动作***/		if(s_stLogicRunInf.u32ScQuickActionType != SC_ACTION_QUICK_STOP)		{			u32ActionNameWriteptr = 0x00;			memset(s_stActionNameFlag,INTERFACE_ACTION_NONE,sizeof(s_stActionNameFlag));			for(u32I = 0x00; u32I < u16QuickActionNumb;u32I++)			{				if((u16QuickActionDoingStatus[u32I] == 0x01)&&(u16QuickActionName[u32I]!= INTERFACE_ACTION_NONE)&&(s_stLogicRunInf.u32ScQuickActionTimer >= ((u16QuickActionStart[u32I]+u16QuickActionIng[u32I])*83)&&(u16QuickActionIng[u32I] != 0x00)))				{					u32ReturnFlag = ~(u32LogicSupportRfidData[u16QuickActionName[u32I]]);					u32RfidFrameData = u32RfidFrameData&u32ReturnFlag;					u32ReturnFlag = 0x01;					s_stActionNameFlag[u32I] = INTERFACE_ACTION_NONE;					u16QuickActionDoingStatus[u32I] = 0x02;									}				else if((u16QuickActionDoingStatus[u32I] == 0x00)&&(u16QuickActionName[u32I]!= INTERFACE_ACTION_NONE)&&(s_stLogicRunInf.u32ScQuickActionTimer >= (u16QuickActionStart[u32I]*83))&&(u16QuickActionIng[u32I] != 0x00))				{					u32RfidFrameData |= u32LogicSupportRfidData[u16QuickActionName[u32I]];					u32ReturnFlag = 0x01;					u32J = 0x00;					InterfaceGetActionNameNumb(u8LogicSupportAction[u16QuickActionName[u32I]],&u32J);					s_stActionNameFlag[u32ActionNameWriteptr++] = (INTERFACE_ACTION_TYPE)(u32J);					u32ActionNameWriteptr %= LOGIC_QUICK_ACTIONNUMB_MAX;					u16QuickActionDoingStatus[u32I] = 0x01;					}				else if(u16QuickActionDoingStatus[u32I] == 0x01)				{					u32RfidFrameData |= u32LogicSupportRfidData[u16QuickActionName[u32I]];					u32ReturnFlag = 0x01;					u32J = 0x00;					InterfaceGetActionNameNumb(u8LogicSupportAction[u16QuickActionName[u32I]],&u32J);									s_stActionNameFlag[u32ActionNameWriteptr++] = (INTERFACE_ACTION_TYPE)(u32J);					u32ActionNameWriteptr %= LOGIC_QUICK_ACTIONNUMB_MAX;									}				else								;			}		}		/**对显示动作名称进行整理***/		for(u32I = 0x00;u32I < LOGIC_QUICK_ACTIONNUMB_MAX;u32I++)		{			if(s_stActionNameFlag[u32I] == INTERFACE_ACTION_JIANG_ZHU)			{				for(u32J= u32I+0x01;u32J< LOGIC_QUICK_ACTIONNUMB_MAX;u32J++)				{					if((s_stActionNameFlag[u32J] == INTERFACE_ACTION_JIANG_QIANZHU)	\						||(s_stActionNameFlag[u32J] == INTERFACE_ACTION_JIANG_HOUZHU))					{						s_stActionNameFlag[u32J] = INTERFACE_ACTION_NONE;					}				}			}			if(s_stActionNameFlag[u32I] == INTERFACE_ACTION_JIANG_QIANZHU)			{				for(u32J= u32I+0x01;u32J< LOGIC_QUICK_ACTIONNUMB_MAX;u32J++)				{					if((s_stActionNameFlag[u32J] == INTERFACE_ACTION_JIANG_HOUZHU)	)					{						s_stActionNameFlag[u32I] = INTERFACE_ACTION_JIANG_ZHU;						s_stActionNameFlag[u32J] = INTERFACE_ACTION_NONE;					}				}			}				if(s_stActionNameFlag[u32I] == INTERFACE_ACTION_JIANG_HOUZHU)			{				for(u32J= u32I+0x01;u32J< LOGIC_QUICK_ACTIONNUMB_MAX;u32J++)				{					if((s_stActionNameFlag[u32J] == INTERFACE_ACTION_JIANG_QIANZHU))					{						s_stActionNameFlag[u32I] = INTERFACE_ACTION_JIANG_ZHU;						s_stActionNameFlag[u32J] = INTERFACE_ACTION_NONE;					}				}			}						}		for(u32I = 0x00;u32I < LOGIC_QUICK_ACTIONNUMB_MAX;u32I++)		{			if(s_stActionNameFlag[u32I] == INTERFACE_ACTION_NONE)				{				for(u32J= u32I+0x01;u32J< LOGIC_QUICK_ACTIONNUMB_MAX;u32J++)				{					if(s_stActionNameFlag[u32J] != INTERFACE_ACTION_NONE)					{						s_stActionNameFlag[u32I] = s_stActionNameFlag[u32J];						s_stActionNameFlag[u32J] = INTERFACE_ACTION_NONE;					}				}			}		}				/**执行对应的动作***/		if((u32RfidFrameData != 0x00) && (u32RfidFrameData != u32RfidFrameDataBackup))		{				u32RfidFrameData |= (RFID_FRAME_ACTION<<30);						InterfaceSetActionName(s_stActionNameFlag);				if(s_stLogicRunInf.u32ScQuickActionTimer)			{					InterfaceInsertNote(INTERFACE_NOTE_ACTION_ING);								InterfaceSetUpdateMainMethod(INTERFACE_SHOW_MAIN_NOTE|INTERFACE_SHOW_SC_SELF_CONTROL);//显示主屏所有信息						OSSemPost(g_stSemInterface);			}			else							;			u32RfidDataType = RFID_FRAME_ACTION;			LogicRunInfApi(LOGIC_SET_RFID_FRAME_TYPE, &u32RfidDataType);//发送的数据			LogicRunInfApi(LOGIC_SET_SC_ACTION_NAME, &u32RfidFrameData);//发送的数据				g_stLogicSem->OSEventCnt = 0;			u32ReturnFlag = SC_BUTTON_ACK_NONE;			LogicRunInfApi(LOGIC_SET_BUTTON_ACCEPT_STATUS,&u32ReturnFlag);//将应答设为无效				u32ReturnFlag = RFID_ACTION_NONE;			LogicRunInfApi(LOGIC_SET_BUTTON_ACK_VALUE,&u32ReturnFlag);//将应答动作字设为无效						u32ReturnFlag = (u32)(u32RfidFrameData|(u32RfidDataType<<30));			LogicRunInfApi(LOGIC_SET_BUTTON_VALUE,&u32ReturnFlag);				LogicParamApi(LOGIC_GET_RFID_SENDTIMES, &u16QuickEnableFlag);			LogicParamApi(LOGIC_GET_RFID_TINMEOUT, &u16QuickActionNumb);				u32ReturnFlag = (u32)(u16QuickEnableFlag*u16QuickActionNumb);				u32ReturnFlag += 30;					OSSemPend(g_stLogicSem,u32ReturnFlag/TICK_TIME,&err);				if(err == OS_ERR_TIMEOUT)//无应答			{				u32I = SC_ACTION_QUICK_STOP;				u32ReturnFlag = LogicRunInfApi(LOGIC_SET_SC_QUICK_TYPE, &u32I);					InterfaceSetCtrlMode(INTERFACE_MODE_SC_SELF_CONTROL);				InterfaceInsertNote(INTERFACE_NOTE_NO_ACK);				InterfaceSetUpdateMainMethod(INTERFACE_SHOW_MAIN_NOTE);//显示主屏所有信息						OSSemPost(g_stSemInterface);							}			else if(err == OS_ERR_NONE)//有应答			{				/**关于设置的一些特殊模式切换的处理*/				LogicRunInfApi(LOGIC_GET_BUTTON_ACCEPT_STATUS, &err);				LogicRunInfApi(LOGIC_GET_BUTTON_VALUE,&u32I);				LogicRunInfApi(LOGIC_GET_BUTTON_ACK_VALUE,&u32J);				if((err == SC_BUTTON_ACK_ACCEPT) && (u32I == u32J))				{					s_stLogicRunInf.u32ScQuickActionTimer += u32ReturnFlag;						u32ReturnFlag = (u32)(u32RfidFrameData|(u32RfidDataType<<30));					LogicRunInfApi(LOGIC_SET_BUTTON_LONG_VALUE,&u32ReturnFlag);										}				else if((err == SC_BUTTON_ACK_REJECT))				{					u32I = SC_ACTION_QUICK_STOP;					u32ReturnFlag = LogicRunInfApi(LOGIC_SET_SC_QUICK_TYPE, &u32I);					InterfaceSetCtrlMode(INTERFACE_MODE_SC_SELF_CONTROL);					InterfaceInsertNote(INTERFACE_NOTE_BUTTON_REJECT);					InterfaceSetUpdateMainMethod(INTERFACE_SHOW_MAIN_NOTE);//显示主屏所有信息							OSSemPost(g_stSemInterface);									}				else				{					u32I = SC_ACTION_QUICK_STOP;					u32ReturnFlag = LogicRunInfApi(LOGIC_SET_SC_QUICK_TYPE, &u32I);					InterfaceSetCtrlMode(INTERFACE_MODE_SC_SELF_CONTROL);					InterfaceInsertNote(INTERFACE_NOTE_NO_ACK);					InterfaceSetUpdateMainMethod(INTERFACE_SHOW_MAIN_NOTE);//显示主屏所有信息							OSSemPost(g_stSemInterface);														}						}			else				;			}		else if((u32RfidFrameData == 0x00) && (u32RfidFrameDataBackup != 0x00))		{			u32RfidDataType = RFID_FRAME_ACTION;			LogicRunInfApi(LOGIC_SET_RFID_FRAME_TYPE, &u32RfidDataType);//发送的数据			LogicRunInfApi(LOGIC_SET_SC_ACTION_NAME, &u32RfidFrameDataBackup);//发送的数据			u32J = (u32)(u32RfidFrameDataBackup|(u32RfidDataType<<30));			LogicRunInfApi(LOGIC_SET_BUTTON_UP, &u32J);						//查找是否还有需要继续执行的动作			u32ActionNameWriteptr = 0x00;				if(s_stLogicRunInf.u32ScQuickActionType != SC_ACTION_QUICK_STOP)			{				for(u32I = 0x00; u32I < u16QuickActionNumb;u32I++)				{					if((u16QuickActionDoingStatus[u32I] == 0x00)&&(u16QuickActionName[u32I]!= INTERFACE_ACTION_NONE)&&(s_stLogicRunInf.u32ScQuickActionTimer < (u16QuickActionStart[u32I]*100)))					{						InterfaceGetActionNameNumb(u8LogicSupportAction[u16QuickActionName[u32I]],&u32J);						s_stActionNameFlag[u32ActionNameWriteptr++] = (INTERFACE_ACTION_TYPE)(u32J);						InterfaceSetActionName(s_stActionNameFlag);					}				}			}			else				;			if(u32ActionNameWriteptr == 0x00)//没有需要发送的数据了			{				if(s_stLogicRunInf.u32ScQuickActionType != SC_ACTION_QUICK_STOP)					InterfaceInsertNote(INTERFACE_NOTE_ACTION_JIANGYI_END);				InterfaceSetCtrlMode(INTERFACE_MODE_SC_SELF_CONTROL);				InterfaceSetUpdateMainMethod(INTERFACE_SHOW_MAIN_NOTE|INTERFACE_SHOW_SC_SELF_CONTROL);//显示主屏所有信息						OSSemPost(g_stSemInterface);									u32J = LOGIC_STATUS_RFID_SC_SELF_CONTROL;				LogicRunInfApi(LOGIC_SET_RUN_STATUS,&u32J);								s_stLogicRunInf.u32ScQuickActionType = SC_ACTION_QUICK_DONE;								memset(s_stActionNameFlag,INTERFACE_ACTION_NONE,sizeof(s_stActionNameFlag));				memset(u16QuickActionDoingStatus,0x00,sizeof(u16QuickActionDoingStatus));				u32RfidDataType = 0x00;				u32RfidFrameData = 0x00;				u32RfidFrameDataBackup = 0x00;					InterfaceSetActionName(s_stActionNameFlag);				s_stLogicRunInf.u32ScQuickActionTimer  = 0x00;			}				else//还有数据需要发送							{				if(s_stLogicRunInf.u32ScQuickActionTimer)				{						InterfaceInsertNote(INTERFACE_NOTE_ACTION_ALARAM);					InterfaceSetUpdateMainMethod(INTERFACE_SHOW_MAIN_NOTE|INTERFACE_SHOW_SC_SELF_CONTROL);//显示主屏所有信息							OSSemPost(g_stSemInterface);									}			}		}		else if((u32RfidFrameData == 0x00) && (u32RfidFrameDataBackup == 0x00)&&(s_stLogicRunInf.u32ScQuickActionType == SC_ACTION_QUICK_STOP))		{				u32J = LOGIC_STATUS_RFID_SC_SELF_CONTROL;				LogicRunInfApi(LOGIC_SET_RUN_STATUS,&u32J);												memset(s_stActionNameFlag,INTERFACE_ACTION_NONE,sizeof(s_stActionNameFlag));				memset(u16QuickActionDoingStatus,0x00,sizeof(u16QuickActionDoingStatus));				u32RfidDataType = 0x00;				u32RfidFrameData = 0x00;				u32RfidFrameDataBackup = 0x00;					InterfaceSetActionName(s_stActionNameFlag);				s_stLogicRunInf.u32ScQuickActionTimer  = 0x00;					}		else			;		u32RfidFrameDataBackup = u32RfidFrameData;				if((s_stLogicRunInf.u32ScQuickActionType != SC_ACTION_QUICK_STOP)&&(s_stLogicRunInf.u32ScQuickActionType != SC_ACTION_QUICK_DONE))		{				s_stLogicRunInf.u32ScQuickActionTimer += LOGIC_TASK_TIME_SET;					InterfaceSetCtrlMode(INTERFACE_MODE_SC_SELF_QUICK);		}				return u32ReturnFlag;	}#endif/*********************************************************************************************函数名称：LogicStatusRfidTransPrgProc**函数作用：逻辑层红外开始搜索其他遥控器设备参数状态处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/#if (ONLINE_UPDATE_SELF_PRG_PT_FLAG	!= DISABLED)	static u32 LogicStatusRfidTransPrgProc(void)	{		u32 u32Temp = s_u32DownProgAddr-THE_DEV_PRG_STORAGE_BASEADDR;		u32 u32SendLength = 0x00;		u8 u8Buf[60];				if(s_u32SendInterval > LOGIC_TASK_TIME_SET)			s_u32SendInterval -= LOGIC_TASK_TIME_SET;		else			s_u32SendInterval = 0x00;				if(s_u32SendInterval == 0x00)		{			u32SendLength = (sizeof(RFID_UPDATE_FRAME_TYPE)-sizeof(u8)-sizeof(u32)-0x03);						u32Temp = u32Temp/DEV_PROGRAM_VERSION_SIZE;			u32Temp++;			u32Temp *= DEV_PROGRAM_VERSION_SIZE;			if(u32Temp > (s_u32DownProgLength+DEV_PROGRAM_VERSION_SIZE))				u32Temp = s_u32DownProgLength+DEV_PROGRAM_VERSION_SIZE;			if((s_u32DownProgAddr+u32SendLength) >  (u32Temp+THE_DEV_PRG_STORAGE_BASEADDR))			{				u32SendLength = u32Temp+THE_DEV_PRG_STORAGE_BASEADDR - s_u32DownProgAddr;			}		}					if(s_u32SendInterval == 0x00)		{			if((s_u32DownProgAddr-THE_DEV_PRG_STORAGE_BASEADDR) < DEV_PROGRAM_VERSION_SIZE)			{				s_u32DownProgSendPacketNumb++;							IapReadBuf(u8Buf,s_u32DownProgAddr,u32SendLength);				RfidUpdateSendPrgData(s_u32DestDevID,RFID_FT_UPDATE_DWL_VERSION,s_u32DownProgSendPacketNumb,u8Buf,u32SendLength);				s_u32DownProgAddr += u32SendLength;				s_u32SendInterval = LOGIC_UPDATE_SEND_INTERVAL_SET;				if(s_u32DownProgAddr == (THE_DEV_PRG_STORAGE_BASEADDR+u32SendLength))				{					OSTimeDly(LOGIC_UPDATE_SEND_INTERVAL_SET/TICK_TIME);					//RfidUpdateSendPrgData(s_u32DestDevID,RFID_FT_UPDATE_DWL_VERSION,s_u32DownProgSendPacketNumb,u8Buf,u32SendLength);					/**无论传输的何种设备的程序，以擦除相关区域的最大时间进行估计***/					if ((s_u32DownProgramType== SS_DEV_TYPE)|| (s_u32DownProgramType == SC_DEV_TYPE))//支架控制器硬件，计算区域大小						s_u32SendInterval = THE_DYK_DEV_STORAGE_SIZEMAX;					else	//其他设备，按照最大值YKQ程序的大小进行计算						s_u32SendInterval = THE_DEV_PRG_STORAGE_SIZE;					if(s_u32SendInterval%THE_DEV_PRG_BULK_SIZE)					{						s_u32SendInterval /= THE_DEV_PRG_BULK_SIZE;						s_u32SendInterval += 0x01;					}					else						s_u32SendInterval /= THE_DEV_PRG_BULK_SIZE;					s_u32SendInterval *= FLASH_BULK_ERASER_TIME;					}				if((s_u32DownProgAddr-THE_DEV_PRG_STORAGE_BASEADDR) == DEV_PROGRAM_VERSION_SIZE)				{					OSTimeDly(LOGIC_UPDATE_SEND_INTERVAL_SET/TICK_TIME);					u8Buf[0x00] = 0x01;					u32SendLength = 0x01;					RfidUpdateSendPrgData(s_u32DestDevID,RFID_FT_UPDATE_WRITE_VERSION,s_u32DownProgSendPacketNumb,u8Buf,u32SendLength);									s_u32DownProgSendPacketNumb = 0x00;				}								InterfaceSetCtrlMode(INTERFACE_MODE_TRANS_PRG);									}			else if((s_u32DownProgAddr-THE_DEV_PRG_STORAGE_BASEADDR-DEV_PROGRAM_VERSION_SIZE) < s_u32DownProgLength)			{				s_u32DownProgSendPacketNumb++;							IapReadBuf(u8Buf,s_u32DownProgAddr,u32SendLength);				RfidUpdateSendPrgData(s_u32DestDevID,RFID_FT_UPDATE_DWL_CODE,s_u32DownProgSendPacketNumb,u8Buf,u32SendLength);				s_u32DownProgAddr += u32SendLength;				s_u32SendInterval = LOGIC_UPDATE_SEND_INTERVAL_SET;				InterfaceSetCtrlMode(INTERFACE_MODE_TRANS_PRG);								if((((s_u32DownProgAddr-THE_DEV_PRG_STORAGE_BASEADDR)%DEV_PROGRAM_VERSION_SIZE) == 0x00)\					||((s_u32DownProgAddr-THE_DEV_PRG_STORAGE_BASEADDR-DEV_PROGRAM_VERSION_SIZE) == s_u32DownProgLength))				{					OSTimeDly(LOGIC_UPDATE_SEND_INTERVAL_SET/TICK_TIME);										u8Buf[0x00] = 0x01;					u32SendLength = 0x01;					RfidUpdateSendPrgData(s_u32DestDevID,RFID_FT_UPDATE_WRITE_CODE,s_u32DownProgSendPacketNumb,u8Buf,u32SendLength);										}								if((s_u32DownProgAddr-THE_DEV_PRG_STORAGE_BASEADDR-DEV_PROGRAM_VERSION_SIZE) == s_u32DownProgLength)				{					OSTimeDly(LOGIC_UPDATE_SEND_INTERVAL_SET/TICK_TIME);										u8Buf[0x00] = 0x01;					u32SendLength = 0x01;					RfidUpdateSendPrgData(s_u32DestDevID,RFID_FT_UPDATE_END,s_u32DownProgSendPacketNumb,u8Buf,u32SendLength);					OSTimeDly(LOGIC_UPDATE_SEND_INTERVAL_SET/TICK_TIME);											OSTaskSuspend(INTERFACE_TASK_PRIO);					StateLed(0x00,ADJUST_CODE_ING_LED);						KeyLedOnOff(0x00,KEY_LED_ALL);										s_u32SendInterval = 0x00;					s_u32DownProgAddr = 0x00;					s_u32DownProgSendPacketNumb = 0x00;					s_u32DownProgLength= 0x00;					LcdAreaClear(OLED_DISPLAY_NORMAL,6,0,7,127);					ShowStr(OLED_DISPLAY_NORMAL,"发送已完成",6, 19);					OSTimeDly(1500/TICK_TIME);					LcdAreaClear(OLED_DISPLAY_NORMAL,6,0,7,127);					ShowStr(OLED_DISPLAY_NORMAL,"即将重启",6, 32);					OSTimeDly(1500/TICK_TIME);					u32Temp = YKQ_SHUTDOWN_NO_SLEEP;					LogicParamApi(LOGIC_SET_SHUTDOWM_FLAG,&u32Temp);					#ifdef IWDG_ENABLED						IWDG_Feed();					#endif						#if (BSP_PRG_STORAGE_FLASH_FLAG	==	BSP_PRG_STORAGE_INFLASH_USE)						__disable_fault_irq();						FLASH_SetLatency(THE_DEV_FLASH_Latency);//120 MHz< HCLK <= 168 MHz						FLASH_Unlock();								#endif								IapEraserSector(MY_DEV_TYPE_ADDRESS);					IapReadBuf((u8 *)&u32Temp,THE_DEV_PRG_STORAGE_BASEADDR+PROG_WRITE_BASE_ADDRESS,0x04);					IapWriteBuf((u8 *)&u32Temp, APP_WRITE_BASEADDRESS, 0x04);					IapWriteBuf((u8 *)&u32Temp, APP_WRITE_BASEADDRESS, 0x04);										IapReadBuf((u8 *)&u32Temp,THE_DEV_PRG_STORAGE_BASEADDR+PROG_DEVTYPE_OFFSET_ADDRESS,0x04);					IapWriteBuf((u8 *)&u32Temp, MY_DEV_TYPE_ADDRESS, 0x04);					IapWriteBuf((u8 *)&u32Temp, MY_DEV_TYPE_ADDRESS, 0x04);										u32Temp = RROG_DOWNLOAD_FLAG;					IapWriteBuf((u8 *)&u32Temp, APP_DOWNLOAD_OFFSET_ADDRESS, 0x04);					IapWriteBuf((u8 *)&u32Temp, APP_DOWNLOAD_OFFSET_ADDRESS, 0x04);										u32Temp = RROG_UPDATE_FLAG;					IapWriteBuf((u8 *)&u32Temp, APP_UPDATE_OFFSET_ADDRESS, 0x04);						IapWriteBuf((u8 *)&u32Temp, APP_UPDATE_OFFSET_ADDRESS, 0x04);															u32Temp = (Version[8]-0x30)|(((Version[6]-0x30)+(Version[5]-0x30)*10)<<8)|((Version[3]-0x30)<<16)|((Version[1]-0x30)<<24);						IapWriteBuf((u8 *)&u32Temp, APP_VERSION_ADDRESS, 0x04);						IapWriteBuf((u8 *)&u32Temp, APP_VERSION_ADDRESS, 0x04);					#if (BSP_PRG_STORAGE_FLASH_FLAG	==	BSP_PRG_STORAGE_INFLASH_USE)						FLASH_Lock();						__enable_fault_irq();								#endif											#ifdef IWDG_ENABLED						IWDG_Feed();					#endif					//进行程序的跳转,跳至BOOTLOADER					IapJumpToBoot(IN_FLASH_BOOTLOADER_ADDR);				}			}					else			{				InterfaceSetCtrlMode(INTERFACE_MODE_TRANS_PRG);			}							}				return 0x01;	}#endif			/*********************************************************************************************函数名称：LogicStatusRfidTransWLPrgProc**函数作用：传输无线程序（全面）**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/#if (ONLINE_UPDATE_SELF_PRG_PT_FLAG	!= DISABLED)	static u32 LogicStatusRfidTransWLPrgProc(void)	{		u32 u32Temp = s_u32DownProgAddr-YKQ_WL_PROGRAM_BASE_ADDRESS;		u32 u32SendLength = 0x00;		u8 u8Buf[60];				#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */			OS_CPU_SR  cpu_sr = 0;		#endif				if(s_u32SendInterval > LOGIC_TASK_TIME_SET)			s_u32SendInterval -= LOGIC_TASK_TIME_SET;		else			s_u32SendInterval = 0x00;				if(s_u32SendInterval == 0x00)		{			u32SendLength = (sizeof(RFID_UPDATE_FRAME_TYPE)-sizeof(u8)-sizeof(u32)-0x03);						u32Temp = u32Temp/DEV_PROGRAM_VERSION_SIZE;			u32Temp++;			u32Temp *= DEV_PROGRAM_VERSION_SIZE;			if(u32Temp > (s_u32DownProgLength+DEV_PROGRAM_VERSION_SIZE))				u32Temp = s_u32DownProgLength+DEV_PROGRAM_VERSION_SIZE;			if((s_u32DownProgAddr+u32SendLength) >  (u32Temp+YKQ_WL_PROGRAM_BASE_ADDRESS))			{				u32SendLength = u32Temp+YKQ_WL_PROGRAM_BASE_ADDRESS - s_u32DownProgAddr;			}		}				if(s_u32SendInterval == 0x00)		{			if((s_u32DownProgAddr-YKQ_WL_PROGRAM_BASE_ADDRESS) < DEV_PROGRAM_VERSION_SIZE)			{				s_u32DownProgSendPacketNumb++;							IapReadBuf(u8Buf,s_u32DownProgAddr,u32SendLength);				RfidUpdateSendPrgData(s_u32DestDevID,WL_RFID_FT_UPDATE_DWL_VERSION,s_u32DownProgSendPacketNumb,u8Buf,u32SendLength);				s_u32DownProgAddr += u32SendLength;				s_u32SendInterval = LOGIC_UPDATE_SEND_INTERVAL_SET;				if(s_u32DownProgAddr == (YKQ_WL_PROGRAM_BASE_ADDRESS+u32SendLength))				{					OSTimeDly(LOGIC_UPDATE_SEND_INTERVAL_SET/TICK_TIME);					//RfidUpdateSendPrgData(s_u32DestDevID,RFID_FT_UPDATE_DWL_VERSION,s_u32DownProgSendPacketNumb,u8Buf,u32SendLength);					/**无论传输的何种设备的程序，以擦除相关区域的最大时间进行估计***/					if ((s_u32DownProgramType== SS_DEV_TYPE)|| (s_u32DownProgramType == SC_DEV_TYPE))//支架控制器硬件，计算区域大小						s_u32SendInterval = THE_DYK_DEV_STORAGE_SIZEMAX;					else	//其他设备，按照最大值YKQ程序的大小进行计算						s_u32SendInterval = THE_DEV_PRG_STORAGE_SIZE;					if(s_u32SendInterval%THE_DEV_PRG_BULK_SIZE)					{						s_u32SendInterval /= THE_DEV_PRG_BULK_SIZE;						s_u32SendInterval += 0x01;					}					else						s_u32SendInterval /= THE_DEV_PRG_BULK_SIZE;					s_u32SendInterval *= FLASH_BULK_ERASER_TIME;					}				if((s_u32DownProgAddr-YKQ_WL_PROGRAM_BASE_ADDRESS) == DEV_PROGRAM_VERSION_SIZE)				{					OSTimeDly(LOGIC_UPDATE_SEND_INTERVAL_SET/TICK_TIME);					u8Buf[0x00] = 0x01;					u32SendLength = 0x01;					RfidUpdateSendPrgData(s_u32DestDevID,WL_RFID_FT_UPDATE_WRITE_VERSION,s_u32DownProgSendPacketNumb,u8Buf,u32SendLength);									s_u32DownProgSendPacketNumb = 0x00;				}								InterfaceSetCtrlMode(INTERFACE_MODE_TRANS_PRG);									}			else if((s_u32DownProgAddr-YKQ_WL_PROGRAM_BASE_ADDRESS-DEV_PROGRAM_VERSION_SIZE) < s_u32DownProgLength)			{				s_u32DownProgSendPacketNumb++;							IapReadBuf(u8Buf,s_u32DownProgAddr,u32SendLength);				RfidUpdateSendPrgData(s_u32DestDevID,WL_RFID_FT_UPDATE_DWL_CODE,s_u32DownProgSendPacketNumb,u8Buf,u32SendLength);				s_u32DownProgAddr += u32SendLength;				s_u32SendInterval = LOGIC_UPDATE_SEND_INTERVAL_SET;				InterfaceSetCtrlMode(INTERFACE_MODE_TRANS_PRG);								if((((s_u32DownProgAddr-YKQ_WL_PROGRAM_BASE_ADDRESS)%DEV_PROGRAM_VERSION_SIZE) == 0x00)\					||((s_u32DownProgAddr-YKQ_WL_PROGRAM_BASE_ADDRESS-DEV_PROGRAM_VERSION_SIZE) == s_u32DownProgLength))				{					OSTimeDly(LOGIC_UPDATE_SEND_INTERVAL_SET/TICK_TIME);										u8Buf[0x00] = 0x01;					u32SendLength = 0x01;					RfidUpdateSendPrgData(s_u32DestDevID,WL_RFID_FT_UPDATE_WRITE_CODE,s_u32DownProgSendPacketNumb,u8Buf,u32SendLength);										}								if((s_u32DownProgAddr-YKQ_WL_PROGRAM_BASE_ADDRESS-DEV_PROGRAM_VERSION_SIZE) == s_u32DownProgLength)				{					OSTimeDly(LOGIC_UPDATE_SEND_INTERVAL_SET/TICK_TIME);										u8Buf[0x00] = 0x01;					u32SendLength = 0x01;					RfidUpdateSendPrgData(s_u32DestDevID,WL_RFID_FT_UPDATE_END,s_u32DownProgSendPacketNumb,u8Buf,u32SendLength);					OSTimeDly(LOGIC_UPDATE_SEND_INTERVAL_SET/TICK_TIME);											StateLed(0x00,ADJUST_CODE_ING_LED);						KeyLedOnOff(0x00,KEY_LED_ALL);										s_u32SendInterval = 0x00;					s_u32DownProgAddr = 0x00;					s_u32DownProgSendPacketNumb = 0x00;					s_u32DownProgLength= 0x00;					LcdAreaClear(OLED_DISPLAY_NORMAL,6,0,7,127);					ShowStr(OLED_DISPLAY_NORMAL,"发送已完成",6, 19);					OSTimeDly(150/TICK_TIME);					OSTaskDel(RFIDMNG_UPDATE_TASK_PRIO);													if(g_u32ID == B_type)					{					  OS_ENTER_CRITICAL();												RFID_Init(RFID_PRG_ININT_SYNC0,RFID_PRG_ININT_SYNC1);						RfidMngSetRecvCallBack();					  OS_EXIT_CRITICAL();											}					else					{						SendSetupToWl(RFID_PRG_ININT_SYNC1);					}					OSTaskResume(IRMNG_TASK_PRIO);					OSTaskCreate(RfidMng_Task, (void *)0, &RfidMng_task_stk[RFIDMNG_TASK_STK_SIZE - 1], RFIDMNG_TASK_PRIO); 										OSTimeDly(150/TICK_TIME);								StateLed(0x00,ADJUST_CODE_ING_LED);															u32Temp = LOGIC_STATUS_IDLE;					LogicRunInfApi(LOGIC_SET_RUN_STATUS,&u32Temp);										InterfaceInsertNote(INTERFACE_NOTE_SYSTEM_IDLE);						InterfaceSetCtrlMode(INTERFACE_MODE_IDLE);					InterfaceSetUpdateMainMethod(INTERFACE_SHOW_MAIN_ALL);					OSSemPost(g_stSemInterface);									}			}					else			{				InterfaceSetCtrlMode(INTERFACE_MODE_TRANS_PRG);			}								}				return 0x01;	}#endif	/*********************************************************************************************函数名称：LogicStatusUsartTransWLPrgProc**函数作用：	传输本地程序（本地）**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/		#if (ONLINE_UPDATE_SELF_PRG_PT_FLAG	!= DISABLED)	static u32 LogicStatusUsartTransWLPrgProc(void)	{		u32 u32Temp = s_u32DownProgAddr-YKQ_WL_PROGRAM_BASE_ADDRESS;		u32 u32SendLength = 0x00;		u8 u8Buf[128];		memset(u8Buf,0,0x80);				if(s_u32SendInterval > LOGIC_TASK_TIME_SET)			s_u32SendInterval -= LOGIC_TASK_TIME_SET;		else			s_u32SendInterval = 0x00;				if(s_u32SendInterval == 0x00)		{			u32SendLength = (sizeof(stUSARTDATA)-0x07);						u32Temp = u32Temp/DEV_PROGRAM_VERSION_SIZE;			u32Temp++;			u32Temp *= DEV_PROGRAM_VERSION_SIZE;			if(u32Temp > (s_u32DownProgLength+DEV_PROGRAM_VERSION_SIZE))				u32Temp = s_u32DownProgLength+DEV_PROGRAM_VERSION_SIZE;			if((s_u32DownProgAddr+u32SendLength) >  (u32Temp+YKQ_WL_PROGRAM_BASE_ADDRESS))			{				u32SendLength = u32Temp+YKQ_WL_PROGRAM_BASE_ADDRESS - s_u32DownProgAddr;			}		}		if(s_u32SendInterval == 0x00)		{			if((s_u32DownProgAddr-YKQ_WL_PROGRAM_BASE_ADDRESS) < DEV_PROGRAM_VERSION_SIZE)			{				s_u32DownProgSendPacketNumb++;							IapReadBuf(u8Buf,s_u32DownProgAddr,u32SendLength);				InsUsartTrsQueue(u8Buf,u32SendLength,UPDATAPROGRAM,1,1);				s_u32DownProgAddr += u32SendLength;				s_u32SendInterval = LOGIC_UPDATE_SEND_INTERVAL_SET;				if(s_u32DownProgAddr == (YKQ_WL_PROGRAM_BASE_ADDRESS+u32SendLength))				{					OSTimeDly(LOGIC_UPDATE_SEND_INTERVAL_SET/TICK_TIME);					//RfidUpdateSendPrgData(s_u32DestDevID,RFID_FT_UPDATE_DWL_VERSION,s_u32DownProgSendPacketNumb,u8Buf,u32SendLength);					/**无论传输的何种设备的程序，以擦除相关区域的最大时间进行估计***/					if ((s_u32DownProgramType== SS_DEV_TYPE)|| (s_u32DownProgramType == SC_DEV_TYPE))//支架控制器硬件，计算区域大小						s_u32SendInterval = THE_DYK_DEV_STORAGE_SIZEMAX;					else	//其他设备，按照最大值YKQ程序的大小进行计算						s_u32SendInterval = YKQ_WL_PROGRAM_SIZE;					if(s_u32SendInterval%THE_DEV_PRG_BULK_SIZE)					{						s_u32SendInterval /= THE_DEV_PRG_BULK_SIZE;						s_u32SendInterval += 0x01;					}					else						s_u32SendInterval /= THE_DEV_PRG_BULK_SIZE;					s_u32SendInterval *= FLASH_BULK_ERASER_TIME;					}							InterfaceSetCtrlMode(INTERFACE_MODE_TRANS_PRG);									}			else if((s_u32DownProgAddr-YKQ_WL_PROGRAM_BASE_ADDRESS-DEV_PROGRAM_VERSION_SIZE) < s_u32DownProgLength)			{				IapReadBuf(u8Buf,s_u32DownProgAddr,u32SendLength);				InsUsartTrsQueue(u8Buf,u32SendLength,UPDATAPROGRAM,1,1);				s_u32DownProgAddr += u32SendLength;				s_u32SendInterval = LOGIC_UPDATE_SEND_INTERVAL_SET;				InterfaceSetCtrlMode(INTERFACE_MODE_TRANS_PRG);												if((s_u32DownProgAddr-YKQ_WL_PROGRAM_BASE_ADDRESS-DEV_PROGRAM_VERSION_SIZE) == s_u32DownProgLength)				{					OSTimeDly(LOGIC_UPDATE_SEND_INTERVAL_SET/TICK_TIME);					u8Buf[0x00] = 0x01;					u32SendLength = 0x01;					InsUsartTrsQueue(u8Buf,u32SendLength,UPDATAPROGRAM,0,1);										StateLed(0x00,ADJUST_CODE_ING_LED);						KeyLedOnOff(0x00,KEY_LED_ALL);										s_u32SendInterval = 0x00;					s_u32DownProgAddr = 0x00;					s_u32DownProgSendPacketNumb = 0x00;					s_u32DownProgLength= 0x00;					LcdAreaClear(OLED_DISPLAY_NORMAL,6,0,7,127);					ShowStr(OLED_DISPLAY_NORMAL,"发送已完成",6, 19);					OSTimeDly(2000/TICK_TIME);					OSTaskDel(RFIDMNG_UPDATE_TASK_PRIO);					u32Temp = LOGIC_STATUS_IDLE;					LogicRunInfApi(LOGIC_SET_RUN_STATUS,&u32Temp);					SendSetupToWl(RFID_ININT_SYNC1);					OSTaskResume(IRMNG_TASK_PRIO);					OSTaskCreate(RfidMng_Task, (void *)0, &RfidMng_task_stk[RFIDMNG_TASK_STK_SIZE - 1], RFIDMNG_TASK_PRIO); 										OSTimeDly(150/TICK_TIME);								StateLed(0x00,ADJUST_CODE_ING_LED);										InterfaceInsertNote(INTERFACE_NOTE_SYSTEM_IDLE);						InterfaceSetCtrlMode(INTERFACE_MODE_IDLE);					InterfaceSetUpdateMainMethod(INTERFACE_SHOW_MAIN_ALL);					OSSemPost(g_stSemInterface);											//				OSTimeDly(100);	//				YKQUpdateStatus = YKQ_UPDATE_PRG_ALL;//				if(g_u32ID != B_type)//					WirelessChipPwrOn();//				u32Temp = LOGIC_STATUS_RFID_CXB_RECV_WL_PRG;//				LogicRunInfApi(LOGIC_SET_RUN_STATUS,&u32Temp);					}			}					else			{				InterfaceSetCtrlMode(INTERFACE_MODE_TRANS_PRG);			}							}			return 0x01;	}#endif/*********************************************************************************************函数名称：LogicStatusRfidRecvWLPrgProc**函数作用：逻辑层接收无线程序**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/	static u32 LogicStatusRfidRecvWLPrgProc(void){	u32 u32Temp = 0x01;	u16 u16CrcTemp = 0x00;		u32 u32Temp2 = 0x00;	#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */		OS_CPU_SR  cpu_sr = 0;	#endif		#ifdef IWDG_ENABLED		IWDG_Feed();	#endif		/**先判断程序的正确性**/	s_u32DownProgramType	= YKQ_WL_DEV_TYPE;		/**判断外扩FLASH中是否有程序**/	if(IapGetPrgStorageAddr(s_u32DownProgramType, &s_u32DownProgAddr) != 0x01)//读取外扩中的基地址		u32Temp = 0x00;		/**计算版本信息的CRC***/	u16CrcTemp = 0x00;	u16CrcTemp = IapExFlashCrc(s_u32DownProgAddr,PROG_VER_CRCL_OFFSET_ADDRESS);				IapReadBuf((u8 *)&u32Temp2,s_u32DownProgAddr+PROG_VER_CRCL_OFFSET_ADDRESS,0x04);	u32Temp = (u32)u16CrcTemp;	if(u32Temp != u32Temp2)		u32Temp = 0x00;		//读取文件长度	if(IapGetPrgSize(s_u32DownProgramType, &u32Temp2) != 0x01)//读取外扩中的文件最大长度		u32Temp = 0x00;		IapReadBuf((u8 *)&s_u32DownProgLength,s_u32DownProgAddr+PROG_LENGTH_OFFSET_ADDRESS,0x04);//实际长度	if((s_u32DownProgLength > u32Temp2)||(s_u32DownProgLength == 0xFFFFFFFF) || (s_u32DownProgLength == 0x00))//长度不正确	{		u32Temp = 0x00;	}	LcdClear();			/**此处增加提示讯息**/	if(u32Temp == 0x00)	{			LcdClear();				ShowStr(0, "无程序", 2,40); 		OSTaskSuspend(INTERFACE_TASK_PRIO);			OSTimeDly(2000/TICK_TIME);		OSTaskResume(INTERFACE_TASK_PRIO);				u32Temp = LOGIC_STATUS_IDLE;		LogicRunInfApi(LOGIC_SET_RUN_STATUS,&u32Temp);		InterfaceInsertNote(INTERFACE_NOTE_SYSTEM_IDLE);			InterfaceSetCtrlMode(INTERFACE_MODE_IDLE);		InterfaceSetUpdateMainMethod(INTERFACE_SHOW_MAIN_ALL);		OSSemPost(g_stSemInterface);		return 0x00;			}		//计算程序的CRC，此处增加LCD屏状态显示，防止等待时间过长							ShowStr(0, "更新遥控器程序", 1,8); 														 	ShowStr(0, "检测文件,稍候", 3, 12);	#ifdef IWDG_ENABLED		IWDG_Feed();	#endif	u16CrcTemp = 0x00;	u16CrcTemp = IapExFlashCrc(s_u32DownProgAddr+PROG_CODE_OFFSET_ADDRESS,s_u32DownProgLength);	#ifdef IWDG_ENABLED		IWDG_Feed();		#endif	IapReadBuf((u8 *)&u32Temp2,s_u32DownProgAddr+PROG_CRCL_OFFSET_ADDRESS,0x04);//CRC	 u32Temp = (u32)u16CrcTemp;	if(u32Temp != u32Temp2)	{		LcdClear();				ShowStr(0, "无程序", 2,40); 				OSTaskSuspend(INTERFACE_TASK_PRIO);			OSTimeDly(2000/TICK_TIME);		OSTaskResume(INTERFACE_TASK_PRIO);				u32Temp = LOGIC_STATUS_IDLE;		LogicRunInfApi(LOGIC_SET_RUN_STATUS,&u32Temp);		InterfaceInsertNote(INTERFACE_NOTE_SYSTEM_IDLE);			InterfaceSetCtrlMode(INTERFACE_MODE_IDLE);		InterfaceSetUpdateMainMethod(INTERFACE_SHOW_MAIN_ALL);		OSSemPost(g_stSemInterface);		return 0x00;	}//		LogicParamApi(LOGIC_GET_UPDATE_STATUS, &pData);	/**无论传输的何种设备的程序，以擦除相关区域的最大时间进行估计***/	if ((s_u32DownProgramType== SS_DEV_TYPE)|| (s_u32DownProgramType == SC_DEV_TYPE))//支架控制器硬件，计算区域大小		s_u32SendInterval = THE_DYK_DEV_STORAGE_SIZEMAX;	else	//其他设备，按照最大值HUB程序的大小进行计算		s_u32SendInterval = THE_DEV_PRG_STORAGE_SIZE;	if(s_u32SendInterval%THE_DEV_PRG_BULK_SIZE)	{		s_u32SendInterval /= THE_DEV_PRG_BULK_SIZE;				s_u32SendInterval += 0x01;	}	else		s_u32SendInterval /= THE_DEV_PRG_BULK_SIZE;		s_u32SendInterval *= FLASH_BULK_ERASER_TIME;	/*计算总共需要多少时间*/	IapReadBuf((u8 *)&u32Temp, s_u32DownProgAddr|PROG_LENGTH_OFFSET_ADDRESS, 0x04);//代码长度	/**进行更新自身或本地***/		if(YKQUpdateStatus == YKQ_UPDATE_PRG_SELF)	{		/*计算总共需要多少时间*/		InterfaceSetDownloadRemainTimer(((u32Temp/0x80) * 100*TRANS_PROG_TIMES)+s_u32SendInterval);		if(g_u32ID == B_type)		{						LcdClear();					ShowStr(0, "该版本不支持", 2,5); 				OSTaskSuspend(INTERFACE_TASK_PRIO);				OSTimeDly(2000/TICK_TIME);			OSTaskResume(INTERFACE_TASK_PRIO);			u32Temp = LOGIC_STATUS_IDLE;			LogicRunInfApi(LOGIC_SET_RUN_STATUS,&u32Temp);						OSTimeDly(150/TICK_TIME);						StateLed(0x00,ADJUST_CODE_ING_LED);						InterfaceInsertNote(INTERFACE_NOTE_SYSTEM_IDLE);				InterfaceSetCtrlMode(INTERFACE_MODE_IDLE);			InterfaceSetUpdateMainMethod(INTERFACE_SHOW_MAIN_ALL);			OSSemPost(g_stSemInterface);							return 0x00;					}				s_u32DestDevID = 0x00;//广播帧		s_u32SendInterval = 0x00;		s_u32DownProgSendPacketNumb	= 0x00;					u32Temp = LOGIC_STATUS_USART_TRANS_WL_PRG;		LogicRunInfApi(LOGIC_SET_RUN_STATUS,&u32Temp);		InterfaceInsertNote(INTERFACE_NOTE_PLEASE_DONOT_MOVE);		InterfaceSetCtrlMode(INTERFACE_MODE_TRANS_PRG);		InterfaceSetUpdateMainMethod(INTERFACE_SHOW_MAIN_ALL);		OSSemPost(g_stSemInterface);		StateLed(0x00,KEY_SHIFT_LED|ADJUST_CODE_SUCCEED_LED|ADJUST_CODE_ING_LED);		KeyLedOnOff(0x00,KEY_LED_MAX);		#ifdef IWDG_ENABLED			IWDG_Feed();		#endif		OSTaskDel(RFIDMNG_TASK_PRIO);			OSTaskSuspend(IRMNG_TASK_PRIO);					#if (YKQ_HARDWARE_BEEP_EXIST_DEFINE != DISABLED)			OSTaskSuspend(BUZZERMNG_TASK_PRIO);		#endif					}	else if(YKQUpdateStatus == YKQ_UPDATE_PRG_ALL)	{		/*计算总共需要多少时间*/		InterfaceSetDownloadRemainTimer(((u32Temp/100) * TRANS_RECV_PRG_HUNDRED_BYTES_TIME*TRANS_PROG_TIMES));//jhyjhy		u32Temp = LOGIC_STATUS_RFID_TRANS_WL_PRG;		LogicRunInfApi(LOGIC_SET_RUN_STATUS,&u32Temp);		InterfaceInsertNote(INTERFACE_NOTE_PLEASE_DONOT_MOVE);		InterfaceSetCtrlMode(INTERFACE_MODE_TRANS_PRG);		InterfaceSetUpdateMainMethod(INTERFACE_SHOW_MAIN_ALL);		OSSemPost(g_stSemInterface);		StateLed(0x00,KEY_SHIFT_LED|ADJUST_CODE_SUCCEED_LED|ADJUST_CODE_ING_LED);		KeyLedOnOff(0x00,KEY_LED_MAX);				OSTaskDel(RFIDMNG_TASK_PRIO);		if(g_u32ID != B_type)			OSTaskSuspend(USART_TASK_PRIO);				OSTaskSuspend(IRMNG_TASK_PRIO);			s_u32DestDevID = 0x00;//广播帧		s_u32SendInterval = 0x00;		s_u32DownProgSendPacketNumb	= 0x00;						/**无线更新处理任务**/			if(g_u32ID == B_type)		{			OS_ENTER_CRITICAL();					RFID_Init(RFID_PRG_ININT_SYNC0,RFID_PRG_ININT_SYNC1);			RfidMngSetRecvCallBack();			OS_EXIT_CRITICAL();		}		else		{			SendSetupToWl(RFID_PRG_ININT_SYNC1);		}		/**无线更新程序处理任务**/		#if (ONLINE_UPDATE_SELF_PRG_PT_FLAG	!= DISABLED)			RfidUpdateMngInint();			OSTimeDly(20);			OSTaskCreate(RfidMng_Update_Task, (void *)0, &RfidMng_task_stk[RFIDMNG_UPDATE_TASK_STK_SIZE - 1], RFIDMNG_UPDATE_TASK_PRIO); 		#endif					}	else		;	return 0x01;}	/*********************************************************************************************函数名称：LogicStatusRfidCXBRecvWLPrgProc**函数作用：逻辑层无线模块断开处理逻辑**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/	static u32 LogicStatusUnconnectWLProc(void){		u8 u8Temp;	StateLed(ADJUST_CODE_SUCCEED_LED,ADJUST_CODE_ING_LED);		//关闭绿色指示灯，亮起红色指示灯	//提示无线模块异常	InterfaceInsertNote(WL_UNCONNECTED);	InterfaceSetCtrlMode(INTERFACE_MODE_WL_UNCONNECT);	InterfaceSetUpdateMainMethod(INTERFACE_SHOW_MAIN_NOTE);	OSSemPost(g_stSemInterface);	//清除版本号		for(u8Temp = 0;u8Temp<sizeof(s_stLogicParamSystem.u8WLVersion);u8Temp++)	{		s_stLogicParamSystem.u8WLVersion[u8Temp] = '*';	}		OSTimeDly(200);	StateLed(0x00,KEY_SHIFT_LED|ADJUST_CODE_ING_LED|ADJUST_CODE_SUCCEED_LED);//关闭指示灯	//关闭提示无线模块异常	InterfaceInsertNote(INTERFACE_NOTE_SYSTEM_IDLE);		InterfaceSetUpdateMainMethod(INTERFACE_SHOW_MAIN_ALL);	OSSemPost(g_stSemInterface);	OSTimeDly(200);	return 0x01;	}/*********************************************************************************************函数名称：LogicStatusRfidCXBRecvWLPrgProc**函数作用：逻辑层接收程序棒接收无线数据**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/	static u32 LogicStatusRfidCXBRecvWLPrgProc(void){		stFRAME stSendFrame;		u8 u8YkqID;		u32 u32SendLength = 0x00;		u32 u32ReturnFlag = 0x01;		u32 u32Y = 0x00;		#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */			OS_CPU_SR  cpu_sr = 0;		#endif		if(g_u32ID == B_type)		{			OS_ENTER_CRITICAL();					RFID_Init(RFID_PRG_ININT_SYNC0,RFID_PRG_ININT_SYNC1);			OS_EXIT_CRITICAL();				}					else		{			SendSetupToWl(RFID_PRG_ININT_SYNC1);		}			memset(&stSendFrame,0x00,sizeof(stFRAME));		LogicParamApi(LOGIC_GET_YKQ_NUMBER, &u8YkqID);		stSendFrame.u32ID.ID.RxID = (u8)(SC_DEV_TYPE&0xFF);		stSendFrame.u32ID.ID.TxID = (u8)(WL_DEV_TYPE&0xFF);		stSendFrame.u32ID.ID.FrameType = RFID_FT_KEY_DOWN;		stSendFrame.u32ID.ID.Sum = 0;		stSendFrame.u32ID.ID.Sub = 0;		stSendFrame.u32ID.ID.ACK = NO_ACK;		stSendFrame.u32ID.ID.Reservd = 0;		stSendFrame.u32ID.ID.NoUsed = 0;		stSendFrame.u8DLC = 0x08;		stSendFrame.u8DT[0x02] = 0x00;						stSendFrame.u8DT[0x03] = 0x00;		stSendFrame.u8DT[0x04] = 0x00;		stSendFrame.u8DT[0x05] = u8YkqID;		u32SendLength = 0x05;		RfidUpdateSendPrg(0x01, 11, 0x00, (u8 *)&stSendFrame, u32SendLength);			KeyLedOnOff(0x00,KEY_LED_MAX);					InterfaceSetCtrlMode(INTERFACE_MODE_RECV_PRG_START);						/*计算总共需要多少时间*/		InterfaceSetDownloadRemainTimer(0x0000);		InterfaceInsertNote(INTERFACE_NOTE_PLEASE_DONOT_MOVE);		InterfaceSetUpdateMainMethod(INTERFACE_SHOW_MAIN_ALL);		OSSemPost(g_stSemInterface);						if(g_u32ID != B_type)			OSTaskSuspend(USART_TASK_PRIO);		OSTaskSuspend(IRMNG_TASK_PRIO);		OSTaskDel(RFIDMNG_TASK_PRIO);				if(g_u32ID == B_type)		{				RfidMngSetRecvCallBack();		}		/**无线更新程序处理任务**/		#if (ONLINE_UPDATE_SELF_PRG_PT_FLAG	!= DISABLED)			RfidUpdateMngInint();			OSTaskCreate(RfidMng_Update_Task, (void *)0, &RfidMng_task_stk[RFIDMNG_UPDATE_TASK_STK_SIZE - 1], RFIDMNG_UPDATE_TASK_PRIO); 		#endif		StateLed(ADJUST_CODE_ING_LED,ADJUST_CODE_SUCCEED_LED);				u32Y = LOGIC_STATUS_RFID_RECV_PRG;		LogicRunInfApi(LOGIC_SET_RUN_STATUS,&u32Y);			return u32ReturnFlag;}/*********************************************************************************************函数名称：LogicStatusRfidCXBRecvPrgProc**函数作用：逻辑层接收程序棒程序**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/	#if (ONLINE_UPDATE_SELF_PRG_PT_FLAG	!= DISABLED)			static u32 LogicStatusRfidCXBRecvPrgProc(void)	{		stFRAME stSendFrame;		u8 u8YkqID;		u32 u32SendLength = 0x00;		u32 u32ReturnFlag = 0x01;		u32 u32Y = 0x00;		#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */			 OS_CPU_SR  cpu_sr = 0;		#endif		if(g_u32ID == B_type)		{			OS_ENTER_CRITICAL();			RFID_Init(RFID_PRG_ININT_SYNC0,RFID_PRG_ININT_SYNC1);			OS_EXIT_CRITICAL();		}		else		{			SendSetupToWl(RFID_PRG_ININT_SYNC1);		}			memset(&stSendFrame,0x00,sizeof(stFRAME));		LogicParamApi(LOGIC_GET_YKQ_NUMBER, &u8YkqID);		stSendFrame.u32ID.ID.RxID = (u8)(SC_DEV_TYPE&0xFF);		stSendFrame.u32ID.ID.TxID = (u8)(WL_DEV_TYPE&0xFF);		stSendFrame.u32ID.ID.FrameType = RFID_FT_KEY_DOWN;		stSendFrame.u32ID.ID.Sum = 0;		stSendFrame.u32ID.ID.Sub = 0;		stSendFrame.u32ID.ID.ACK = NO_ACK;		stSendFrame.u32ID.ID.Reservd = 0;		stSendFrame.u32ID.ID.NoUsed = 0;		stSendFrame.u8DLC = 0x08;		stSendFrame.u8DT[0x02] = 0x00;						stSendFrame.u8DT[0x03] = 0x00;		stSendFrame.u8DT[0x04] = 0x00;		stSendFrame.u8DT[0x05] = u8YkqID;		u32SendLength = 0x05;		RfidUpdateSendPrg(0x01, 10, 0x00, (u8 *)&stSendFrame, u32SendLength);			KeyLedOnOff(0x00,KEY_LED_MAX);					InterfaceSetCtrlMode(INTERFACE_MODE_RECV_PRG_START);					/*计算总共需要多少时间*/		InterfaceSetDownloadRemainTimer(0x0000);		InterfaceInsertNote(INTERFACE_NOTE_PLEASE_DONOT_MOVE);		InterfaceSetUpdateMainMethod(INTERFACE_SHOW_MAIN_ALL);		OSSemPost(g_stSemInterface);						if(g_u32ID != B_type)			OSTaskSuspend(USART_TASK_PRIO);		OSTaskSuspend(IRMNG_TASK_PRIO);		OSTaskDel(RFIDMNG_TASK_PRIO);				if(g_u32ID == B_type)		{			/**无线更新处理任务**/				OS_ENTER_CRITICAL();					RfidMngSetRecvCallBack();			OS_EXIT_CRITICAL();			}		/**无线更新程序处理任务**/		#if (ONLINE_UPDATE_SELF_PRG_PT_FLAG	!= DISABLED)			RfidUpdateMngInint();			OSTaskCreate(RfidMng_Update_Task, (void *)0, &RfidMng_task_stk[RFIDMNG_UPDATE_TASK_STK_SIZE - 1], RFIDMNG_UPDATE_TASK_PRIO); 		#endif				RfidUpdateSendPrgData(0x00, 10, 0x00, (u8 *)&stSendFrame, u32SendLength);			StateLed(ADJUST_CODE_ING_LED,ADJUST_CODE_SUCCEED_LED);				u32Y = LOGIC_STATUS_RFID_RECV_PRG;		LogicRunInfApi(LOGIC_SET_RUN_STATUS,&u32Y);					return u32ReturnFlag;			}#endif		//配置文件同步请求帧		zzw	static u32 LogicStatusActionInfoReqProc(void){	stFRAME stSendFrame;	u8 u8YkqID,u8ScID;	u32 u32SendLength = 0x00;	u32 u32ReturnFlag = 0x01;	u32 u32Y = 0x00;	#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */		 OS_CPU_SR  cpu_sr = 0;	#endif	memset(&stSendFrame,0x00,sizeof(stFRAME));	LogicParamApi(LOGIC_GET_YKQ_NUMBER, &u8YkqID);	LogicRunInfApi(LOGIC_GET_CONLIBRATE_SC_NUMB, &u8ScID);//对码架号	stSendFrame.u32ID.ID.RxID = (u8)(SC_DEV_TYPE&0xFF);	stSendFrame.u32ID.ID.TxID = (u8)(WL_DEV_TYPE&0xFF);	stSendFrame.u32ID.ID.FrameType = RFID_FT_ACTION_INFO_REQ;	stSendFrame.u32ID.ID.Sum = 0;	stSendFrame.u32ID.ID.Sub = 0;	stSendFrame.u32ID.ID.ACK = NO_ACK;	stSendFrame.u32ID.ID.Reservd = 0;	stSendFrame.u32ID.ID.NoUsed = 0;	stSendFrame.u8DLC = 0x08;		stSendFrame.u8DT[0x00] = u8YkqID;	stSendFrame.u8DT[0x01] = u8ScID;	stSendFrame.u8DT[0x02] = 0x00;					stSendFrame.u8DT[0x03] = 0x00;	stSendFrame.u8DT[0x04] = 0x00;	stSendFrame.u8DT[0x05] = 0x00;	stSendFrame.u8DT[0x06] = 0x00;	stSendFrame.u8DT[0x07] = 0x00;	u32SendLength = 0x05;//	RfidUpdateSendPrg(s_u32DestDevID, 10, 0x00, (u8 *)&stSendFrame, u32SendLength);		//question			RfidTransformTx可以先用程序帮调试，完成后改	//	RfidTransformTx(&stSendFrame, u8ScID,0x01, 60,NO_ACK);	KeyLedOnOff(0x00,KEY_LED_MAX);				InterfaceSetCtrlMode(INTERFACE_MODE_RECV_PRG_START);				/*计算总共需要多少时间*/	InterfaceSetDownloadRemainTimer(0x0000);	InterfaceInsertNote(INTERFACE_NOTE_PLEASE_DONOT_MOVE);	InterfaceSetUpdateMainMethod(INTERFACE_SHOW_MAIN_ALL);	OSSemPost(g_stSemInterface);#if 0	//	OSTimeDly(1000/TICK_TIME);//	if(g_u32ID == B_type)//	{//		OS_ENTER_CRITICAL();//		RFID_Init(RFID_PRG_ININT_SYNC0,RFID_PRG_ININT_SYNC1);//		OS_EXIT_CRITICAL();//	}//	else//	{//		SendSetupToWl(RFID_PRG_ININT_SYNC1);//	}		if(g_u32ID != B_type)		OSTaskSuspend(USART_TASK_PRIO);#endif	OS_ENTER_CRITICAL();	OSTaskSuspend(IRMNG_TASK_PRIO);	OSTaskDel(RFIDMNG_TASK_PRIO);		if(g_u32ID == B_type)	{		/**无线更新处理任务**/					RfidMngSetRecvCallBack();	}		u32Y = LOGIC_STATUS_ACTION_MESS_REQ;	LogicRunInfApi(LOGIC_SET_RUN_STATUS,&u32Y);		/**无线更新程序处理任务**/	#if (ONLINE_UPDATE_SELF_PRG_PT_FLAG	!= DISABLED)		RfidUpdateMngInint();		OSTaskCreate(RfidMng_Update_Task, (void *)0, &RfidMng_task_stk[RFIDMNG_UPDATE_TASK_STK_SIZE - 1], RFIDMNG_UPDATE_TASK_PRIO); 	#endif	OS_EXIT_CRITICAL();			RfidUpdateSendPrgData(u8ScID, RFID_FT_ACTION_INFO_REQ, u8ScID, (u8 *)&stSendFrame, u32SendLength);			StateLed(ADJUST_CODE_ING_LED,ADJUST_CODE_SUCCEED_LED);		return u32ReturnFlag;		}/*********************************************************************************************函数名称：LogicWlTestSendProc**函数作用：发送无线测试数据**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/	static u32 LogicWlTestSendProc(void* pData){    RfidMngWLTestSend();    return 0x01;}	/*********************************************************************************************函数名称：LogicStatusRfidRecvPrgProc**函数作用：逻辑层红外开始搜索其他遥控器设备参数状态处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/	#if (ONLINE_UPDATE_SELF_PRG_PT_FLAG	!= DISABLED)		static u32 LogicStatusRfidRecvPrgProc(void)	{		return 1;	}#endif	/*********************************************************************************************函数名称：LogicStatusIrSearchYkqStartCtrlProc**函数作用：逻辑层红外开始搜索其他遥控器设备参数状态处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/#if (SET_YKQ_PRGPT_USE_FLAG != 0)	static u32 LogicStatusIrSearchYkqStartCtrlProc(void)	{		u32 u32ReturnFlag = 0x00;		u16 u16Temp = 0x00;					LogicParamApi(LOGIC_GET_YKQ_NUMBER,&u16Temp);					IrSendSearchYkqCodeInterface(u16Temp);		u16Temp = LOGIC_STATUS_IR_SEARCH_YQK_ING;		LogicRunInfApi(LOGIC_SET_RUN_STATUS, &u16Temp);//获取当前运行状态				return u32ReturnFlag;	}#endif/*********************************************************************************************函数名称：LogicStatusIrSearchYkqIngCtrlProc**函数作用：逻辑层红外正在搜索其他遥控器设备参数状态处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/#if (SET_YKQ_PRGPT_USE_FLAG != 0)	static u32 LogicStatusIrSearchYkqIngCtrlProc(void)	{		u32 u32ReturnFlag = 0x00;				return u32ReturnFlag;	}#endif/*********************************************************************************************函数名称：LogicStatusRfidUnColibrateProc**函数作用：逻辑层无线解除对码状态处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/static u32 LogicStatusRfidUnColibrateProc(void){	u16 u16Status;		u16Status = LOGIC_STATUS_IDLE;		LogicRunInfApi(LOGIC_SET_RUN_STATUS,&u16Status);		RfidMngSendDataUnColibarate();		return 0x01;	}/*********************************************************************************************函数名称：LogicStatusShutupProc**函数作用：逻辑层关机状态处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/static u32 LogicStatusShutupProc(void){	if(u32ShutDownTimer == 0x00)	{								u32ShutDownTimer= LOGIC_TASK_TIME_SET;	}	else	{		u32ShutDownTimer = 0x00;	}	return 0x01;	}/*********************************************************************************************函数名称：LogicParamApi**函数作用：LOGIC参数相关消息处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/u32 LogicParamApi(LOGIC_PARAM_MSG_TYPE sMsg,void *pData){	u32 u32ReturnFlag = 0x00;		#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */			OS_CPU_SR  cpu_sr = 0;	#endif		OS_ENTER_CRITICAL(); 	if(LogicParamApiProcFuncs[sMsg])	{		u32ReturnFlag = (*LogicParamApiProcFuncs[sMsg])(sMsg,pData);	}	else	{		u32ReturnFlag = 0x00;	}	OS_EXIT_CRITICAL();			return u32ReturnFlag;}/*********************************************************************************************函数名称：LogicRunInfApi**函数作用：LOGIC运行相关消息处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/u32 LogicRunInfApi(LOGIC_RUN_MSG_TYPE sMsg, void * pData){	u32 u32ReturnFlag = 0x00;		#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */			OS_CPU_SR  cpu_sr = 0;	#endif		OS_ENTER_CRITICAL(); 	if(LogicRunInfApiProcFuncs[sMsg])	{		u32ReturnFlag = (*LogicRunInfApiProcFuncs[sMsg])(pData);	}	else	{		u32ReturnFlag = 0x00;	}	OS_EXIT_CRITICAL();			return u32ReturnFlag;}/*********************************************************************************************函数名称：LogicShutdownProc**函数作用：逻辑层关机操作函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/void LogicShutdownProc(void){	u8 u8Temp = 0x00 ,err;	u16 u16ColumData = 0x00;	u32 u32Temp = 0x00;	OS_TCB      ptcb;		u8Temp = GPIO_ReadInputDataBit(INPUT_WAKEUP1_PORT,INPUT_WAKEUP1_PIN);	err = InterfaceGetCtrlMode();	LogicRunInfApi(LOGIC_GET_BATTERY_STATUS, &u32Temp);		if(err == INTERFACE_MODE_INCHARGE_DISPLAY)//关机充电下，进行重启操作	{		if((u32Temp == BATTERY_WORK_NORMAL)||(u32Temp == BATTERY_TOO_LOW))			u32Temp = YKQ_SHUTDOWN_INCHARGE_TURNDOWN;		else if(u32Temp == BATTERY_CHARGE_OVER)			u32Temp = YKQ_SHUTDOWN_SLEEP_WAKEUP2|YKQ_SHUTDOWN_SLEEP_WAKEUP1;		else			u32Temp = YKQ_SHUTDOWN_WORK_TURNON;	}	else if(u8Temp == INPUT_HIGH)	{		if((u32Temp != BATTERY_START_CHARGED)&&(u32Temp != BATTERY_BEING_CHARGED)\				&&(u32Temp != BATTERY_CHARGE_GONNA_OVER)&&(u32Temp != BATTERY_CHARGE_OVER))			u32Temp = YKQ_SHUTDOWN_SLEEP_WAKEUP1|YKQ_SHUTDOWN_SLEEP_WAKEUP2;		else			u32Temp = YKQ_SHUTDOWN_INCHARGE_TURNON;	}	else	{		u32Temp = YKQ_SHUTDOWN_SLEEP_WAKEUP2|YKQ_SHUTDOWN_SLEEP_WAKEUP1;	}	StateLed(0x00,KEY_SHIFT_LED|ADJUST_CODE_ING_LED|ADJUST_CODE_SUCCEED_LED);	#if (YKQ_HARDWARE_KEYLED_EXIST_DEFINE != DISABLED)		KeyLedOnOff(0x00, KEY_LED_ALL);	#endif		#ifdef	IWDG_ENABLED			err = OSTaskQuery(IWDG_TASK_PRIO,&ptcb);		if(err == OS_ERR_NONE)		{				u32Temp |= YKQ_SHUTDOWN_SLEEP_IWDG;			OSTimeDly(1000/TICK_TIME);					IWDG_SleepConfiguration();				}	#endif	LogicParamApi(LOGIC_SET_SHUTDOWM_FLAG,&u32Temp);	#if (YKQ_HARDWARE_BATTERY_MNG == BATTERY_ADC_MNG)//在硬件中，使用AD方式计算电量		BatteryGetStatus((BATTERY_STATUS_TYPE*)&u16ColumData);		if(u16ColumData != BATTERY_ININT)		{				#if 0				char s2[40];				LcdClear();				ShowStr(OLED_DISPLAY_NORMAL,"关机:",0, 20);				sprintf(s2,"%x",u32Temp);				ShowStr(OLED_DISPLAY_NORMAL,s2,0, 80);			#endif						u32Temp = 0x00;				BatteryGetCoulomeData(&u16ColumData);			LogicParamApi(LOGIC_SET_BATTERY_COULDATA_BACKUP,&u16ColumData);						#if 0				ShowStr(OLED_DISPLAY_NORMAL,"电池",2, 20);					sprintf(s2,"%d",u16ColumData);				ShowStr(OLED_DISPLAY_NORMAL,s2,4, 20);					OSTimeDly(1000/TICK_TIME);	//showing for 1s			#endif						BatteryGetAcrBackup(&u32Temp);			LogicParamApi(LOGIC_SET_BATTERY_ACR_BACKUP,&u32Temp);						BatteryGetVoltBackup(&u32Temp);			LogicParamApi(LOGIC_SET_BATTERY_VOLTAGE_BACKUP,&u32Temp);						BatteryGetInchargeTimer(&u32Temp);			LogicParamApi(LOGIC_SET_BATTERY_INCHARGE_TIMER,&u32Temp);					}	#endif		 	SetScrClosed();		OledShutDown();	OledChipPwrOff();			if(g_u32ID != B_type)		KEY595ChipOUTOff();	if(g_u32ID == B_type)		SetRFChipSleepMode();		WirelessChipPwrOff();			if(g_u32ID != B_type)	{		Ltc3440BurstModeDisabled();	}	else	{		Ltc3440BurstModeEnabled();	}		RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOA|RCC_AHBPeriph_GPIOB|RCC_AHBPeriph_GPIOC|RCC_AHBPeriph_GPIOD, DISABLE);//串口端口时钟使能	RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1 , DISABLE);//串口功能时钟使能	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, DISABLE);	RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1, DISABLE);	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, DISABLE);	RCC_APB1PeriphClockCmd(RFID_SPI_MCU_RCC,DISABLE);	RCC_APB2PeriphClockCmd(RCC_APB2Periph_SYSCFG,DISABLE);			RCC_HSICmd(DISABLE);	RCC_HSEConfig(RCC_HSE_OFF);	RCC_MSICmd(DISABLE);	RCC_LSEConfig(RCC_LSE_OFF);	RCC_LSICmd(DISABLE);			RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR,ENABLE);		if(u8Temp != Bit_SET)		PWR_WakeUpPinCmd(PWR_WakeUpPin_1, ENABLE);  	PWR_WakeUpPinCmd(PWR_WakeUpPin_2, ENABLE); 	PWR_PVDCmd(DISABLE);		/* Enable WKUP pin 1 、2*/	while(1)	{		OSTimeDly(TICK_TIME);//		OSTimeDly(200/OS_TICKS_PER_SEC);		if(u8Temp != Bit_SET)		{			if((PWR_GetFlagStatus(PWR_CSR_EWUP2) == SET))				if((PWR_GetFlagStatus(PWR_CSR_EWUP1) == SET))				break;		}		else		{			if(PWR_GetFlagStatus(PWR_CSR_EWUP2) == SET)			{				break;			}		}	}		/* Request to enter STANDBY mode (Wake Up flag is cleared in PWR_EnterSTANDBYMode function) */	/* Clear WakeUp flag */	PWR_ClearFlag(PWR_FLAG_WU);	PWR_ClearFlag(PWR_CSR_VREFINTRDYF);		PWR_EnterSTANDBYMode();}/*********************************************************************************************函数名称：LogicPeriodSampleProc**函数作用：逻辑层周期性操作处理函数**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/void LogicPeriodSampleProc(u32 u32TimeDelay) {	BATTERY_STATUS_TYPE		stBatteryStatus;//电池状态	BATTERY_COULOMETRY_TYPE	stCoulomStatus;//电池电量状态	u16 u16CoulomData;//电量的真实数值	u16 u16I = 0x00;	u16 u16InterfaceMode;	u32 u32Temp;		BATTERY_STATUS_TYPE		stBatteryStatusLast;//电池状态	BATTERY_COULOMETRY_TYPE	stCoulomStatusLast;//电池电量状态	u16 u16CoulomDataLast;//电量的真实数值	s_u32LogicSampleTimer += u32TimeDelay;	if((s_u32LogicSampleTimer % BATTERY_SAMPLE_TIME_SET) == 0x00)	{		LogicRunInfApi(LOGIC_GET_BATTERY_STATUS, &stBatteryStatusLast);		LogicRunInfApi(LOGIC_GET_BATTERY_COULOM_STATUS, &stCoulomStatusLast);		LogicRunInfApi(LOGIC_GET_BATTERY_COULOM_DATA, &u16CoulomDataLast);			BatteryGetCoulomeData(&u16CoulomData);		BatteryGetStatus(&stBatteryStatus);		BatteryGetCoulomeStatus(&stCoulomStatus);			u16InterfaceMode = (u16)(InterfaceGetCtrlMode());		switch(stBatteryStatus)		{			case BATTERY_WORK_NORMAL:				if((stCoulomStatus != stCoulomStatusLast) || (stBatteryStatus  != stBatteryStatusLast)||(u16CoulomData != u16CoulomDataLast))				{					if(u16InterfaceMode == INTERFACE_MODE_IDLE)					{						InterfaceSetUpdateMainMethod(INTERFACE_SHOW_MAIN_BATTERY);						OSSemPost(g_stSemInterface);					}					else if((u16InterfaceMode != INTERFACE_MODE_SELF_SET)&&((u16InterfaceMode != INTERFACE_MODE_INCHARGE_DISPLAY)))					{						InterfaceSetUpdateMainMethod(INTERFACE_SHOW_MAIN_BATTERY);						OSSemPost(g_stSemInterface);					}					else						;				}				if((((stBatteryStatusLast == BATTERY_START_CHARGED) ||(stBatteryStatusLast == BATTERY_BEING_CHARGED) ||(stBatteryStatusLast == BATTERY_CHARGE_GONNA_OVER) || (stBatteryStatusLast == BATTERY_CHARGE_OVER))\					&&(stBatteryStatus  != stBatteryStatusLast))\				    ||(u16InterfaceMode == INTERFACE_MODE_INCHARGE_DISPLAY))				{					u32ShutDownTimer = 0x00;										if(u16InterfaceMode == INTERFACE_MODE_IDLE)					{						InterfaceInsertNote(INTERFACE_NOTE_BATTERY_LINE_OFF);						InterfaceSetUpdateMainMethod(INTERFACE_SHOW_MAIN_NOTE|INTERFACE_SHOW_MAIN_AWAKE);																	OSSemPost(g_stSemInterface);						#if (YKQ_HARDWARE_BEEP_EXIST_DEFINE != DISABLED)							BuzzerOn(BEEP_UNCOLIBRAT);						#endif						u16CoulomDataLast = 0x00;						#if (YKQ_HARDWARE_BATTERY_MNG == BATTERY_ADC_MNG)//在硬件中，使用AD方式计算电量							BatteryGetCoulomeData(&u16CoulomData);							LogicParamApi(LOGIC_SET_BATTERY_COULDATA_BACKUP,&u16CoulomData);							BatterySetCoulomeData(u16CoulomData);													BatteryGetAcrBackup(&u32Temp);							LogicParamApi(LOGIC_SET_BATTERY_ACR_BACKUP,&u32Temp);							BatterySetTotalAcr(u32Temp);													BatteryGetVoltBackup(&u32Temp);							LogicParamApi(LOGIC_SET_BATTERY_VOLTAGE_BACKUP,&u32Temp);										#endif												}					else if(u16InterfaceMode == INTERFACE_MODE_INCHARGE_DISPLAY)					{						OSTaskSuspend(SCAN_KEY_TASK_PRIO);						InterfaceInsertNote(INTERFACE_NOTE_BATTERY_LINE_OFF);						InterfaceSetUpdateMainMethod(INTERFACE_SHOW_MAIN_NOTE|INTERFACE_SHOW_MAIN_AWAKE);																	OSSemPost(g_stSemInterface);						#if (YKQ_HARDWARE_BEEP_EXIST_DEFINE != DISABLED)							BuzzerOn(BEEP_UNCOLIBRAT);						#endif												u16I = LOGIC_STATUS_SHUTUP;						LogicRunInfApi(LOGIC_SET_RUN_STATUS, &u16I);							#if (YKQ_HARDWARE_BATTERY_MNG == BATTERY_ADC_MNG)//在硬件中，使用AD方式计算电量							BatteryGetCoulomeData(&u16CoulomData);							LogicParamApi(LOGIC_SET_BATTERY_COULDATA_BACKUP,&u16CoulomData);							BatterySetCoulomeData(u16CoulomData);													BatteryGetAcrBackup(&u32Temp);							LogicParamApi(LOGIC_SET_BATTERY_ACR_BACKUP,&u32Temp);							BatterySetTotalAcr(u32Temp);													BatteryGetVoltBackup(&u32Temp);							LogicParamApi(LOGIC_SET_BATTERY_VOLTAGE_BACKUP,&u32Temp);						#endif						}					else						;					StateLed(0x00,ADJUST_CODE_ING_LED|ADJUST_CODE_SUCCEED_LED);				}								if((stBatteryStatusLast == BATTERY_TOO_LOW)&&(u16InterfaceMode == INTERFACE_MODE_IDLE))				{					StateLed(0x00,ADJUST_CODE_ING_LED|ADJUST_CODE_SUCCEED_LED);				}				break;							case BATTERY_START_CHARGED://开始充电				if((stCoulomStatus == BATTERY_COULOMETRY_EMPTY)&&(stCoulomStatus != stCoulomStatusLast))				{					#if (YKQ_HARDWARE_BEEP_EXIST_DEFINE != DISABLED)						BuzzerOff();					#endif					u32ShutDownTimer = 0xFFFFFFFF;//停止关机操作				}								u32ShutDownTimer = 0x00; 				if(u16InterfaceMode == INTERFACE_MODE_IDLE)				{										InterfaceInsertNote(INTERFACE_NOTE_BATTERY_INCHARGE);					InterfaceSetUpdateMainMethod(INTERFACE_SHOW_MAIN_NOTE|INTERFACE_SHOW_MAIN_AWAKE|INTERFACE_SHOW_MAIN_BATTERY);					#if (YKQ_HARDWARE_BEEP_EXIST_DEFINE != DISABLED)						BuzzerOn(BEEP_UNCOLIBRAT);					#endif					OSSemPost(g_stSemInterface);				}				else if(u16InterfaceMode == INTERFACE_MODE_INCHARGE_DISPLAY)				{					InterfaceInsertNote(INTERFACE_NOTE_BATTERY_INCHARGE);					InterfaceSetUpdateMainMethod(INTERFACE_SHOW_INCHARGE_DISPLAY);					#if (YKQ_HARDWARE_BEEP_EXIST_DEFINE != DISABLED)						BuzzerOn(BEEP_UNCOLIBRAT);					#endif					OSSemPost(g_stSemInterface);								}				else					;							case BATTERY_BEING_CHARGED://正在充电过程中			case BATTERY_CHARGE_GONNA_OVER://充电即将完成			case BATTERY_CHARGE_OVER://充电已经完成				#if (BOARD_BATTERY_TEST == BOARD_BATTERY_COULOME_NUMBER)					if(((u16CoulomData > u16CoulomDataLast)&&(stBatteryStatusLast != BATTERY_CHARGE_OVER))||(stBatteryStatusLast == BATTERY_WORK_NORMAL)||(stBatteryStatusLast == BATTERY_ININT))					{						LogicRunInfApi(LOGIC_SET_BATTERY_COULOM_DATA, &u16CoulomData); 						if((u16InterfaceMode == INTERFACE_MODE_IDLE)||(u16InterfaceMode == INTERFACE_MODE_ININT))						{													InterfaceInsertNote(INTERFACE_NOTE_BATTERY_INCHARGE);							InterfaceSetUpdateMainMethod(INTERFACE_SHOW_MAIN_NOTE);								OSSemPost(g_stSemInterface);							}						else if(u16InterfaceMode == INTERFACE_MODE_INCHARGE_DISPLAY)						{							InterfaceInsertNote(INTERFACE_NOTE_BATTERY_INCHARGE);							InterfaceSetUpdateMainMethod(INTERFACE_SHOW_INCHARGE_DISPLAY);							#if (YKQ_HARDWARE_BEEP_EXIST_DEFINE != DISABLED)								BuzzerOn(BEEP_UNCOLIBRAT);							#endif							OSSemPost(g_stSemInterface);										}						else							;					}				#endif								if((stBatteryStatus != stBatteryStatusLast)&&(stBatteryStatus == BATTERY_CHARGE_OVER))				{					if((u16InterfaceMode == INTERFACE_MODE_IDLE))					{						InterfaceInsertNote(INTERFACE_NOTE_BATTERY_INCHARGE_OVER);						InterfaceSetUpdateMainMethod(INTERFACE_SHOW_MAIN_NOTE|INTERFACE_SHOW_MAIN_AWAKE);						#if (YKQ_HARDWARE_BEEP_EXIST_DEFINE != DISABLED)							BuzzerOn(BEEP_UNCOLIBRAT);						#endif						OSSemPost(g_stSemInterface);					}					else if(u16InterfaceMode == INTERFACE_MODE_INCHARGE_DISPLAY)					{						InterfaceInsertNote(INTERFACE_NOTE_BATTERY_INCHARGE_OVER);						InterfaceSetUpdateMainMethod(INTERFACE_SHOW_INCHARGE_DISPLAY|INTERFACE_SHOW_MAIN_AWAKE);						#if (YKQ_HARDWARE_BEEP_EXIST_DEFINE != DISABLED)							BuzzerOn(BEEP_UNCOLIBRAT);						#endif						OSSemPost(g_stSemInterface);									}					else						;									}				if((stCoulomStatus != stCoulomStatusLast) || (stBatteryStatus  != stBatteryStatusLast))				{					if(u16InterfaceMode == INTERFACE_MODE_IDLE)					{						if(stBatteryStatus == BATTERY_CHARGE_OVER)						{							InterfaceInsertNote(INTERFACE_NOTE_BATTERY_INCHARGE_OVER);													InterfaceSetUpdateMainMethod(INTERFACE_SHOW_MAIN_BATTERY|INTERFACE_SHOW_MAIN_NOTE);						}						else if(stBatteryStatusLast == BATTERY_WORK_NORMAL)						{							InterfaceInsertNote(INTERFACE_NOTE_BATTERY_INCHARGE);													InterfaceSetUpdateMainMethod(INTERFACE_SHOW_MAIN_BATTERY|INTERFACE_SHOW_MAIN_NOTE);													}						else						{							InterfaceSetUpdateMainMethod(INTERFACE_SHOW_MAIN_BATTERY);						}													OSSemPost(g_stSemInterface);					}					else if(u16InterfaceMode == INTERFACE_MODE_INCHARGE_DISPLAY)					{						if(stBatteryStatus == BATTERY_CHARGE_OVER)						{							InterfaceInsertNote(INTERFACE_NOTE_BATTERY_INCHARGE_OVER);													InterfaceSetUpdateMainMethod(INTERFACE_SHOW_INCHARGE_DISPLAY);						}						else						{							InterfaceSetUpdateMainMethod(INTERFACE_SHOW_INCHARGE_DISPLAY);						}													OSSemPost(g_stSemInterface);					}										else if((u16InterfaceMode !=  INTERFACE_MODE_SELF_SET)&&(u16InterfaceMode !=  INTERFACE_MODE_SHUTSOWN)\						&&(u16InterfaceMode !=  INTERFACE_MODE_COLIBRATE_CODE_SUCCESS)&&(u16InterfaceMode !=  INTERFACE_MODE_COLIBRATE_CODE_FAIL))					{						InterfaceSetUpdateMainMethod(INTERFACE_SHOW_MAIN_BATTERY);						OSSemPost(g_stSemInterface);					}					else						;				}				if(stBatteryStatus == BATTERY_CHARGE_OVER)				{					StateLed(ADJUST_CODE_ING_LED,ADJUST_CODE_SUCCEED_LED);				}				else				{					StateLed(ADJUST_CODE_SUCCEED_LED,ADJUST_CODE_ING_LED);				}				break;			case BATTERY_TOO_LOW:				if((u16CoulomData >= 3)&&(u16CoulomData < 5)&&(stCoulomStatus != stCoulomStatusLast))				{					if((u16InterfaceMode == INTERFACE_MODE_IDLE)&&(u32ShutDownTimer == 0x00))					{								InterfaceInsertNote(INTERFACE_NOTE_BATTERY_TOO_LOW);						InterfaceSetUpdateMainMethod(INTERFACE_SHOW_MAIN_NOTE);						#if (YKQ_HARDWARE_BEEP_EXIST_DEFINE != DISABLED)							BuzzerOn(BEEP_UNCOLIBRAT);						#endif					}									}				else if(((u16CoulomData < 3))&&(stCoulomStatus != stCoulomStatusLast))				{					if(u32ShutDownTimer == 0x00)					{												u32ShutDownTimer= BATTERY_LOW_SHUTDOWN_TIMER; 						if(u16InterfaceMode == INTERFACE_MODE_IDLE)						{							InterfaceInsertNote(INTERFACE_NOTE_BATTERY_LOW_SHUTDOWN_10);							InterfaceSetUpdateMainMethod(INTERFACE_SHOW_MAIN_NOTE|INTERFACE_SHOW_MAIN_AWAKE);							#if (YKQ_HARDWARE_BEEP_EXIST_DEFINE != DISABLED)								BuzzerOn(BEEP_SHUTDOWN_NOTE);							#endif						}										}				}				else					;								if(u16InterfaceMode == INTERFACE_MODE_IDLE)				{					InterfaceSetUpdateMainMethod(INTERFACE_SHOW_MAIN_BATTERY);					OSSemPost(g_stSemInterface);				}				else if(u16InterfaceMode == INTERFACE_MODE_INCHARGE_DISPLAY)				{					OSTaskSuspend(SCAN_KEY_TASK_PRIO);					InterfaceInsertNote(INTERFACE_NOTE_BATTERY_LINE_OFF);					InterfaceSetUpdateMainMethod(INTERFACE_SHOW_MAIN_NOTE|INTERFACE_SHOW_MAIN_AWAKE);																OSSemPost(g_stSemInterface);					#if (YKQ_HARDWARE_BEEP_EXIST_DEFINE != DISABLED)						BuzzerOn(BEEP_UNCOLIBRAT);					#endif											u16I = LOGIC_STATUS_SHUTUP;					LogicRunInfApi(LOGIC_SET_RUN_STATUS, &u16I);						#if (YKQ_HARDWARE_BATTERY_MNG == BATTERY_ADC_MNG)//在硬件中，使用AD方式计算电量						BatteryGetCoulomeData(&u16CoulomData);						LogicParamApi(LOGIC_SET_BATTERY_COULDATA_BACKUP,&u16CoulomData);						BatterySetCoulomeData(u16CoulomData);											BatteryGetAcrBackup(&u32Temp);						LogicParamApi(LOGIC_SET_BATTERY_ACR_BACKUP,&u32Temp);						BatterySetTotalAcr(u32Temp);											BatteryGetVoltBackup(&u32Temp);						LogicParamApi(LOGIC_SET_BATTERY_VOLTAGE_BACKUP,&u32Temp);						#endif					}								else if(u16InterfaceMode != INTERFACE_MODE_SELF_SET)				{					InterfaceSetUpdateMainMethod(INTERFACE_SHOW_MAIN_BATTERY);					OSSemPost(g_stSemInterface);							}				else					;				if(((stBatteryStatusLast == BATTERY_START_CHARGED) ||(stBatteryStatusLast == BATTERY_BEING_CHARGED) ||(stBatteryStatusLast == BATTERY_CHARGE_GONNA_OVER) || (stBatteryStatusLast == BATTERY_CHARGE_OVER))\					&&(stBatteryStatus  != stBatteryStatusLast))				{					u32ShutDownTimer = 0x00;					if(u16InterfaceMode == INTERFACE_MODE_IDLE)					{						InterfaceInsertNote(INTERFACE_NOTE_BATTERY_LINE_OFF);						InterfaceSetUpdateMainMethod(INTERFACE_SHOW_MAIN_NOTE|INTERFACE_SHOW_MAIN_AWAKE);																	OSSemPost(g_stSemInterface);						#if (YKQ_HARDWARE_BEEP_EXIST_DEFINE != DISABLED)							BuzzerOn(BEEP_UNCOLIBRAT);						#endif						u16CoulomDataLast = 0x00;						#if (YKQ_HARDWARE_BATTERY_MNG == BATTERY_ADC_MNG)//在硬件中，使用AD方式计算电量							BatteryGetCoulomeData(&u16CoulomData);							LogicParamApi(LOGIC_SET_BATTERY_COULDATA_BACKUP,&u16CoulomData);							BatterySetCoulomeData(u16CoulomData);													BatteryGetAcrBackup(&u32Temp);							LogicParamApi(LOGIC_SET_BATTERY_ACR_BACKUP,&u32Temp);							BatterySetTotalAcr(u32Temp);																			BatteryGetVoltBackup(&u32Temp);							LogicParamApi(LOGIC_SET_BATTERY_VOLTAGE_BACKUP,&u32Temp);									#endif												}					else if(u16InterfaceMode == INTERFACE_MODE_INCHARGE_DISPLAY)					{						OSTaskSuspend(SCAN_KEY_TASK_PRIO);						InterfaceInsertNote(INTERFACE_NOTE_BATTERY_LINE_OFF);						InterfaceSetUpdateMainMethod(INTERFACE_SHOW_MAIN_NOTE|INTERFACE_SHOW_MAIN_AWAKE);																	OSSemPost(g_stSemInterface);						#if (YKQ_HARDWARE_BEEP_EXIST_DEFINE != DISABLED)							BuzzerOn(BEEP_UNCOLIBRAT);						#endif												u16I = LOGIC_STATUS_SHUTUP;						LogicRunInfApi(LOGIC_SET_RUN_STATUS, &u16I);							#if (YKQ_HARDWARE_BATTERY_MNG == BATTERY_ADC_MNG)//在硬件中，使用AD方式计算电量							BatteryGetCoulomeData(&u16CoulomData);							LogicParamApi(LOGIC_SET_BATTERY_COULDATA_BACKUP,&u16CoulomData);													BatteryGetAcrBackup(&u32Temp);							LogicParamApi(LOGIC_SET_BATTERY_ACR_BACKUP,&u32Temp);							BatteryGetVoltBackup(&u32Temp);							LogicParamApi(LOGIC_SET_BATTERY_VOLTAGE_BACKUP,&u32Temp);							#endif						}					else						;				}					if((u16InterfaceMode == INTERFACE_MODE_IDLE)\					||(u16InterfaceMode == INTERFACE_MODE_SELF_SET))									LedToggle(ADJUST_CODE_SUCCEED_LED);					break;							case BATTERY_FAULT:				if(stBatteryStatus  != stBatteryStatusLast)				{					if(u16InterfaceMode == INTERFACE_MODE_IDLE)					{										InterfaceInsertNote(INTERFACE_NOTE_BATTERY_FAULT);						InterfaceSetUpdateMainMethod(INTERFACE_SHOW_MAIN_NOTE);						#if (YKQ_HARDWARE_BEEP_EXIST_DEFINE != DISABLED)							BuzzerOn(BEEP_UNCOLIBRAT);						#endif						InterfaceSetUpdateMainMethod(INTERFACE_SHOW_MAIN_BATTERY);						OSSemPost(g_stSemInterface);										}				}				break;							default:				break;						}		if(u16InterfaceMode != INTERFACE_MODE_ININT)		{			LogicRunInfApi(LOGIC_SET_BATTERY_STATUS, &stBatteryStatus);			LogicRunInfApi(LOGIC_SET_BATTERY_COULOM_STATUS, &stCoulomStatus);			LogicRunInfApi(LOGIC_SET_BATTERY_COULOM_DATA, &u16CoulomData);			}	}	/*关机时间处理**/	if(u32ShutDownTimer && (u32ShutDownTimer != 0xFFFFFFFF))	{		if(u32ShutDownTimer >= u32TimeDelay)			u32ShutDownTimer -= u32TimeDelay;		else			u32ShutDownTimer = 0x00;		if(u32ShutDownTimer == 0x00)//进行关机操作		{			u32ShutDownTimer = 0xFFFFFFFF;			u16I = LOGIC_STATUS_SHUTUP;			LogicRunInfApi(LOGIC_SET_RUN_STATUS, &u16I);						/*进行关机操作**/			LogicShutdownProc();   // jhyjhy		}		else		{			if((u32ShutDownTimer%1000) == 0x00)			{				u16CoulomData = (BATTERY_LOW_SHUTDOWN_TIMER-u32ShutDownTimer)/1000;				InterfaceInsertNote((INTERFACE_NOTE_TYPE)(INTERFACE_NOTE_BATTERY_LOW_SHUTDOWN_10+u16CoulomData));				if(u16InterfaceMode == INTERFACE_MODE_IDLE)				{									InterfaceSetUpdateMainMethod(INTERFACE_SHOW_MAIN_NOTE|INTERFACE_SHOW_MAIN_BATTERY);				}				else				{					InterfaceSetUpdateMainMethod(INTERFACE_SHOW_MAIN_NOTE);				}					OSSemPost(g_stSemInterface);			}		}	}}extern u32 RfidTestTimer;void ClearRfidTestShow(void){    u8 u8I;    u16 u16I;    LogicParamApi(LOGIC_GET_WL_TEST_ENABLE, &u8I);    u16I = (u16)(InterfaceGetCtrlMode());               if((u8I == ENABLE) && (u16I == INTERFACE_MODE_SC_UNCERTIFIED))	    {        if(RfidTestTimer > 0 && RfidTestTimer != 0xffff)		        {            RfidTestTimer--;    //无线测试        }        if(RfidTestTimer == 0)        {            RfidTestTimer = 0xffff;            InterfaceSetUpdateMainMethod(INTERFACE_SHOW_MAIN_RFIDSIGNAL);            OSSemPost(g_stSemInterface);        }            }}/*********************************************************************************************函数名称：Logic_task**函数作用：逻辑层任务处理**函数参数：无**函数输出：无**注意事项：无*******************************************************************************************/void Logic_task(void *p_arg) {	#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */		OS_CPU_SR  cpu_sr = 0;	#endif	OSTimeDly(LOGIC_TASK_POWERUP_DELAY/TICK_TIME);//在上电时，延时进行处理		while(1)	{		#ifdef	IWDG_ENABLED				OS_ENTER_CRITICAL();			Iwdg_Logic = 0;			OS_EXIT_CRITICAL();		#endif		OSTimeDly(LOGIC_TASK_TIME_SET/TICK_TIME);		if(LogicStatusProcFuncs[s_stLogicRunInf.stLogicRunStatus])//逻辑层运行状态的转化处理			(*LogicStatusProcFuncs[s_stLogicRunInf.stLogicRunStatus])();		LogicPeriodSampleProc(LOGIC_TASK_TIME_SET);//周期性采集处理工作					if(RebootSet == 1)		{			RfidMngSendDataUnColibarate();			RfidMngSendDataUnColibarate();			OSTimeDly(1500/TICK_TIME);			IapJumpToBoot(IN_FLASH_BOOTLOADER_ADDR);		}        ClearRfidTestShow();	}        }