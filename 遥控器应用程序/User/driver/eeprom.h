/****************************************************************************日  期：2012.03.01                                                               **创建人：李微辰**修改人：**使  用：**************************************************************************/ /* Define to prevent recursive inclusion -------------------------------------*/#ifndef __STM32_EVAL_I2C_EE_H#define __STM32_EVAL_I2C_EE_H#ifdef __cplusplus extern "C" {#endif/* Includes ------------------------------------------------------------------*///#include "stm32_eval.h"/** @addtogroup Utilities  * @{  */  /** @addtogroup STM32_EVAL  * @{  */ /** @addtogroup Common  * @{  */  /** @addtogroup STM32_EVAL_I2C_EE  * @{  */  /** @defgroup STM32_EVAL_I2C_EE_Exported_Types  * @{  */ /**  * @}  */  /** @defgroup STM32_EVAL_I2C_EE_Exported_Constants  * @{  */  /* Uncomment this line to use the default start and end of critical section    callbacks (it disables then enabled all interrupts) */#define USE_DEFAULT_CRITICAL_CALLBACK /* Start and End of critical section: these callbacks should be typically used   to disable interrupts when entering a critical section of I2C communication   You may use default callbacks provided into this driver by uncommenting the    define USE_DEFAULT_CRITICAL_CALLBACK.   Or you can comment that line and implement these callbacks into your    application *//* Uncomment the following line to use the default e24LCXX_TIMEOUT_UserCallback()    function implemented in stm32_evel_i2c_ee.c file.   e24LCXX_TIMEOUT_UserCallback() function is called whenever a timeout condition    occure during communication (waiting on an event that doesn't occur, bus    errors, busy devices ...). */   /* #define USE_DEFAULT_TIMEOUT_CALLBACK */void e24LCXX_LowLevel_DeInit(void);void e24LCXX_LowLevel_Init(void); void e24LCXX_LowLevel_DMAConfig(uint32_t pBuffer, uint32_t BufferSize, uint32_t Direction);/**  * @}  */#define e24LCXX_I2C_DMA                      DMA1   #define e24LCXX_I2C_DMA_CHANNEL_TX           DMA1_Channel4#define e24LCXX_I2C_DMA_CHANNEL_RX           DMA1_Channel5 #define e24LCXX_I2C_DMA_FLAG_TX_TC           DMA1_IT_TC4   #define e24LCXX_I2C_DMA_FLAG_TX_GL           DMA1_IT_GL4 #define e24LCXX_I2C_DMA_FLAG_RX_TC           DMA1_IT_TC5 #define e24LCXX_I2C_DMA_FLAG_RX_GL           DMA1_IT_GL5    #define e24LCXX_I2C_DMA_CLK                  RCC_AHBPeriph_DMA1#define e24LCXX_I2C_DR_Address               ((uint32_t)0x40005410)#define e24LCXX_USE_DMA   #define e24LCXX_I2C_DMA_TX_IRQn              DMA1_Channel4_IRQn#define e24LCXX_I2C_DMA_RX_IRQn              DMA1_Channel5_IRQn#define e24LCXX_I2C_DMA_TX_IRQHandler        DMA1_Channel4_IRQHandler#define e24LCXX_I2C_DMA_RX_IRQHandler        DMA1_Channel5_IRQHandler   #define e24LCXX_I2C_DMA_PREPRIO              0#define e24LCXX_I2C_DMA_SUBPRIO              0      #define e24LCXX_DIRECTION_TX                 0#define e24LCXX_DIRECTION_RX                 1    #define BLOCK_ADD(ADDRESS) (((ADDRESS>>8)&0x07)<<1)  #define e24LCXX_Block0_ADDRESS     0xA0   #define e24LCXX_Block1_ADDRESS     0xA2    #define e24LCXX_Block2_ADDRESS     0xA4  #define e24LCXX_Block3_ADDRESS     0xA6  #define e24LCXX_Block4_ADDRESS     0xA8 #define e24LCXX_Block5_ADDRESS     0xAA #define e24LCXX_Block6_ADDRESS     0xAC #define e24LCXX_Block7_ADDRESS     0xAE#define I2C_SPEED               300000#define I2C_SLAVE_ADDRESS7      0xA0//#if defined (e24LCXX_M24C08)// #define e24LCXX_PAGESIZE           16//#elif defined (e24LCXX_M24C64_32)// #define e24LCXX_PAGESIZE           32//#endif#define e24LCXX_PAGESIZE           16   /* Maximum Timeout values for flags and events waiting loops. These timeouts are   not based on accurate values, they just guarantee that the application will    not remain stuck if the I2C communication is corrupted.   You may modify these timeout values depending on CPU frequency and application   conditions (interrupts routines ...). */   #define e24LCXX_FLAG_TIMEOUT         ((uint32_t)0x1000)#define e24LCXX_LONG_TIMEOUT         ((uint32_t)(10 * e24LCXX_FLAG_TIMEOUT))/* Maximum number of trials for e24LCXX_WaitEepromStandbyState() function */#define e24LCXX_MAX_TRIALS_NUMBER     150   /* Defintions for the state of the DMA transfer */   #define e24LCXX_STATE_READY           0#define e24LCXX_STATE_BUSY            1#define e24LCXX_STATE_ERROR           2   #define e24LCXX_OK                    0#define e24LCXX_FAIL                  1   /**  * @}  */   /** @defgroup STM32_EVAL_I2C_EE_Exported_Macros  * @{  */    /**  * @}  */ /** @defgroup STM32_EVAL_I2C_EE_Exported_Functions  * @{  */ void     e24LCXX_DeInit(void);void     e24LCXX_Init(void);uint32_t e24LCXX_ReadBuffer(uint8_t* pBuffer, uint16_t ReadAddr, uint16_t* NumByteToRead);uint32_t e24LCXX_WritePage(uint8_t* pBuffer, uint16_t WriteAddr, uint8_t* NumByteToWrite);uint32_t e24LCXX_WriteBuffer(uint8_t* pBuffer, uint16_t WriteAddr, uint16_t NumByteToWrite);uint32_t e24LCXX_WaitEepromStandbyState(void);uint32_t e24LCXX_TIMEOUT_UserCallback(void);/* USER Callbacks: These are functions for which prototypes only are declared in   EEPROM driver and that should be implemented into user applicaiton. */  /* e24LCXX_TIMEOUT_UserCallback() function is called whenever a timeout condition    occure during communication (waiting on an event that doesn't occur, bus    errors, busy devices ...).   You can use the default timeout callback implementation by uncommenting the    define USE_DEFAULT_TIMEOUT_CALLBACK in stm32_evel_i2c_ee.h file.   Typically the user implementation of this callback should reset I2C peripheral   and re-initialize communication or in worst case reset all the application. */uint32_t e24LCXX_TIMEOUT_UserCallback(void);/* Start and End of critical section: these callbacks should be typically used   to disable interrupts when entering a critical section of I2C communication   You may use default callbacks provided into this driver by uncommenting the    define USE_DEFAULT_CRITICAL_CALLBACK in stm32_evel_i2c_ee.h file..   Or you can comment that line and implement these callbacks into your    application */void e24LCXX_EnterCriticalSection_UserCallback(void);void e24LCXX_ExitCriticalSection_UserCallback(void);unsigned char CRC_8(unsigned short PData);u16 Para_Read(u16 u16Off, u16 *u16Dst, u16 u16len);u16 Para_Save(u16 u16Off, u16 u16Cnt);void Task_Par_Saved(void);#ifdef __cplusplus}#endif#endif /* __STM32_EVAL_I2C_EE_H *//**  * @}  *//**  * @}  *//**  * @}  *//**  * @}  */ /**  * @}  *//******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/