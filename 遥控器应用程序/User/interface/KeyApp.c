/********************************************************************************
* 文件名：	KeyApp.c
* 作者：	马如意   
* 版本：   	V1.0
* 日期：    2015.04.28
* 功能描述:  实现按键的协议层处理

* 修改说明：   
*
*       >>>>  在工程中的位置  <<<<
*             3-应用层
*          √  2-协议层
*             1-硬件驱动层
*********************************************************************************
* @copy
* <h2><center>&copy; COPYRIGHT 天津华宁电子有限公司 研发中心 软件部</center></h2>
*********************************************************************************/
/********************************************************************************
* .h头文件
*********************************************************************************/
#include	"includes.h"

/********************************************************************************
* #define宏定义
*********************************************************************************/

/********************************************************************************
* 常量定义
*********************************************************************************/
/********************************************************************************
* 变量定义
*********************************************************************************/
u16 Iwdg_ScanKey = 0;
//OS_EVENT *s_stKeyTest ;
/********************************************************************************
* 函数定义
*********************************************************************************/
/***************************************************************************************
** 函数名称:ScanKey_task
** 功能描述：矩阵键盘扫描任务
** 函数输入：无
** 函数输出：无
** 注意事项：
******************************************************************************************/
void ScanKey_task(void *p_arg)
{
	u16 u16Status = LOGIC_STATUS_ININT;
//	u8  u8i= 0;
//	u8  test1 = 0;
//	u8 err;

	#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
		OS_CPU_SR  cpu_sr = 0;
	#endif

//	s_stKeyTest = OSSemCreate(0);
	
	while(u16Status == LOGIC_STATUS_ININT)
	{
		LogicRunInfApi(LOGIC_GET_RUN_STATUS,&u16Status);
		OSTimeDly(SCANKEY_TASK_TIME_SET/TICK_TIME);
	}
		
	while(1)
	{
		#ifdef	IWDG_ENABLED	
			OS_ENTER_CRITICAL();
			Iwdg_ScanKey = 0;
			OS_EXIT_CRITICAL();
		#endif
//	if(InterfaceGetCtrlMode() == INTERFACE_MODE_SC_SELF_CONTROL)//不是关机状态
//	{

//		for(test1 = 0;test1<10;test1++)
//		{
//			
////			u8i = u8i+3;
////			if(u8i>20)
////				u8i = 1;	
//			u8i = 3;
//			if(test1 == 0)
//			{
//				OSTimeDly(500/TICK_TIME);
//				AcceptKey(0x20,0x01);
//				OSSemPend(s_stKeyTest,550/TICK_TIME,&err);
//				if(err == OS_ERR_NONE)
//				{
//					OSTimeDly(u8i*100/TICK_TIME);
//					AcceptKey(0x20,0x00);
//				}
//			}
//			else
//			{
//				OSTimeDly(300/TICK_TIME);
//				AcceptKey(0x20,0x01);
//				OSSemPend(s_stKeyTest,550/TICK_TIME,&err);
//				if(err == OS_ERR_NONE)
//				{
//					OSTimeDly(u8i*100/TICK_TIME);
//					AcceptKey(0x20,0x00);
//				}
//			}	
//		}
//		test1 = 0;
//	}
//	else
		//执行周期10ms
		KeyScanProc();
		OSTimeDly(SCANKEY_TASK_TIME_SET/TICK_TIME);
	}
}

